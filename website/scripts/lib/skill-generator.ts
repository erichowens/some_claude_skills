/**
 * Skills.ts Generator
 *
 * Generates the website's skills.ts registry file from parsed skills.
 */

import * as fs from 'fs';
import * as path from 'path';
import { ParsedSkill, SKILL_CATEGORIES } from './types';

// =============================================================================
// SKILLS.TS GENERATION
// =============================================================================

export function generateSkillsTs(skills: ParsedSkill[], outputPath: string): void {
  const content = buildSkillsTsContent(skills);
  fs.writeFileSync(outputPath, content, 'utf-8');
}

function buildSkillsTsContent(skills: ParsedSkill[]): string {
  // Group skills by category
  const byCategory = groupByCategory(skills);

  // Build skills array
  const skillsArray = buildSkillsArray(byCategory);

  // Build category config
  const categoryConfig = buildCategoryConfig();

  // Build descriptions object inline
  const descriptionsObj: Record<string, string> = {};
  for (const skill of skills) {
    descriptionsObj[skill.id] = skill.description;
  }
  const descriptionsJson = JSON.stringify(descriptionsObj, null, 2);

  return `/**
 * Skills Registry
 *
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file is generated by scripts/generate-skills.ts from SKILL.md files.
 * To modify skills, edit the corresponding SKILL.md file and run:
 *   npm run skills:generate
 *
 * Generated: ${new Date().toISOString()}
 * Total Skills: ${skills.length}
 */

// =============================================================================
// TYPES
// =============================================================================

export interface SkillPairing {
  skill: string;
  reason: string;
}

export interface Skill {
  id: string;
  title: string;
  category: string;
  path: string;
  description: string;
  tags: string[];
  badge?: 'NEW' | 'HOT' | 'ADVANCED' | 'EXPERIMENTAL';
  pairsWith?: SkillPairing[];
  heroImage?: string;
}

export interface CategoryConfig {
  icon: string;
  description: string;
}

// =============================================================================
// SKILL DESCRIPTIONS (for dynamic lookup)
// =============================================================================

const skillDescriptions: Record<string, string> = ${descriptionsJson};

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Get description with fallback
 */
function getDesc(skillId: string, fallback: string): string {
  return skillDescriptions[skillId] || fallback;
}

// =============================================================================
// CATEGORY CONFIGURATION
// =============================================================================

export const categoryConfig: Record<string, CategoryConfig> = ${categoryConfig};

// =============================================================================
// SKILLS REGISTRY
// =============================================================================

export const skills: Skill[] = [
${skillsArray}
];

// Alias for backwards compatibility
export const ALL_SKILLS = skills;

// =============================================================================
// UTILITIES
// =============================================================================

export function getSkillById(id: string): Skill | undefined {
  return skills.find(skill => skill.id === id);
}

export function getSkillsByCategory(category: string): Skill[] {
  return skills.filter(skill => skill.category === category);
}

export function getSkillsByTag(tag: string): Skill[] {
  return skills.filter(skill => skill.tags.includes(tag));
}

export function getAllCategories(): string[] {
  return [...new Set(skills.map(skill => skill.category))];
}

export function getAllTags(): string[] {
  const tags = new Set<string>();
  skills.forEach(skill => skill.tags.forEach(tag => tags.add(tag)));
  return [...tags].sort();
}

export function searchSkills(query: string): Skill[] {
  const lowerQuery = query.toLowerCase();
  return skills.filter(skill =>
    skill.title.toLowerCase().includes(lowerQuery) ||
    skill.description.toLowerCase().includes(lowerQuery) ||
    skill.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
  );
}
`;
}

// =============================================================================
// HELPERS
// =============================================================================

function groupByCategory(skills: ParsedSkill[]): Map<string, ParsedSkill[]> {
  const byCategory = new Map<string, ParsedSkill[]>();

  // Initialize with known categories in order
  for (const category of Object.keys(SKILL_CATEGORIES)) {
    byCategory.set(category, []);
  }
  byCategory.set('Uncategorized', []);

  // Group skills
  for (const skill of skills) {
    const category = skill.category || 'Uncategorized';
    if (!byCategory.has(category)) {
      byCategory.set(category, []);
    }
    byCategory.get(category)!.push(skill);
  }

  // Sort skills within each category alphabetically
  for (const [, categorySkills] of byCategory) {
    categorySkills.sort((a, b) => a.title.localeCompare(b.title));
  }

  return byCategory;
}

function buildSkillsArray(byCategory: Map<string, ParsedSkill[]>): string {
  const lines: string[] = [];

  for (const [category, categorySkills] of byCategory) {
    if (categorySkills.length === 0) continue;

    const icon = SKILL_CATEGORIES[category]?.icon || 'ðŸ“¦';
    lines.push(`  // ${icon} ${category} (${categorySkills.length} skills)`);

    for (const skill of categorySkills) {
      lines.push(buildSkillEntry(skill));
    }

    lines.push('');
  }

  return lines.join('\n');
}

function buildSkillEntry(skill: ParsedSkill): string {
  const escapedDesc = escapeString(skill.shortDescription);
  const tags = skill.tags.map((t) => `'${t}'`).join(', ');
  const badge = skill.badge ? `, badge: '${skill.badge}'` : '';

  // Build pairsWith array if present
  let pairsWithStr = '';
  if (skill.pairsWith && skill.pairsWith.length > 0) {
    const pairs = skill.pairsWith.map(p =>
      `{ skill: '${escapeString(p.skill)}', reason: '${escapeString(p.reason)}' }`
    ).join(', ');
    pairsWithStr = `, pairsWith: [${pairs}]`;
  }

  // Check for hero image
  let heroImageStr = '';
  const staticDir = path.resolve(__dirname, '../../static/img/skills');
  const possibleExtensions = ['.png', '.webp', '.jpg', '.jpeg'];
  for (const ext of possibleExtensions) {
    const heroImagePath = path.join(staticDir, `${skill.id}-hero${ext}`);
    if (fs.existsSync(heroImagePath)) {
      heroImageStr = `, heroImage: '/img/skills/${skill.id}-hero${ext}'`;
      break;
    }
  }

  return `  { id: '${skill.id}', title: '${escapeString(skill.title)}', category: '${skill.category}', path: '${skill.urlPath}', description: getDesc('${skill.id}', '${escapedDesc}'), tags: [${tags}]${badge}${pairsWithStr}${heroImageStr} },`;
}

function buildCategoryConfig(): string {
  const entries: string[] = [];

  for (const [name, config] of Object.entries(SKILL_CATEGORIES)) {
    entries.push(`  '${name}': { icon: '${config.icon}', description: '${escapeString(config.description)}' }`);
  }

  return `{\n${entries.join(',\n')}\n}`;
}

function escapeString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/\n/g, '\\n');
}

// =============================================================================
// SKILL DESCRIPTIONS JSON
// =============================================================================

export function generateSkillDescriptionsJson(
  skills: ParsedSkill[],
  outputPath: string
): void {
  const descriptions: Record<string, string> = {};

  for (const skill of skills) {
    descriptions[skill.id] = skill.description;
  }

  const content = JSON.stringify(descriptions, null, 2);
  fs.writeFileSync(outputPath, content, 'utf-8');
}
