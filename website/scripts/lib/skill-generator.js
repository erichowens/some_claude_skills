"use strict";
/**
 * Skills.ts Generator
 *
 * Generates the website's skills.ts registry file from parsed skills.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSkillsTs = generateSkillsTs;
exports.generateSkillDescriptionsJson = generateSkillDescriptionsJson;
var fs = require("fs");
var path = require("path");
var types_1 = require("./types");
// =============================================================================
// SKILLS.TS GENERATION
// =============================================================================
function generateSkillsTs(skills, outputPath) {
    var content = buildSkillsTsContent(skills);
    fs.writeFileSync(outputPath, content, 'utf-8');
}
function buildSkillsTsContent(skills) {
    // Group skills by category
    var byCategory = groupByCategory(skills);
    // Build skills array
    var skillsArray = buildSkillsArray(byCategory);
    // Build category config
    var categoryConfig = buildCategoryConfig();
    // Build descriptions object inline
    var descriptionsObj = {};
    for (var _i = 0, skills_1 = skills; _i < skills_1.length; _i++) {
        var skill = skills_1[_i];
        descriptionsObj[skill.id] = skill.description;
    }
    var descriptionsJson = JSON.stringify(descriptionsObj, null, 2);
    return "/**\n * Skills Registry\n *\n * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY\n *\n * This file is generated by scripts/generate-skills.ts from SKILL.md files.\n * To modify skills, edit the corresponding SKILL.md file and run:\n *   npm run skills:generate\n *\n * Generated: ".concat(new Date().toISOString(), "\n * Total Skills: ").concat(skills.length, "\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface SkillPairing {\n  skill: string;\n  reason: string;\n}\n\nexport interface Skill {\n  id: string;\n  title: string;\n  category: string;\n  path: string;\n  description: string;\n  tags: string[];\n  badge?: 'NEW' | 'HOT' | 'ADVANCED' | 'EXPERIMENTAL';\n  pairsWith?: SkillPairing[];\n  heroImage?: string;\n}\n\nexport interface CategoryConfig {\n  icon: string;\n  description: string;\n}\n\n// =============================================================================\n// SKILL DESCRIPTIONS (for dynamic lookup)\n// =============================================================================\n\nconst skillDescriptions: Record<string, string> = ").concat(descriptionsJson, ";\n\n// =============================================================================\n// HELPERS\n// =============================================================================\n\n/**\n * Get description with fallback\n */\nfunction getDesc(skillId: string, fallback: string): string {\n  return skillDescriptions[skillId] || fallback;\n}\n\n// =============================================================================\n// CATEGORY CONFIGURATION\n// =============================================================================\n\nexport const categoryConfig: Record<string, CategoryConfig> = ").concat(categoryConfig, ";\n\n// =============================================================================\n// SKILLS REGISTRY\n// =============================================================================\n\nexport const skills: Skill[] = [\n").concat(skillsArray, "\n];\n\n// Alias for backwards compatibility\nexport const ALL_SKILLS = skills;\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\nexport function getSkillById(id: string): Skill | undefined {\n  return skills.find(skill => skill.id === id);\n}\n\nexport function getSkillsByCategory(category: string): Skill[] {\n  return skills.filter(skill => skill.category === category);\n}\n\nexport function getSkillsByTag(tag: string): Skill[] {\n  return skills.filter(skill => skill.tags.includes(tag));\n}\n\nexport function getAllCategories(): string[] {\n  return [...new Set(skills.map(skill => skill.category))];\n}\n\nexport function getAllTags(): string[] {\n  const tags = new Set<string>();\n  skills.forEach(skill => skill.tags.forEach(tag => tags.add(tag)));\n  return [...tags].sort();\n}\n\nexport function searchSkills(query: string): Skill[] {\n  const lowerQuery = query.toLowerCase();\n  return skills.filter(skill =>\n    skill.title.toLowerCase().includes(lowerQuery) ||\n    skill.description.toLowerCase().includes(lowerQuery) ||\n    skill.tags.some(tag => tag.toLowerCase().includes(lowerQuery))\n  );\n}\n");
}
// =============================================================================
// HELPERS
// =============================================================================
function groupByCategory(skills) {
    var byCategory = new Map();
    // Initialize with known categories in order
    for (var _i = 0, _a = Object.keys(types_1.SKILL_CATEGORIES); _i < _a.length; _i++) {
        var category = _a[_i];
        byCategory.set(category, []);
    }
    byCategory.set('Uncategorized', []);
    // Group skills
    for (var _b = 0, skills_2 = skills; _b < skills_2.length; _b++) {
        var skill = skills_2[_b];
        var category = skill.category || 'Uncategorized';
        if (!byCategory.has(category)) {
            byCategory.set(category, []);
        }
        byCategory.get(category).push(skill);
    }
    // Sort skills within each category alphabetically
    for (var _c = 0, byCategory_1 = byCategory; _c < byCategory_1.length; _c++) {
        var _d = byCategory_1[_c], categorySkills = _d[1];
        categorySkills.sort(function (a, b) { return a.title.localeCompare(b.title); });
    }
    return byCategory;
}
function buildSkillsArray(byCategory) {
    var _a;
    var lines = [];
    for (var _i = 0, byCategory_2 = byCategory; _i < byCategory_2.length; _i++) {
        var _b = byCategory_2[_i], category = _b[0], categorySkills = _b[1];
        if (categorySkills.length === 0)
            continue;
        var icon = ((_a = types_1.SKILL_CATEGORIES[category]) === null || _a === void 0 ? void 0 : _a.icon) || 'ðŸ“¦';
        lines.push("  // ".concat(icon, " ").concat(category, " (").concat(categorySkills.length, " skills)"));
        for (var _c = 0, categorySkills_1 = categorySkills; _c < categorySkills_1.length; _c++) {
            var skill = categorySkills_1[_c];
            lines.push(buildSkillEntry(skill));
        }
        lines.push('');
    }
    return lines.join('\n');
}
function buildSkillEntry(skill) {
    var escapedDesc = escapeString(skill.shortDescription);
    var tags = skill.tags.map(function (t) { return "'".concat(t, "'"); }).join(', ');
    var badge = skill.badge ? ", badge: '".concat(skill.badge, "'") : '';
    // Build pairsWith array if present
    var pairsWithStr = '';
    if (skill.pairsWith && skill.pairsWith.length > 0) {
        var pairs = skill.pairsWith.map(function (p) {
            return "{ skill: '".concat(escapeString(p.skill), "', reason: '").concat(escapeString(p.reason), "' }");
        }).join(', ');
        pairsWithStr = ", pairsWith: [".concat(pairs, "]");
    }
    // Check for hero image
    var heroImageStr = '';
    var staticDir = path.resolve(__dirname, '../../static/img/skills');
    var possibleExtensions = ['.png', '.webp', '.jpg', '.jpeg'];
    for (var _i = 0, possibleExtensions_1 = possibleExtensions; _i < possibleExtensions_1.length; _i++) {
        var ext = possibleExtensions_1[_i];
        var heroImagePath = path.join(staticDir, "".concat(skill.id, "-hero").concat(ext));
        if (fs.existsSync(heroImagePath)) {
            heroImageStr = ", heroImage: '/img/skills/".concat(skill.id, "-hero").concat(ext, "'");
            break;
        }
    }
    return "  { id: '".concat(skill.id, "', title: '").concat(escapeString(skill.title), "', category: '").concat(skill.category, "', path: '").concat(skill.urlPath, "', description: getDesc('").concat(skill.id, "', '").concat(escapedDesc, "'), tags: [").concat(tags, "]").concat(badge).concat(pairsWithStr).concat(heroImageStr, " },");
}
function buildCategoryConfig() {
    var entries = [];
    for (var _i = 0, _a = Object.entries(types_1.SKILL_CATEGORIES); _i < _a.length; _i++) {
        var _b = _a[_i], name_1 = _b[0], config = _b[1];
        entries.push("  '".concat(name_1, "': { icon: '").concat(config.icon, "', description: '").concat(escapeString(config.description), "' }"));
    }
    return "{\n".concat(entries.join(',\n'), "\n}");
}
function escapeString(str) {
    return str
        .replace(/\\/g, '\\\\')
        .replace(/'/g, "\\'")
        .replace(/\n/g, '\\n');
}
// =============================================================================
// SKILL DESCRIPTIONS JSON
// =============================================================================
function generateSkillDescriptionsJson(skills, outputPath) {
    var descriptions = {};
    for (var _i = 0, skills_3 = skills; _i < skills_3.length; _i++) {
        var skill = skills_3[_i];
        descriptions[skill.id] = skill.description;
    }
    var content = JSON.stringify(descriptions, null, 2);
    fs.writeFileSync(outputPath, content, 'utf-8');
}
