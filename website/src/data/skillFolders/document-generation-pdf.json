{
  "name": "document-generation-pdf",
  "type": "folder",
  "path": "document-generation-pdf",
  "children": [
    {
      "name": "assets",
      "type": "folder",
      "path": "document-generation-pdf/assets",
      "children": []
    },
    {
      "name": "references",
      "type": "folder",
      "path": "document-generation-pdf/references",
      "children": [
        {
          "name": "document-assembly.md",
          "type": "file",
          "path": "document-generation-pdf/references/document-assembly.md",
          "size": 15881,
          "content": "# Document Assembly\n\nComplete guide to merging PDFs, creating document packets, adding watermarks, and advanced PDF assembly techniques.\n\n## Use Cases\n\n- **Legal packets**: Petition + Evidence + Affidavits ‚Üí Single filing\n- **HR onboarding**: Offer letter + Benefits + Handbook ‚Üí Welcome packet\n- **Medical records**: Lab results + Scans + Reports ‚Üí Patient file\n- **Financial reports**: Balance sheet + Income + Cash flow ‚Üí Annual report\n\n---\n\n## Basic Merging\n\n### Merge PDFs with pdf-lib\n\n```typescript\nimport { PDFDocument } from 'pdf-lib';\nimport * as fs from 'fs';\n\nasync function mergePDFs(inputPaths: string[], outputPath: string) {\n  const mergedPdf = await PDFDocument.create();\n\n  for (const inputPath of inputPaths) {\n    // Load PDF\n    const pdfBytes = fs.readFileSync(inputPath);\n    const pdf = await PDFDocument.load(pdfBytes);\n\n    // Copy all pages\n    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());\n    copiedPages.forEach(page => mergedPdf.addPage(page));\n  }\n\n  // Save\n  const pdfBytes = await mergedPdf.save();\n  fs.writeFileSync(outputPath, pdfBytes);\n}\n\n// Usage\nawait mergePDFs([\n  'petition.pdf',\n  'evidence.pdf',\n  'affidavit.pdf'\n], 'filing_packet.pdf');\n```\n\n---\n\n## Selective Page Merging\n\n### Copy Specific Pages\n\n```typescript\nasync function mergeSpecificPages(\n  sources: Array<{ path: string; pages: number[] }>,\n  outputPath: string\n) {\n  const mergedPdf = await PDFDocument.create();\n\n  for (const source of sources) {\n    const pdfBytes = fs.readFileSync(source.path);\n    const pdf = await PDFDocument.load(pdfBytes);\n\n    // Convert to 0-based indices\n    const pageIndices = source.pages.map(p => p - 1);\n\n    // Copy selected pages\n    const copiedPages = await mergedPdf.copyPages(pdf, pageIndices);\n    copiedPages.forEach(page => mergedPdf.addPage(page));\n  }\n\n  const pdfBytes = await mergedPdf.save();\n  fs.writeFileSync(outputPath, pdfBytes);\n}\n\n// Usage\nawait mergeSpecificPages([\n  { path: 'report.pdf', pages: [1, 2, 3] },      // First 3 pages\n  { path: 'appendix.pdf', pages: [5, 6] },       // Pages 5-6\n  { path: 'summary.pdf', pages: [1] }            // Just page 1\n], 'compiled.pdf');\n```\n\n---\n\n## Cover Pages\n\n### Simple Cover Page\n\n```typescript\nasync function addCoverPage(\n  inputPath: string,\n  outputPath: string,\n  coverOptions: {\n    title: string;\n    subtitle?: string;\n    date?: string;\n  }\n) {\n  const existingPdfBytes = fs.readFileSync(inputPath);\n  const pdfDoc = await PDFDocument.load(existingPdfBytes);\n\n  // Create new document with cover\n  const newPdf = await PDFDocument.create();\n\n  // Add cover page (US Letter: 612 x 792 pts)\n  const coverPage = newPdf.addPage([612, 792]);\n\n  // Embed font\n  const helveticaBold = await newPdf.embedFont(StandardFonts.HelveticaBold);\n  const helvetica = await newPdf.embedFont(StandardFonts.Helvetica);\n\n  // Title (centered, 48pt)\n  const titleSize = 48;\n  const titleWidth = helveticaBold.widthOfTextAtSize(coverOptions.title, titleSize);\n  coverPage.drawText(coverOptions.title, {\n    x: (612 - titleWidth) / 2,\n    y: 600,\n    size: titleSize,\n    font: helveticaBold,\n    color: rgb(0, 0, 0)\n  });\n\n  // Subtitle (if provided)\n  if (coverOptions.subtitle) {\n    const subtitleSize = 18;\n    const subtitleWidth = helvetica.widthOfTextAtSize(coverOptions.subtitle, subtitleSize);\n    coverPage.drawText(coverOptions.subtitle, {\n      x: (612 - subtitleWidth) / 2,\n      y: 550,\n      size: subtitleSize,\n      font: helvetica,\n      color: rgb(0.3, 0.3, 0.3)\n    });\n  }\n\n  // Date (bottom)\n  const date = coverOptions.date || new Date().toLocaleDateString();\n  const dateSize = 12;\n  const dateWidth = helvetica.widthOfTextAtSize(date, dateSize);\n  coverPage.drawText(date, {\n    x: (612 - dateWidth) / 2,\n    y: 50,\n    size: dateSize,\n    font: helvetica,\n    color: rgb(0.5, 0.5, 0.5)\n  });\n\n  // Copy original pages\n  const copiedPages = await newPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());\n  copiedPages.forEach(page => newPdf.addPage(page));\n\n  // Save\n  const pdfBytes = await newPdf.save();\n  fs.writeFileSync(outputPath, pdfBytes);\n}\n```\n\n---\n\n## Watermarks\n\n### Text Watermark (All Pages)\n\n```typescript\nasync function addWatermark(\n  inputPath: string,\n  outputPath: string,\n  watermarkText: string,\n  options: {\n    opacity?: number;\n    rotation?: number;\n    fontSize?: number;\n  } = {}\n) {\n  const pdfBytes = fs.readFileSync(inputPath);\n  const pdfDoc = await PDFDocument.load(pdfBytes);\n\n  const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);\n\n  const fontSize = options.fontSize || 60;\n  const opacity = options.opacity !== undefined ? options.opacity : 0.3;\n  const rotation = options.rotation !== undefined ? options.rotation : -45;\n\n  const pages = pdfDoc.getPages();\n  const textWidth = font.widthOfTextAtSize(watermarkText, fontSize);\n\n  pages.forEach(page => {\n    const { width, height } = page.getSize();\n\n    // Center watermark\n    const x = (width - textWidth) / 2;\n    const y = height / 2;\n\n    page.drawText(watermarkText, {\n      x,\n      y,\n      size: fontSize,\n      font,\n      color: rgb(0.7, 0.7, 0.7),\n      opacity,\n      rotate: degrees(rotation)\n    });\n  });\n\n  const outputBytes = await pdfDoc.save();\n  fs.writeFileSync(outputPath, outputBytes);\n}\n\n// Usage\nawait addWatermark(\n  'confidential.pdf',\n  'confidential_watermarked.pdf',\n  'CONFIDENTIAL',\n  { opacity: 0.3, rotation: -45 }\n);\n```\n\n### Image Watermark (Logo)\n\n```typescript\nasync function addLogoWatermark(\n  inputPath: string,\n  outputPath: string,\n  logoPath: string,\n  position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' = 'bottom-right'\n) {\n  const pdfBytes = fs.readFileSync(inputPath);\n  const pdfDoc = await PDFDocument.load(pdfBytes);\n\n  // Embed logo\n  const logoBytes = fs.readFileSync(logoPath);\n  const logoImage = logoPath.endsWith('.png')\n    ? await pdfDoc.embedPng(logoBytes)\n    : await pdfDoc.embedJpg(logoBytes);\n\n  const logoWidth = 100;\n  const logoHeight = (logoImage.height / logoImage.width) * logoWidth;\n\n  const pages = pdfDoc.getPages();\n\n  pages.forEach(page => {\n    const { width, height } = page.getSize();\n\n    let x: number, y: number;\n\n    switch (position) {\n      case 'top-left':\n        x = 20;\n        y = height - logoHeight - 20;\n        break;\n      case 'top-right':\n        x = width - logoWidth - 20;\n        y = height - logoHeight - 20;\n        break;\n      case 'bottom-left':\n        x = 20;\n        y = 20;\n        break;\n      case 'bottom-right':\n        x = width - logoWidth - 20;\n        y = 20;\n        break;\n    }\n\n    page.drawImage(logoImage, {\n      x,\n      y,\n      width: logoWidth,\n      height: logoHeight,\n      opacity: 0.8\n    });\n  });\n\n  const outputBytes = await pdfDoc.save();\n  fs.writeFileSync(outputPath, outputBytes);\n}\n```\n\n---\n\n## Page Numbering\n\n### Add Page Numbers\n\n```typescript\nasync function addPageNumbers(\n  inputPath: string,\n  outputPath: string,\n  options: {\n    format?: string;  // \"{n}\", \"Page {n}\", \"{n} of {total}\"\n    position?: 'bottom-center' | 'bottom-right' | 'top-center';\n    start?: number;\n    fontSize?: number;\n  } = {}\n) {\n  const pdfBytes = fs.readFileSync(inputPath);\n  const pdfDoc = await PDFDocument.load(pdfBytes);\n\n  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n  const fontSize = options.fontSize || 10;\n  const position = options.position || 'bottom-center';\n  const start = options.start || 1;\n  const format = options.format || 'Page {n} of {total}';\n\n  const pages = pdfDoc.getPages();\n  const total = pages.length;\n\n  pages.forEach((page, index) => {\n    const { width, height } = page.getSize();\n    const pageNumber = start + index;\n\n    const text = format\n      .replace('{n}', pageNumber.toString())\n      .replace('{total}', total.toString());\n\n    const textWidth = font.widthOfTextAtSize(text, fontSize);\n\n    let x: number, y: number;\n\n    switch (position) {\n      case 'bottom-center':\n        x = (width - textWidth) / 2;\n        y = 30;\n        break;\n      case 'bottom-right':\n        x = width - textWidth - 50;\n        y = 30;\n        break;\n      case 'top-center':\n        x = (width - textWidth) / 2;\n        y = height - 50;\n        break;\n    }\n\n    page.drawText(text, {\n      x,\n      y,\n      size: fontSize,\n      font,\n      color: rgb(0, 0, 0)\n    });\n  });\n\n  const outputBytes = await pdfDoc.save();\n  fs.writeFileSync(outputPath, outputBytes);\n}\n```\n\n---\n\n## Table of Contents\n\n### Generate TOC from Bookmarks\n\n```typescript\nasync function createTableOfContents(\n  inputPath: string,\n  outputPath: string\n) {\n  const pdfBytes = fs.readFileSync(inputPath);\n  const pdfDoc = await PDFDocument.load(pdfBytes);\n\n  // Create new PDF with TOC\n  const newPdf = await PDFDocument.create();\n\n  // Add TOC page\n  const tocPage = newPdf.addPage([612, 792]);\n  const font = await newPdf.embedFont(StandardFonts.Helvetica);\n  const boldFont = await newPdf.embedFont(StandardFonts.HelveticaBold);\n\n  let yPosition = 750;\n\n  // Title\n  tocPage.drawText('Table of Contents', {\n    x: 50,\n    y: yPosition,\n    size: 18,\n    font: boldFont\n  });\n\n  yPosition -= 40;\n\n  // List sections (example - in real implementation, extract from PDF structure)\n  const sections = [\n    { title: 'Petition', page: 1 },\n    { title: 'Evidence', page: 5 },\n    { title: 'Affidavit', page: 12 },\n    { title: 'Exhibits', page: 15 }\n  ];\n\n  sections.forEach(section => {\n    tocPage.drawText(`${section.title}`, {\n      x: 50,\n      y: yPosition,\n      size: 12,\n      font\n    });\n\n    const pageText = `Page ${section.page}`;\n    const pageTextWidth = font.widthOfTextAtSize(pageText, 12);\n    tocPage.drawText(pageText, {\n      x: 500,\n      y: yPosition,\n      size: 12,\n      font\n    });\n\n    yPosition -= 20;\n  });\n\n  // Copy original pages\n  const copiedPages = await newPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());\n  copiedPages.forEach(page => newPdf.addPage(page));\n\n  const outputBytes = await newPdf.save();\n  fs.writeFileSync(outputPath, outputBytes);\n}\n```\n\n---\n\n## Metadata Preservation\n\n### Copy Metadata from Source\n\n```typescript\nasync function mergeWithMetadata(\n  inputPaths: string[],\n  outputPath: string\n) {\n  const mergedPdf = await PDFDocument.create();\n\n  // Load first PDF for metadata\n  const firstPdfBytes = fs.readFileSync(inputPaths[0]);\n  const firstPdf = await PDFDocument.load(firstPdfBytes);\n\n  // Copy metadata\n  if (firstPdf.getTitle()) mergedPdf.setTitle(firstPdf.getTitle());\n  if (firstPdf.getAuthor()) mergedPdf.setAuthor(firstPdf.getAuthor());\n  if (firstPdf.getSubject()) mergedPdf.setSubject(firstPdf.getSubject());\n  if (firstPdf.getCreator()) mergedPdf.setCreator(firstPdf.getCreator());\n  if (firstPdf.getProducer()) mergedPdf.setProducer(firstPdf.getProducer());\n\n  // Set new metadata\n  mergedPdf.setCreationDate(new Date());\n  mergedPdf.setModificationDate(new Date());\n  mergedPdf.setKeywords(['merged', 'document', 'packet']);\n\n  // Copy pages from all PDFs\n  for (const inputPath of inputPaths) {\n    const pdfBytes = fs.readFileSync(inputPath);\n    const pdf = await PDFDocument.load(pdfBytes);\n    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());\n    copiedPages.forEach(page => mergedPdf.addPage(page));\n  }\n\n  const pdfBytes = await mergedPdf.save();\n  fs.writeFileSync(outputPath, pdfBytes);\n}\n```\n\n---\n\n## Advanced Assembly\n\n### Complete Document Packet\n\n```typescript\ninterface PacketSection {\n  title: string;\n  file: string;\n  pages?: number[];  // If undefined, include all pages\n}\n\nasync function createDocumentPacket(\n  sections: PacketSection[],\n  outputPath: string,\n  options: {\n    addCover?: boolean;\n    packetTitle?: string;\n    addTOC?: boolean;\n    addPageNumbers?: boolean;\n    watermark?: string;\n  } = {}\n) {\n  const finalPdf = await PDFDocument.create();\n\n  // 1. Add cover page\n  if (options.addCover) {\n    const coverPage = finalPdf.addPage([612, 792]);\n    const font = await finalPdf.embedFont(StandardFonts.HelveticaBold);\n\n    const title = options.packetTitle || 'Document Packet';\n    const titleSize = 36;\n    const titleWidth = font.widthOfTextAtSize(title, titleSize);\n\n    coverPage.drawText(title, {\n      x: (612 - titleWidth) / 2,\n      y: 600,\n      size: titleSize,\n      font,\n      color: rgb(0, 0, 0)\n    });\n  }\n\n  // 2. Add TOC page\n  if (options.addTOC) {\n    const tocPage = finalPdf.addPage([612, 792]);\n    const font = await finalPdf.embedFont(StandardFonts.Helvetica);\n    const boldFont = await finalPdf.embedFont(StandardFonts.HelveticaBold);\n\n    let yPosition = 750;\n    tocPage.drawText('Table of Contents', {\n      x: 50,\n      y: yPosition,\n      size: 18,\n      font: boldFont\n    });\n\n    yPosition -= 40;\n\n    let currentPage = options.addCover ? 2 : 1;\n    if (options.addTOC) currentPage++;\n\n    sections.forEach(section => {\n      tocPage.drawText(section.title, {\n        x: 50,\n        y: yPosition,\n        size: 12,\n        font\n      });\n\n      tocPage.drawText(`Page ${currentPage}`, {\n        x: 500,\n        y: yPosition,\n        size: 12,\n        font\n      });\n\n      yPosition -= 20;\n\n      // Count pages for this section\n      const pdfBytes = fs.readFileSync(section.file);\n      const pdf = PDFDocument.load(pdfBytes);\n      // In real implementation, await and count pages\n    });\n  }\n\n  // 3. Add sections\n  for (const section of sections) {\n    const pdfBytes = fs.readFileSync(section.file);\n    const pdf = await PDFDocument.load(pdfBytes);\n\n    const pageIndices = section.pages\n      ? section.pages.map(p => p - 1)\n      : pdf.getPageIndices();\n\n    const copiedPages = await finalPdf.copyPages(pdf, pageIndices);\n    copiedPages.forEach(page => finalPdf.addPage(page));\n  }\n\n  // 4. Add watermark\n  if (options.watermark) {\n    const font = await finalPdf.embedFont(StandardFonts.HelveticaBold);\n    const pages = finalPdf.getPages();\n\n    pages.forEach(page => {\n      const { width, height } = page.getSize();\n      const textWidth = font.widthOfTextAtSize(options.watermark!, 60);\n\n      page.drawText(options.watermark!, {\n        x: (width - textWidth) / 2,\n        y: height / 2,\n        size: 60,\n        font,\n        color: rgb(0.7, 0.7, 0.7),\n        opacity: 0.3,\n        rotate: degrees(-45)\n      });\n    });\n  }\n\n  // 5. Add page numbers\n  if (options.addPageNumbers) {\n    const font = await finalPdf.embedFont(StandardFonts.Helvetica);\n    const pages = finalPdf.getPages();\n    const total = pages.length;\n\n    pages.forEach((page, index) => {\n      const { width } = page.getSize();\n      const pageNumber = index + 1;\n      const text = `Page ${pageNumber} of ${total}`;\n      const textWidth = font.widthOfTextAtSize(text, 10);\n\n      page.drawText(text, {\n        x: (width - textWidth) / 2,\n        y: 30,\n        size: 10,\n        font,\n        color: rgb(0, 0, 0)\n      });\n    });\n  }\n\n  // 6. Save\n  const pdfBytes = await finalPdf.save();\n  fs.writeFileSync(outputPath, pdfBytes);\n}\n\n// Usage\nawait createDocumentPacket(\n  [\n    { title: 'Petition', file: 'petition.pdf' },\n    { title: 'Evidence', file: 'evidence.pdf', pages: [1, 2, 3] },\n    { title: 'Affidavit', file: 'affidavit.pdf' }\n  ],\n  'filing_packet.pdf',\n  {\n    addCover: true,\n    packetTitle: 'Expungement Filing Packet',\n    addTOC: true,\n    addPageNumbers: true,\n    watermark: 'DRAFT'\n  }\n);\n```\n\n---\n\n## Performance Tips\n\n1. **Reuse embedded fonts** across pages\n2. **Batch page operations** instead of one-by-one\n3. **Load PDFs once** if using same source multiple times\n4. **Save at the end** (don't save after each operation)\n\n**Benchmark** (100 merges):\n- Save after each: 45 seconds\n- Save at end: 3 seconds\n\n---\n\n## Resources\n\n- [pdf-lib Merging](https://pdf-lib.js.org/docs/api/classes/pdfdocument#copypages)\n- [Watermarking Guide](https://pdf-lib.js.org/docs/api/classes/pdfpage#drawtext)\n- [Metadata API](https://pdf-lib.js.org/docs/api/classes/pdfdocument#setauthor)\n"
        },
        {
          "name": "pdf-lib-guide.md",
          "type": "file",
          "path": "document-generation-pdf/references/pdf-lib-guide.md",
          "size": 12647,
          "content": "# pdf-lib Guide\n\nComplete guide to pdf-lib for form filling, field manipulation, encryption, and PDF generation.\n\n## Installation\n\n```bash\nnpm install pdf-lib\n```\n\n**Latest version**: 1.17.1 (Jan 2024)\n\n---\n\n## Basic Form Filling\n\n### Loading and Saving\n\n```typescript\nimport { PDFDocument } from 'pdf-lib';\nimport * as fs from 'fs';\n\n// Load existing PDF\nconst existingPdfBytes = fs.readFileSync('template.pdf');\nconst pdfDoc = await PDFDocument.load(existingPdfBytes);\n\n// Get form\nconst form = pdfDoc.getForm();\n\n// ... fill fields ...\n\n// Save\nconst pdfBytes = await pdfDoc.save();\nfs.writeFileSync('filled.pdf', pdfBytes);\n```\n\n---\n\n## Form Field Types\n\n### Text Fields\n\n```typescript\n// Get text field\nconst nameField = form.getTextField('applicant_name');\n\n// Set text\nnameField.setText('John Doe');\n\n// Get current value\nconst name = nameField.getText();\n\n// Max length\nconst maxLength = nameField.getMaxLength();\n\n// Set alignment\nnameField.setAlignment(Alignment.Center);  // Left, Center, Right\n\n// Set font size\nnameField.setFontSize(12);\n\n// Enable multiline\nnameField.enableMultiline();\n\n// Disable read-only\nnameField.enableReadOnly(false);\n```\n\n**Common text fields**:\n- Name, address, phone\n- Dates (as text)\n- Case numbers\n- Comments/notes\n\n---\n\n### Check Boxes\n\n```typescript\n// Get checkbox\nconst consentCheckbox = form.getCheckBox('consent_checkbox');\n\n// Check\nconsentCheckbox.check();\n\n// Uncheck\nconsentCheckbox.uncheck();\n\n// Get state\nconst isChecked = consentCheckbox.isChecked();\n```\n\n**Use cases**:\n- Yes/No questions\n- Consent forms\n- Attestations\n- Option selections\n\n---\n\n### Radio Groups\n\n```typescript\n// Get radio group\nconst employmentStatus = form.getRadioGroup('employment_status');\n\n// Get options\nconst options = employmentStatus.getOptions();\n// Returns: ['employed', 'unemployed', 'self_employed', 'retired']\n\n// Select option\nemploymentStatus.select('employed');\n\n// Get selected\nconst selected = employmentStatus.getSelected();\n\n// Clear selection\nemploymentStatus.clear();\n```\n\n**Use cases**:\n- Multiple choice (one answer)\n- Yes/No/Maybe\n- Option groups\n\n---\n\n### Dropdown Fields\n\n```typescript\n// Get dropdown\nconst stateDropdown = form.getDropdown('state');\n\n// Get options\nconst options = stateDropdown.getOptions();\n// Returns: ['CA', 'NY', 'TX', ...]\n\n// Select single option\nstateDropdown.select('CA');\n\n// Select multiple (if multiselect enabled)\nstateDropdown.select(['CA', 'NY']);\n\n// Get selected\nconst selected = stateDropdown.getSelected();\n// Returns: ['CA']\n\n// Clear\nstateDropdown.clear();\n\n// Enable multiselect\nstateDropdown.enableMultiselect();\n```\n\n**Use cases**:\n- State/country selection\n- Predefined options\n- Category selection\n\n---\n\n## Form Flattening\n\n**Critical**: Flatten forms after filling to prevent user edits.\n\n```typescript\n// Fill form\nform.getTextField('name').setText('John Doe');\nform.getCheckBox('consent').check();\n\n// Flatten (make non-editable)\nform.flatten();\n\n// Save\nconst pdfBytes = await pdfDoc.save();\n```\n\n**What flattening does**:\n1. Converts form fields to static text/graphics\n2. Removes interactive field widgets\n3. Preserves visual appearance\n4. Makes document non-editable\n\n**When NOT to flatten**:\n- Draft documents (user needs to review/edit)\n- Multi-step workflows (partial completion)\n- Templates for manual filling\n\n---\n\n## Inspecting Forms\n\n### List All Fields\n\n```typescript\nconst fields = form.getFields();\n\nfields.forEach(field => {\n  const name = field.getName();\n  const type = field.constructor.name;  // PDFTextField, PDFCheckBox, etc.\n\n  console.log(`${name} (${type})`);\n\n  // Field-specific details\n  if (field instanceof PDFTextField) {\n    console.log(`  Value: \"${field.getText()}\"`);\n    console.log(`  Max length: ${field.getMaxLength()}`);\n  }\n});\n```\n\n### Get Field by Name\n\n```typescript\ntry {\n  const field = form.getField('field_name');\n\n  // Check type\n  if (field instanceof PDFTextField) {\n    // Text field operations\n  } else if (field instanceof PDFCheckBox) {\n    // Checkbox operations\n  } else if (field instanceof PDFDropdown) {\n    // Dropdown operations\n  } else if (field instanceof PDFRadioGroup) {\n    // Radio group operations\n  }\n} catch (err) {\n  console.error('Field not found:', err.message);\n}\n```\n\n---\n\n## Creating Forms\n\n### Add Text Field\n\n```typescript\nconst textField = form.createTextField('new_field');\n\ntextField.addToPage(page, {\n  x: 100,\n  y: 500,\n  width: 200,\n  height: 30\n});\n\ntextField.setText('Default value');\ntextField.setFontSize(12);\n```\n\n### Add Checkbox\n\n```typescript\nconst checkbox = form.createCheckBox('new_checkbox');\n\ncheckbox.addToPage(page, {\n  x: 100,\n  y: 450,\n  width: 20,\n  height: 20\n});\n\ncheckbox.check();\n```\n\n### Add Dropdown\n\n```typescript\nconst dropdown = form.createDropdown('new_dropdown');\n\ndropdown.addToPage(page, {\n  x: 100,\n  y: 400,\n  width: 150,\n  height: 25\n});\n\ndropdown.addOptions(['Option 1', 'Option 2', 'Option 3']);\ndropdown.select('Option 1');\n```\n\n---\n\n## PDF Encryption\n\n### Password Protection\n\n```typescript\nconst pdfBytes = await pdfDoc.save({\n  userPassword: 'user123',     // Password to open PDF\n  ownerPassword: 'owner456',   // Password to change permissions\n  permissions: {\n    printing: 'highResolution',        // 'lowResolution' | 'highResolution' | false\n    modifying: false,                  // Prevent modifications\n    copying: false,                    // Prevent text/image copying\n    annotating: false,                 // Prevent annotations\n    fillingForms: false,               // Prevent form filling\n    contentAccessibility: true,        // Allow screen readers\n    documentAssembly: false            // Prevent page insertion/deletion\n  }\n});\n```\n\n**Permission levels**:\n- `'highResolution'` - Allow high-quality printing\n- `'lowResolution'` - Allow low-quality printing only\n- `false` - Disallow\n\n**Use cases**:\n- Legal documents: Prevent editing\n- Confidential files: Require password\n- HIPAA compliance: Restrict copying\n- Public records: Allow reading only\n\n---\n\n## Fonts and Styling\n\n### Embed Standard Fonts\n\n```typescript\nimport { StandardFonts } from 'pdf-lib';\n\nconst helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);\nconst helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);\nconst timesRoman = await pdfDoc.embedFont(StandardFonts.TimesRoman);\nconst courier = await pdfDoc.embedFont(StandardFonts.Courier);\n```\n\n**Standard fonts** (always available):\n- Helvetica, Helvetica-Bold, Helvetica-Oblique, Helvetica-BoldOblique\n- Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic\n- Courier, Courier-Bold, Courier-Oblique, Courier-BoldOblique\n\n### Embed Custom Fonts\n\n```typescript\nconst fontBytes = fs.readFileSync('CustomFont.ttf');\nconst customFont = await pdfDoc.embedFont(fontBytes);\n\n// Use in text field\ntextField.updateWidgets({\n  defaultAppearance: PDFTextField.createDefaultAppearance(customFont, 12)\n});\n```\n\n---\n\n## Adding Images\n\n```typescript\n// Embed PNG\nconst pngImageBytes = fs.readFileSync('logo.png');\nconst pngImage = await pdfDoc.embedPng(pngImageBytes);\n\n// Embed JPEG\nconst jpgImageBytes = fs.readFileSync('signature.jpg');\nconst jpgImage = await pdfDoc.embedJpg(jpgImageBytes);\n\n// Draw on page\nconst page = pdfDoc.getPage(0);\n\npage.drawImage(pngImage, {\n  x: 100,\n  y: 200,\n  width: 150,\n  height: 50\n});\n```\n\n**Use cases**:\n- Company logos\n- Signature images\n- Diagrams\n- Photos\n\n---\n\n## Creating PDFs from Scratch\n\n```typescript\nconst pdfDoc = await PDFDocument.create();\n\n// Add blank page (US Letter: 612 x 792 points)\nconst page = pdfDoc.addPage([612, 792]);\n\n// Draw text\nconst helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);\n\npage.drawText('Hello, World!', {\n  x: 50,\n  y: 750,\n  size: 24,\n  font: helvetica,\n  color: rgb(0, 0, 0)\n});\n\n// Draw rectangle\npage.drawRectangle({\n  x: 50,\n  y: 700,\n  width: 200,\n  height: 100,\n  borderColor: rgb(0, 0, 0),\n  borderWidth: 2,\n  color: rgb(0.95, 0.95, 0.95)\n});\n\n// Save\nconst pdfBytes = await pdfDoc.save();\n```\n\n**Coordinate system**:\n- Origin (0, 0) is bottom-left\n- X increases right\n- Y increases up\n- Units: points (1 pt = 1/72 inch)\n\n---\n\n## Merging PDFs\n\n```typescript\nconst mergedPdf = await PDFDocument.create();\n\n// Load source PDFs\nconst pdf1Bytes = fs.readFileSync('doc1.pdf');\nconst pdf1 = await PDFDocument.load(pdf1Bytes);\n\nconst pdf2Bytes = fs.readFileSync('doc2.pdf');\nconst pdf2 = await PDFDocument.load(pdf2Bytes);\n\n// Copy pages\nconst copiedPages1 = await mergedPdf.copyPages(pdf1, pdf1.getPageIndices());\ncopiedPages1.forEach(page => mergedPdf.addPage(page));\n\nconst copiedPages2 = await mergedPdf.copyPages(pdf2, pdf2.getPageIndices());\ncopiedPages2.forEach(page => mergedPdf.addPage(page));\n\n// Save\nconst pdfBytes = await mergedPdf.save();\n```\n\n---\n\n## Metadata\n\n```typescript\n// Set metadata\npdfDoc.setTitle('Petition for Expungement');\npdfDoc.setAuthor('John Doe');\npdfDoc.setSubject('Legal Document');\npdfDoc.setKeywords(['expungement', 'legal', 'petition']);\npdfDoc.setProducer('Expungement Guide');\npdfDoc.setCreator('pdf-lib');\npdfDoc.setCreationDate(new Date());\npdfDoc.setModificationDate(new Date());\n\n// Get metadata\nconst title = pdfDoc.getTitle();\nconst author = pdfDoc.getAuthor();\n```\n\n---\n\n## Save Options\n\n```typescript\nconst pdfBytes = await pdfDoc.save({\n  // Optimize for file size\n  useObjectStreams: false,\n\n  // Encryption\n  userPassword: 'user123',\n  ownerPassword: 'owner456',\n  permissions: { /* ... */ },\n\n  // Update existing PDF (instead of creating new)\n  updateFieldAppearances: false,\n\n  // Add metadata\n  addDefaultPage: false\n});\n```\n\n---\n\n## Common Patterns\n\n### Batch Processing\n\n```typescript\nasync function batchFillForms(\n  templatePath: string,\n  dataFiles: string[],\n  outputDir: string\n) {\n  const templateBytes = fs.readFileSync(templatePath);\n\n  for (const dataFile of dataFiles) {\n    // Load template\n    const pdfDoc = await PDFDocument.load(templateBytes);\n    const form = pdfDoc.getForm();\n\n    // Load data\n    const data = JSON.parse(fs.readFileSync(dataFile, 'utf-8'));\n\n    // Fill fields\n    for (const [field, value] of Object.entries(data)) {\n      try {\n        const fieldObj = form.getField(field);\n        if (fieldObj instanceof PDFTextField) {\n          fieldObj.setText(String(value));\n        } else if (fieldObj instanceof PDFCheckBox) {\n          if (value) fieldObj.check();\n        }\n      } catch (err) {\n        console.warn(`Field ${field} not found`);\n      }\n    }\n\n    // Flatten and save\n    form.flatten();\n    const pdfBytes = await pdfDoc.save();\n\n    const outputPath = path.join(outputDir, path.basename(dataFile, '.json') + '.pdf');\n    fs.writeFileSync(outputPath, pdfBytes);\n  }\n}\n```\n\n### Conditional Fields\n\n```typescript\nconst form = pdfDoc.getForm();\n\n// Show field if condition met\nconst hasPriorConvictions = data.prior_convictions === 'yes';\n\nif (hasPriorConvictions) {\n  form.getTextField('conviction_details').setText(data.conviction_details);\n  form.getTextField('conviction_date').setText(data.conviction_date);\n} else {\n  // Hide/disable fields\n  const detailsField = form.getTextField('conviction_details');\n  detailsField.setText('N/A');\n  detailsField.enableReadOnly();\n}\n```\n\n### Signature Placeholders\n\n```typescript\n// Add signature field\nconst signatureField = form.createTextField('applicant_signature');\n\nsignatureField.addToPage(page, {\n  x: 100,\n  y: 100,\n  width: 200,\n  height: 50\n});\n\n// Add border for visual indication\nsignatureField.updateWidgets({\n  borderWidth: 1,\n  borderColor: rgb(0, 0, 0)\n});\n\n// Add placeholder text\nsignatureField.setText('________________________________________');\n\n// Mark as required\nsignatureField.enableRequired();\n```\n\n---\n\n## Error Handling\n\n```typescript\ntry {\n  const pdfDoc = await PDFDocument.load(pdfBytes);\n  const form = pdfDoc.getForm();\n\n  try {\n    const field = form.getField('field_name');\n    // ... use field\n  } catch (err) {\n    console.error('Field not found:', err.message);\n    // Continue with other fields\n  }\n\n  const outputBytes = await pdfDoc.save();\n} catch (err) {\n  console.error('Failed to load PDF:', err.message);\n  throw err;\n}\n```\n\n---\n\n## Performance Tips\n\n1. **Reuse loaded templates** for batch processing\n2. **Don't flatten** until the very end\n3. **Use object streams** for smaller file size\n4. **Embed fonts once** per document\n5. **Batch save operations** (don't save after each field)\n\n**Benchmark** (1000 forms):\n- Reuse template: 5 seconds\n- Reload template each time: 45 seconds\n\n---\n\n## Resources\n\n- [pdf-lib Documentation](https://pdf-lib.js.org/)\n- [GitHub Repository](https://github.com/Hopding/pdf-lib)\n- [Form Examples](https://pdf-lib.js.org/docs/api/classes/pdfform)\n"
        },
        {
          "name": "puppeteer-templates.md",
          "type": "file",
          "path": "document-generation-pdf/references/puppeteer-templates.md",
          "size": 12362,
          "content": "# Puppeteer PDF Templates\n\nComplete guide to generating PDFs from HTML using Puppeteer with templates, page breaks, and print styling.\n\n## When to Use Puppeteer\n\n‚úÖ **Use Puppeteer for**:\n- Invoices with complex layouts\n- Reports with charts/graphs\n- Certificates with custom designs\n- Documents requiring HTML/CSS flexibility\n\n‚ùå **Don't use Puppeteer for**:\n- Simple form filling (use pdf-lib)\n- Government forms (use pdf-lib)\n- Batch processing 1000+ documents (too slow)\n\n---\n\n## Installation\n\n```bash\nnpm install puppeteer\n```\n\n**Latest version**: 21.6.1 (Jan 2024)\n\n**Bundle size**: ~300MB (includes Chromium)\n\n---\n\n## Basic Usage\n\n```typescript\nimport puppeteer from 'puppeteer';\n\nasync function generatePDF(htmlContent: string, outputPath: string) {\n  const browser = await puppeteer.launch({\n    headless: true,\n    args: ['--no-sandbox', '--disable-setuid-sandbox']\n  });\n\n  const page = await browser.newPage();\n\n  // Load HTML\n  await page.setContent(htmlContent, {\n    waitUntil: 'networkidle0'  // Wait for resources to load\n  });\n\n  // Generate PDF\n  await page.pdf({\n    path: outputPath,\n    format: 'A4',\n    printBackground: true,\n    margin: {\n      top: '1in',\n      right: '1in',\n      bottom: '1in',\n      left: '1in'\n    }\n  });\n\n  await browser.close();\n}\n```\n\n---\n\n## Page Formats\n\n```typescript\n// Standard formats\nawait page.pdf({\n  format: 'Letter',  // 8.5\" x 11\" (US)\n  // or: 'A4', 'A3', 'Legal', 'Tabloid'\n});\n\n// Custom size\nawait page.pdf({\n  width: '8.5in',\n  height: '11in'\n});\n\n// Landscape\nawait page.pdf({\n  format: 'Letter',\n  landscape: true\n});\n```\n\n**Common formats**:\n| Format | Size (inches) | Size (mm) |\n|--------|---------------|-----------|\n| Letter | 8.5 √ó 11 | 216 √ó 279 |\n| A4 | 8.27 √ó 11.69 | 210 √ó 297 |\n| Legal | 8.5 √ó 14 | 216 √ó 356 |\n| A3 | 11.69 √ó 16.54 | 297 √ó 420 |\n\n---\n\n## Print CSS\n\n### Critical @media print Rule\n\n```html\n<style>\n  @media print {\n    /* Print-specific styles */\n    .no-print {\n      display: none !important;\n    }\n\n    body {\n      font-size: 12pt;\n      color: black;\n    }\n\n    /* Force page breaks */\n    .page-break {\n      page-break-after: always;\n    }\n\n    /* Avoid breaking inside elements */\n    .avoid-break {\n      page-break-inside: avoid;\n    }\n\n    /* Keep headings with content */\n    h1, h2, h3, h4, h5, h6 {\n      page-break-after: avoid;\n      page-break-inside: avoid;\n    }\n\n    /* Keep tables together */\n    table, figure {\n      page-break-inside: avoid;\n    }\n\n    /* Avoid breaking after first line of paragraph */\n    p {\n      orphans: 3;\n      widows: 3;\n    }\n  }\n</style>\n```\n\n---\n\n## Page Break Control\n\n### Force Page Break\n\n```html\n<style>\n  @media print {\n    .page-break {\n      page-break-after: always;\n    }\n  }\n</style>\n\n<section>\n  <h1>Section 1</h1>\n  <p>Content...</p>\n</section>\n\n<div class=\"page-break\"></div>\n\n<section>\n  <h1>Section 2</h1>\n  <p>Content...</p>\n</section>\n```\n\n### Avoid Page Break\n\n```html\n<style>\n  @media print {\n    .avoid-break {\n      page-break-inside: avoid;\n    }\n  }\n</style>\n\n<section class=\"avoid-break\">\n  <h2>Terms and Conditions</h2>\n  <ol>\n    <li>This entire section stays together</li>\n    <li>No page breaks in the middle</li>\n  </ol>\n</section>\n```\n\n### Page Break Properties\n\n```css\n@media print {\n  /* Before element */\n  .new-page-before {\n    page-break-before: always;\n  }\n\n  /* After element */\n  .new-page-after {\n    page-break-after: always;\n  }\n\n  /* Inside element */\n  .no-break-inside {\n    page-break-inside: avoid;\n  }\n\n  /* Control orphans/widows */\n  p {\n    orphans: 3;  /* Min lines at bottom of page */\n    widows: 3;   /* Min lines at top of page */\n  }\n}\n```\n\n---\n\n## Invoice Template\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n    }\n\n    body {\n      font-family: Arial, sans-serif;\n      font-size: 12pt;\n      line-height: 1.5;\n      color: #333;\n    }\n\n    .invoice {\n      max-width: 8.5in;\n      margin: 0 auto;\n      padding: 0.5in;\n    }\n\n    .header {\n      display: flex;\n      justify-content: space-between;\n      margin-bottom: 1in;\n      border-bottom: 2px solid #000;\n      padding-bottom: 0.25in;\n    }\n\n    .company-info h1 {\n      font-size: 24pt;\n      margin-bottom: 0.1in;\n    }\n\n    .invoice-info {\n      text-align: right;\n    }\n\n    .invoice-number {\n      font-size: 18pt;\n      font-weight: bold;\n      margin-bottom: 0.1in;\n    }\n\n    .billing-info {\n      display: flex;\n      justify-content: space-between;\n      margin-bottom: 0.5in;\n    }\n\n    .items-table {\n      width: 100%;\n      border-collapse: collapse;\n      margin-bottom: 0.5in;\n    }\n\n    .items-table th {\n      background: #f0f0f0;\n      padding: 0.1in;\n      text-align: left;\n      border-bottom: 2px solid #000;\n    }\n\n    .items-table td {\n      padding: 0.1in;\n      border-bottom: 1px solid #ddd;\n    }\n\n    .items-table .amount {\n      text-align: right;\n    }\n\n    .total-section {\n      margin-left: auto;\n      width: 3in;\n    }\n\n    .total-row {\n      display: flex;\n      justify-content: space-between;\n      padding: 0.05in 0;\n    }\n\n    .total-row.grand-total {\n      font-size: 14pt;\n      font-weight: bold;\n      border-top: 2px solid #000;\n      padding-top: 0.1in;\n      margin-top: 0.1in;\n    }\n\n    .footer {\n      margin-top: 1in;\n      padding-top: 0.25in;\n      border-top: 1px solid #ddd;\n      font-size: 10pt;\n      color: #666;\n    }\n\n    @media print {\n      body {\n        print-color-adjust: exact;\n        -webkit-print-color-adjust: exact;\n      }\n\n      .items-table {\n        page-break-inside: avoid;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"invoice\">\n    <div class=\"header\">\n      <div class=\"company-info\">\n        <h1>{{company_name}}</h1>\n        <p>{{company_address}}</p>\n        <p>{{company_phone}}</p>\n        <p>{{company_email}}</p>\n      </div>\n      <div class=\"invoice-info\">\n        <div class=\"invoice-number\">Invoice #{{invoice_number}}</div>\n        <p>Date: {{invoice_date}}</p>\n        <p>Due: {{due_date}}</p>\n      </div>\n    </div>\n\n    <div class=\"billing-info\">\n      <div class=\"bill-to\">\n        <strong>Bill To:</strong><br>\n        {{customer_name}}<br>\n        {{customer_address}}<br>\n        {{customer_phone}}\n      </div>\n      <div class=\"ship-to\">\n        <strong>Ship To:</strong><br>\n        {{shipping_name}}<br>\n        {{shipping_address}}\n      </div>\n    </div>\n\n    <table class=\"items-table\">\n      <thead>\n        <tr>\n          <th>Description</th>\n          <th>Qty</th>\n          <th class=\"amount\">Unit Price</th>\n          <th class=\"amount\">Amount</th>\n        </tr>\n      </thead>\n      <tbody>\n        {{#each items}}\n        <tr>\n          <td>{{description}}</td>\n          <td>{{quantity}}</td>\n          <td class=\"amount\">${{unit_price}}</td>\n          <td class=\"amount\">${{amount}}</td>\n        </tr>\n        {{/each}}\n      </tbody>\n    </table>\n\n    <div class=\"total-section\">\n      <div class=\"total-row\">\n        <span>Subtotal:</span>\n        <span>${{subtotal}}</span>\n      </div>\n      <div class=\"total-row\">\n        <span>Tax ({{tax_rate}}%):</span>\n        <span>${{tax_amount}}</span>\n      </div>\n      <div class=\"total-row grand-total\">\n        <span>Total:</span>\n        <span>${{total}}</span>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <p>Thank you for your business!</p>\n      <p>Payment due within 30 days. Please make checks payable to {{company_name}}.</p>\n    </div>\n  </div>\n</body>\n</html>\n```\n\n---\n\n## Certificate Template\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    @page {\n      size: 11in 8.5in landscape;\n      margin: 0;\n    }\n\n    body {\n      font-family: 'Georgia', serif;\n      margin: 0;\n      padding: 0;\n      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);\n    }\n\n    .certificate {\n      width: 11in;\n      height: 8.5in;\n      padding: 1in;\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      text-align: center;\n      border: 20px double #333;\n      background: white;\n    }\n\n    .title {\n      font-size: 48pt;\n      font-weight: bold;\n      color: #2c3e50;\n      margin-bottom: 0.5in;\n      text-transform: uppercase;\n      letter-spacing: 0.1in;\n    }\n\n    .subtitle {\n      font-size: 20pt;\n      color: #7f8c8d;\n      margin-bottom: 0.75in;\n    }\n\n    .recipient {\n      font-size: 36pt;\n      font-weight: bold;\n      color: #34495e;\n      margin-bottom: 0.5in;\n      font-style: italic;\n    }\n\n    .description {\n      font-size: 16pt;\n      color: #555;\n      max-width: 8in;\n      margin-bottom: 0.75in;\n      line-height: 1.6;\n    }\n\n    .footer {\n      display: flex;\n      justify-content: space-around;\n      width: 100%;\n      max-width: 8in;\n      margin-top: 0.5in;\n    }\n\n    .signature-line {\n      text-align: center;\n    }\n\n    .line {\n      border-top: 2px solid #333;\n      width: 2.5in;\n      margin-bottom: 0.1in;\n    }\n\n    @media print {\n      body {\n        print-color-adjust: exact;\n        -webkit-print-color-adjust: exact;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"certificate\">\n    <div class=\"title\">Certificate of Completion</div>\n    <div class=\"subtitle\">This is to certify that</div>\n    <div class=\"recipient\">{{recipient_name}}</div>\n    <div class=\"description\">\n      has successfully completed the {{course_name}} program\n      on {{completion_date}} with a score of {{score}}%.\n    </div>\n    <div class=\"footer\">\n      <div class=\"signature-line\">\n        <div class=\"line\"></div>\n        <div>Instructor Signature</div>\n        <div>{{instructor_name}}</div>\n      </div>\n      <div class=\"signature-line\">\n        <div class=\"line\"></div>\n        <div>Date</div>\n        <div>{{issue_date}}</div>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n```\n\n---\n\n## Template Engine Integration\n\n### Handlebars\n\n```typescript\nimport handlebars from 'handlebars';\n\nasync function generateFromTemplate(\n  templatePath: string,\n  data: any,\n  outputPath: string\n) {\n  // Load template\n  const templateSource = fs.readFileSync(templatePath, 'utf-8');\n  const template = handlebars.compile(templateSource);\n\n  // Render with data\n  const html = template(data);\n\n  // Generate PDF\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.setContent(html, { waitUntil: 'networkidle0' });\n\n  await page.pdf({\n    path: outputPath,\n    format: 'Letter',\n    printBackground: true\n  });\n\n  await browser.close();\n}\n```\n\n---\n\n## Headers and Footers\n\n```typescript\nawait page.pdf({\n  path: outputPath,\n  format: 'Letter',\n  displayHeaderFooter: true,\n  headerTemplate: `\n    <div style=\"font-size: 10px; text-align: center; width: 100%;\">\n      <span>Company Name - Confidential</span>\n    </div>\n  `,\n  footerTemplate: `\n    <div style=\"font-size: 10px; text-align: center; width: 100%; margin: 0 1in;\">\n      <span>Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span></span>\n    </div>\n  `,\n  margin: {\n    top: '0.75in',\n    bottom: '0.75in',\n    left: '1in',\n    right: '1in'\n  }\n});\n```\n\n**Template variables**:\n- `{{pageNumber}}` - Current page number\n- `{{totalPages}}` - Total page count\n- `{{url}}` - Document URL\n- `{{title}}` - Document title\n- `{{date}}` - Print date\n\n---\n\n## Performance Optimization\n\n### Reuse Browser Instance\n\n```typescript\n// ‚ùå SLOW - Launch browser for each PDF\nfor (const data of dataArray) {\n  const browser = await puppeteer.launch();\n  // ...\n  await browser.close();\n}\n\n// ‚úÖ FAST - Reuse browser\nconst browser = await puppeteer.launch();\n\nfor (const data of dataArray) {\n  const page = await browser.newPage();\n  // ...\n  await page.close();\n}\n\nawait browser.close();\n```\n\n**Benchmark**:\n- Reuse browser: 100 PDFs in 15 seconds\n- New browser each time: 100 PDFs in 180 seconds\n\n### Wait Strategies\n\n```typescript\n// Wait for all resources\nawait page.setContent(html, {\n  waitUntil: 'networkidle0'  // Wait until no network activity\n});\n\n// Wait for specific element\nawait page.waitForSelector('.invoice-total');\n\n// Wait for timeout (last resort)\nawait page.waitForTimeout(1000);\n```\n\n---\n\n## Resources\n\n- [Puppeteer Documentation](https://pptr.dev/)\n- [Page.pdf() API](https://pptr.dev/api/puppeteer.page.pdf)\n- [Print CSS Spec](https://www.w3.org/TR/css-page-3/)\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "document-generation-pdf/scripts",
      "children": [
        {
          "name": "document_assembler.ts",
          "type": "file",
          "path": "document-generation-pdf/scripts/document_assembler.ts",
          "size": 14780,
          "content": "#!/usr/bin/env node\n/**\n * Document Assembler\n *\n * Merge multiple PDFs, add cover pages, watermarks, and page numbers.\n * Create document packets for legal/HR workflows.\n *\n * Usage:\n *   npx tsx document_assembler.ts merge <output.pdf> <input1.pdf> <input2.pdf> ...\n *   npx tsx document_assembler.ts cover <input.pdf> <output.pdf> --title \"Title\" --subtitle \"Subtitle\"\n *   npx tsx document_assembler.ts watermark <input.pdf> <output.pdf> --text \"CONFIDENTIAL\"\n *   npx tsx document_assembler.ts number <input.pdf> <output.pdf> --start 1\n *\n * Examples:\n *   npx tsx document_assembler.ts merge packet.pdf petition.pdf evidence.pdf affidavit.pdf\n *   npx tsx document_assembler.ts cover petition.pdf petition_with_cover.pdf --title \"Petition for Expungement\" --subtitle \"Case #12345\"\n *   npx tsx document_assembler.ts watermark draft.pdf draft_watermarked.pdf --text \"DRAFT - NOT FOR FILING\"\n *   npx tsx document_assembler.ts number brief.pdf brief_numbered.pdf --start 1 --format \"Page {n} of {total}\"\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { PDFDocument, rgb, StandardFonts, degrees } from 'pdf-lib';\n\ninterface MergeOptions {\n  addBookmarks?: boolean;\n  preserveMetadata?: boolean;\n}\n\ninterface CoverPageOptions {\n  title: string;\n  subtitle?: string;\n  date?: string;\n  caseNumber?: string;\n  attorney?: string;\n  backgroundColor?: { r: number; g: number; b: number };\n}\n\ninterface WatermarkOptions {\n  text: string;\n  opacity?: number;\n  rotation?: number;\n  fontSize?: number;\n  color?: { r: number; g: number; b: number };\n  diagonal?: boolean;\n}\n\ninterface PageNumberOptions {\n  start?: number;\n  format?: string;  // e.g., \"Page {n} of {total}\", \"{n}\", \"Page {n}\"\n  position?: 'bottom-center' | 'bottom-right' | 'top-center' | 'top-right';\n  fontSize?: number;\n}\n\nclass DocumentAssembler {\n  /**\n   * Merge multiple PDFs into one\n   */\n  async merge(\n    outputPath: string,\n    inputPaths: string[],\n    options: MergeOptions = {}\n  ): Promise<void> {\n    console.log(`\\nüìÑ Merging ${inputPaths.length} PDFs...\\n`);\n\n    const mergedPdf = await PDFDocument.create();\n\n    for (const inputPath of inputPaths) {\n      console.log(`  Adding: ${path.basename(inputPath)}`);\n\n      const pdfBytes = fs.readFileSync(inputPath);\n      const pdf = await PDFDocument.load(pdfBytes);\n\n      // Copy all pages\n      const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());\n      copiedPages.forEach(page => mergedPdf.addPage(page));\n\n      console.log(`    ‚úì ${pdf.getPageCount()} pages copied`);\n    }\n\n    // Preserve metadata from first document\n    if (options.preserveMetadata && inputPaths.length > 0) {\n      const firstPdfBytes = fs.readFileSync(inputPaths[0]);\n      const firstPdf = await PDFDocument.load(firstPdfBytes);\n\n      if (firstPdf.getTitle()) mergedPdf.setTitle(firstPdf.getTitle());\n      if (firstPdf.getAuthor()) mergedPdf.setAuthor(firstPdf.getAuthor());\n      if (firstPdf.getSubject()) mergedPdf.setSubject(firstPdf.getSubject());\n      if (firstPdf.getCreator()) mergedPdf.setCreator(firstPdf.getCreator());\n    }\n\n    // Save\n    const pdfBytes = await mergedPdf.save();\n    fs.writeFileSync(outputPath, pdfBytes);\n\n    console.log(`\\n‚úÖ Merged PDF saved: ${outputPath}`);\n    console.log(`   Total pages: ${mergedPdf.getPageCount()}\\n`);\n  }\n\n  /**\n   * Add cover page to PDF\n   */\n  async addCoverPage(\n    inputPath: string,\n    outputPath: string,\n    options: CoverPageOptions\n  ): Promise<void> {\n    console.log(`\\nüìÑ Adding cover page...\\n`);\n\n    const existingPdfBytes = fs.readFileSync(inputPath);\n    const pdfDoc = await PDFDocument.load(existingPdfBytes);\n\n    // Create new document with cover page\n    const newPdf = await PDFDocument.create();\n\n    // Add cover page\n    const coverPage = newPdf.addPage([612, 792]);  // 8.5\" x 11\" (US Letter)\n\n    // Background color\n    if (options.backgroundColor) {\n      const { r, g, b } = options.backgroundColor;\n      coverPage.drawRectangle({\n        x: 0,\n        y: 0,\n        width: coverPage.getWidth(),\n        height: coverPage.getHeight(),\n        color: rgb(r, g, b)\n      });\n    }\n\n    const helveticaBold = await newPdf.embedFont(StandardFonts.HelveticaBold);\n    const helvetica = await newPdf.embedFont(StandardFonts.Helvetica);\n\n    let yPosition = 650;\n\n    // Title\n    const titleSize = 32;\n    const titleWidth = helveticaBold.widthOfTextAtSize(options.title, titleSize);\n    coverPage.drawText(options.title, {\n      x: (coverPage.getWidth() - titleWidth) / 2,\n      y: yPosition,\n      size: titleSize,\n      font: helveticaBold,\n      color: rgb(0, 0, 0)\n    });\n\n    yPosition -= 60;\n\n    // Subtitle\n    if (options.subtitle) {\n      const subtitleSize = 18;\n      const subtitleWidth = helvetica.widthOfTextAtSize(options.subtitle, subtitleSize);\n      coverPage.drawText(options.subtitle, {\n        x: (coverPage.getWidth() - subtitleWidth) / 2,\n        y: yPosition,\n        size: subtitleSize,\n        font: helvetica,\n        color: rgb(0.3, 0.3, 0.3)\n      });\n      yPosition -= 40;\n    }\n\n    // Case number\n    if (options.caseNumber) {\n      const caseSize = 14;\n      const caseText = `Case No. ${options.caseNumber}`;\n      const caseWidth = helvetica.widthOfTextAtSize(caseText, caseSize);\n      coverPage.drawText(caseText, {\n        x: (coverPage.getWidth() - caseWidth) / 2,\n        y: yPosition,\n        size: caseSize,\n        font: helvetica,\n        color: rgb(0.4, 0.4, 0.4)\n      });\n      yPosition -= 100;\n    }\n\n    // Attorney/Author\n    if (options.attorney) {\n      const attorneySize = 12;\n      const attorneyText = `Prepared by: ${options.attorney}`;\n      const attorneyWidth = helvetica.widthOfTextAtSize(attorneyText, attorneySize);\n      coverPage.drawText(attorneyText, {\n        x: (coverPage.getWidth() - attorneyWidth) / 2,\n        y: yPosition,\n        size: attorneySize,\n        font: helvetica,\n        color: rgb(0.5, 0.5, 0.5)\n      });\n    }\n\n    // Date (bottom)\n    const date = options.date || new Date().toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    });\n    const dateSize = 12;\n    const dateWidth = helvetica.widthOfTextAtSize(date, dateSize);\n    coverPage.drawText(date, {\n      x: (coverPage.getWidth() - dateWidth) / 2,\n      y: 50,\n      size: dateSize,\n      font: helvetica,\n      color: rgb(0.5, 0.5, 0.5)\n    });\n\n    // Copy original pages\n    const copiedPages = await newPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());\n    copiedPages.forEach(page => newPdf.addPage(page));\n\n    // Save\n    const pdfBytes = await newPdf.save();\n    fs.writeFileSync(outputPath, pdfBytes);\n\n    console.log(`‚úÖ Cover page added: ${outputPath}`);\n    console.log(`   Total pages: ${newPdf.getPageCount()} (1 cover + ${pdfDoc.getPageCount()} original)\\n`);\n  }\n\n  /**\n   * Add watermark to all pages\n   */\n  async addWatermark(\n    inputPath: string,\n    outputPath: string,\n    options: WatermarkOptions\n  ): Promise<void> {\n    console.log(`\\nüíß Adding watermark: \"${options.text}\"\\n`);\n\n    const pdfBytes = fs.readFileSync(inputPath);\n    const pdfDoc = await PDFDocument.load(pdfBytes);\n\n    const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);\n    const fontSize = options.fontSize || 60;\n    const opacity = options.opacity !== undefined ? options.opacity : 0.3;\n    const color = options.color || { r: 0.7, g: 0.7, b: 0.7 };\n    const rotation = options.rotation !== undefined ? options.rotation : (options.diagonal ? -45 : 0);\n\n    const pages = pdfDoc.getPages();\n    const textWidth = font.widthOfTextAtSize(options.text, fontSize);\n\n    pages.forEach((page, index) => {\n      const { width, height } = page.getSize();\n\n      // Center position\n      const x = (width - textWidth) / 2;\n      const y = height / 2;\n\n      page.drawText(options.text, {\n        x,\n        y,\n        size: fontSize,\n        font,\n        color: rgb(color.r, color.g, color.b),\n        opacity,\n        rotate: degrees(rotation)\n      });\n\n      if ((index + 1) % 10 === 0) {\n        console.log(`  ‚úì Watermarked ${index + 1} pages...`);\n      }\n    });\n\n    console.log(`  ‚úì Watermarked all ${pages.length} pages`);\n\n    // Save\n    const outputBytes = await pdfDoc.save();\n    fs.writeFileSync(outputPath, outputBytes);\n\n    console.log(`\\n‚úÖ Watermarked PDF saved: ${outputPath}\\n`);\n  }\n\n  /**\n   * Add page numbers\n   */\n  async addPageNumbers(\n    inputPath: string,\n    outputPath: string,\n    options: PageNumberOptions = {}\n  ): Promise<void> {\n    console.log(`\\nüî¢ Adding page numbers...\\n`);\n\n    const pdfBytes = fs.readFileSync(inputPath);\n    const pdfDoc = await PDFDocument.load(pdfBytes);\n\n    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n    const fontSize = options.fontSize || 10;\n    const position = options.position || 'bottom-center';\n    const start = options.start || 1;\n    const format = options.format || 'Page {n} of {total}';\n\n    const pages = pdfDoc.getPages();\n    const total = pages.length;\n\n    pages.forEach((page, index) => {\n      const { width, height } = page.getSize();\n      const pageNumber = start + index;\n\n      // Format text\n      const text = format\n        .replace('{n}', pageNumber.toString())\n        .replace('{total}', total.toString());\n\n      const textWidth = font.widthOfTextAtSize(text, fontSize);\n\n      // Calculate position\n      let x: number, y: number;\n\n      switch (position) {\n        case 'bottom-center':\n          x = (width - textWidth) / 2;\n          y = 30;\n          break;\n        case 'bottom-right':\n          x = width - textWidth - 50;\n          y = 30;\n          break;\n        case 'top-center':\n          x = (width - textWidth) / 2;\n          y = height - 50;\n          break;\n        case 'top-right':\n          x = width - textWidth - 50;\n          y = height - 50;\n          break;\n        default:\n          x = (width - textWidth) / 2;\n          y = 30;\n      }\n\n      page.drawText(text, {\n        x,\n        y,\n        size: fontSize,\n        font,\n        color: rgb(0, 0, 0)\n      });\n\n      if ((index + 1) % 10 === 0) {\n        console.log(`  ‚úì Numbered ${index + 1} pages...`);\n      }\n    });\n\n    console.log(`  ‚úì Numbered all ${pages.length} pages`);\n\n    // Save\n    const outputBytes = await pdfDoc.save();\n    fs.writeFileSync(outputPath, outputBytes);\n\n    console.log(`\\n‚úÖ Numbered PDF saved: ${outputPath}\\n`);\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  const command = args[0];\n\n  const assembler = new DocumentAssembler();\n\n  switch (command) {\n    case 'merge': {\n      if (args.length < 3) {\n        console.error('Usage: npx tsx document_assembler.ts merge <output.pdf> <input1.pdf> <input2.pdf> ...');\n        process.exit(1);\n      }\n\n      const outputPath = args[1];\n      const inputPaths = args.slice(2);\n\n      assembler.merge(outputPath, inputPaths, { preserveMetadata: true });\n      break;\n    }\n\n    case 'cover': {\n      if (args.length < 3) {\n        console.error('Usage: npx tsx document_assembler.ts cover <input.pdf> <output.pdf> --title \"Title\" [--subtitle \"Subtitle\"] [--case \"12345\"]');\n        process.exit(1);\n      }\n\n      const inputPath = args[1];\n      const outputPath = args[2];\n\n      // Parse options\n      const options: CoverPageOptions = { title: '' };\n      for (let i = 3; i < args.length; i += 2) {\n        const flag = args[i];\n        const value = args[i + 1];\n\n        switch (flag) {\n          case '--title':\n            options.title = value;\n            break;\n          case '--subtitle':\n            options.subtitle = value;\n            break;\n          case '--case':\n            options.caseNumber = value;\n            break;\n          case '--attorney':\n            options.attorney = value;\n            break;\n          case '--date':\n            options.date = value;\n            break;\n        }\n      }\n\n      if (!options.title) {\n        console.error('Error: --title is required');\n        process.exit(1);\n      }\n\n      assembler.addCoverPage(inputPath, outputPath, options);\n      break;\n    }\n\n    case 'watermark': {\n      if (args.length < 3) {\n        console.error('Usage: npx tsx document_assembler.ts watermark <input.pdf> <output.pdf> --text \"TEXT\" [--opacity 0.3] [--diagonal]');\n        process.exit(1);\n      }\n\n      const inputPath = args[1];\n      const outputPath = args[2];\n\n      // Parse options\n      const options: WatermarkOptions = { text: '' };\n      for (let i = 3; i < args.length; i++) {\n        const flag = args[i];\n\n        switch (flag) {\n          case '--text':\n            options.text = args[++i];\n            break;\n          case '--opacity':\n            options.opacity = parseFloat(args[++i]);\n            break;\n          case '--rotation':\n            options.rotation = parseInt(args[++i]);\n            break;\n          case '--diagonal':\n            options.diagonal = true;\n            break;\n          case '--size':\n            options.fontSize = parseInt(args[++i]);\n            break;\n        }\n      }\n\n      if (!options.text) {\n        console.error('Error: --text is required');\n        process.exit(1);\n      }\n\n      assembler.addWatermark(inputPath, outputPath, options);\n      break;\n    }\n\n    case 'number': {\n      if (args.length < 3) {\n        console.error('Usage: npx tsx document_assembler.ts number <input.pdf> <output.pdf> [--start 1] [--format \"Page {n} of {total}\"] [--position bottom-center]');\n        process.exit(1);\n      }\n\n      const inputPath = args[1];\n      const outputPath = args[2];\n\n      // Parse options\n      const options: PageNumberOptions = {};\n      for (let i = 3; i < args.length; i += 2) {\n        const flag = args[i];\n        const value = args[i + 1];\n\n        switch (flag) {\n          case '--start':\n            options.start = parseInt(value);\n            break;\n          case '--format':\n            options.format = value;\n            break;\n          case '--position':\n            options.position = value as any;\n            break;\n          case '--size':\n            options.fontSize = parseInt(value);\n            break;\n        }\n      }\n\n      assembler.addPageNumbers(inputPath, outputPath, options);\n      break;\n    }\n\n    default:\n      console.error('Unknown command. Available commands:');\n      console.error('  merge <output.pdf> <input1.pdf> <input2.pdf> ...');\n      console.error('  cover <input.pdf> <output.pdf> --title \"Title\" [options]');\n      console.error('  watermark <input.pdf> <output.pdf> --text \"TEXT\" [options]');\n      console.error('  number <input.pdf> <output.pdf> [options]');\n      process.exit(1);\n  }\n}\n\nexport { DocumentAssembler, MergeOptions, CoverPageOptions, WatermarkOptions, PageNumberOptions };\n"
        },
        {
          "name": "form_filler.ts",
          "type": "file",
          "path": "document-generation-pdf/scripts/form_filler.ts",
          "size": 13850,
          "content": "#!/usr/bin/env node\n/**\n * PDF Form Filler\n *\n * Fill PDF forms from JSON data with validation and batch processing.\n * Uses pdf-lib for native PDF form field manipulation.\n *\n * Usage:\n *   npx tsx form_filler.ts fill <template.pdf> <data.json> <output.pdf>\n *   npx tsx form_filler.ts batch <template.pdf> <data-dir/> <output-dir/>\n *   npx tsx form_filler.ts inspect <form.pdf>\n *\n * Examples:\n *   npx tsx form_filler.ts fill petition_template.pdf case_123.json petition_filled.pdf\n *   npx tsx form_filler.ts batch petition_template.pdf ./case_data/ ./filled_petitions/\n *   npx tsx form_filler.ts inspect petition_template.pdf\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { PDFDocument, PDFTextField, PDFCheckBox, PDFDropdown, PDFRadioGroup } from 'pdf-lib';\n\ninterface FormFieldData {\n  name: string;\n  type: 'text' | 'checkbox' | 'dropdown' | 'radio';\n  value: string | boolean | string[];\n  required?: boolean;\n}\n\ninterface FormData {\n  fields: Record<string, any>;\n  options?: {\n    flatten?: boolean;\n    encrypt?: boolean;\n    password?: string;\n  };\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\ninterface FilledFormResult {\n  success: boolean;\n  outputPath?: string;\n  error?: string;\n  validation?: ValidationResult;\n  fieldsFilled: number;\n  fieldsTotal: number;\n}\n\nclass FormFiller {\n  /**\n   * Fill a single PDF form\n   */\n  async fill(\n    templatePath: string,\n    data: FormData,\n    outputPath: string\n  ): Promise<FilledFormResult> {\n    try {\n      console.log(`\\nüìÑ Filling form: ${path.basename(templatePath)}`);\n\n      // Load PDF\n      const existingPdfBytes = fs.readFileSync(templatePath);\n      const pdfDoc = await PDFDocument.load(existingPdfBytes);\n      const form = pdfDoc.getForm();\n\n      // Get all fields\n      const fields = form.getFields();\n      console.log(`Found ${fields.length} form fields\\n`);\n\n      // Validate data\n      const validation = this.validate(form, data);\n      if (!validation.valid) {\n        console.error('‚ùå Validation failed:');\n        validation.errors.forEach(err => console.error(`  - ${err}`));\n        return {\n          success: false,\n          error: 'Validation failed',\n          validation,\n          fieldsFilled: 0,\n          fieldsTotal: fields.length\n        };\n      }\n\n      if (validation.warnings.length > 0) {\n        console.warn('‚ö†Ô∏è  Warnings:');\n        validation.warnings.forEach(warn => console.warn(`  - ${warn}`));\n      }\n\n      // Fill fields\n      let fieldsFilled = 0;\n      for (const [fieldName, fieldValue] of Object.entries(data.fields)) {\n        try {\n          const field = form.getField(fieldName);\n\n          if (field instanceof PDFTextField) {\n            field.setText(String(fieldValue));\n            console.log(`‚úì Text field: ${fieldName} = \"${fieldValue}\"`);\n            fieldsFilled++;\n          } else if (field instanceof PDFCheckBox) {\n            if (fieldValue === true || fieldValue === 'true' || fieldValue === 'yes') {\n              field.check();\n              console.log(`‚úì Checkbox: ${fieldName} = checked`);\n            } else {\n              field.uncheck();\n              console.log(`‚úì Checkbox: ${fieldName} = unchecked`);\n            }\n            fieldsFilled++;\n          } else if (field instanceof PDFDropdown) {\n            field.select(String(fieldValue));\n            console.log(`‚úì Dropdown: ${fieldName} = \"${fieldValue}\"`);\n            fieldsFilled++;\n          } else if (field instanceof PDFRadioGroup) {\n            field.select(String(fieldValue));\n            console.log(`‚úì Radio: ${fieldName} = \"${fieldValue}\"`);\n            fieldsFilled++;\n          }\n        } catch (err) {\n          console.warn(`‚ö†Ô∏è  Could not fill field \"${fieldName}\": ${err.message}`);\n        }\n      }\n\n      // Flatten form (make non-editable)\n      if (data.options?.flatten !== false) {\n        form.flatten();\n        console.log('\\nüîí Form flattened (fields are now non-editable)');\n      }\n\n      // Save PDF\n      const pdfBytes = await pdfDoc.save({\n        useObjectStreams: false,\n        ...(data.options?.encrypt && {\n          userPassword: data.options.password || this.generatePassword(),\n          ownerPassword: process.env.PDF_OWNER_PASSWORD || 'owner',\n          permissions: {\n            printing: 'highResolution',\n            modifying: false,\n            copying: false,\n            annotating: false,\n            fillingForms: false,\n            contentAccessibility: true,\n            documentAssembly: false\n          }\n        })\n      });\n\n      fs.writeFileSync(outputPath, pdfBytes);\n\n      console.log(`\\n‚úÖ Filled form saved to: ${outputPath}`);\n      console.log(`   Fields filled: ${fieldsFilled}/${fields.length}`);\n\n      return {\n        success: true,\n        outputPath,\n        validation,\n        fieldsFilled,\n        fieldsTotal: fields.length\n      };\n    } catch (error) {\n      console.error(`\\n‚ùå Error filling form: ${error.message}`);\n      return {\n        success: false,\n        error: error.message,\n        fieldsFilled: 0,\n        fieldsTotal: 0\n      };\n    }\n  }\n\n  /**\n   * Batch fill multiple forms\n   */\n  async batch(\n    templatePath: string,\n    dataDir: string,\n    outputDir: string\n  ): Promise<void> {\n    console.log(`\\nüì¶ Batch filling forms...`);\n    console.log(`Template: ${templatePath}`);\n    console.log(`Data dir: ${dataDir}`);\n    console.log(`Output dir: ${outputDir}\\n`);\n\n    // Ensure output directory exists\n    if (!fs.existsSync(outputDir)) {\n      fs.mkdirSync(outputDir, { recursive: true });\n    }\n\n    // Find all JSON files\n    const dataFiles = fs.readdirSync(dataDir).filter(f => f.endsWith('.json'));\n    console.log(`Found ${dataFiles.length} data files\\n`);\n\n    const results: FilledFormResult[] = [];\n    const startTime = Date.now();\n\n    for (const dataFile of dataFiles) {\n      const dataPath = path.join(dataDir, dataFile);\n      const outputPath = path.join(\n        outputDir,\n        dataFile.replace('.json', '.pdf')\n      );\n\n      const data: FormData = JSON.parse(fs.readFileSync(dataPath, 'utf-8'));\n      const result = await this.fill(templatePath, data, outputPath);\n      results.push(result);\n\n      console.log('‚îÄ'.repeat(60));\n    }\n\n    const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);\n    const successful = results.filter(r => r.success).length;\n    const failed = results.filter(r => !r.success).length;\n\n    console.log(`\\nüìä Batch Results:`);\n    console.log(`   Total: ${results.length}`);\n    console.log(`   ‚úÖ Success: ${successful}`);\n    console.log(`   ‚ùå Failed: ${failed}`);\n    console.log(`   ‚è±Ô∏è  Time: ${elapsed}s`);\n    console.log(`   üìà Rate: ${(results.length / parseFloat(elapsed)).toFixed(1)} forms/sec\\n`);\n\n    if (failed > 0) {\n      console.log('Failed forms:');\n      results\n        .filter(r => !r.success)\n        .forEach(r => console.log(`  - ${r.error}`));\n    }\n  }\n\n  /**\n   * Inspect PDF form fields\n   */\n  async inspect(pdfPath: string): Promise<void> {\n    console.log(`\\nüîç Inspecting form: ${path.basename(pdfPath)}\\n`);\n\n    const pdfBytes = fs.readFileSync(pdfPath);\n    const pdfDoc = await PDFDocument.load(pdfBytes);\n    const form = pdfDoc.getForm();\n\n    const fields = form.getFields();\n    console.log(`Found ${fields.length} form fields:\\n`);\n\n    fields.forEach((field, index) => {\n      const name = field.getName();\n      const type = this.getFieldType(field);\n\n      console.log(`${index + 1}. ${name}`);\n      console.log(`   Type: ${type}`);\n\n      // Field-specific details\n      if (field instanceof PDFTextField) {\n        const value = field.getText();\n        const maxLength = field.getMaxLength();\n        console.log(`   Value: \"${value || '(empty)'}\"`);\n        if (maxLength) {\n          console.log(`   Max length: ${maxLength}`);\n        }\n      } else if (field instanceof PDFCheckBox) {\n        const checked = field.isChecked();\n        console.log(`   Checked: ${checked}`);\n      } else if (field instanceof PDFDropdown) {\n        const options = field.getOptions();\n        const selected = field.getSelected();\n        console.log(`   Options: [${options.join(', ')}]`);\n        console.log(`   Selected: ${selected.join(', ') || '(none)'}`);\n      } else if (field instanceof PDFRadioGroup) {\n        const options = field.getOptions();\n        const selected = field.getSelected();\n        console.log(`   Options: [${options.join(', ')}]`);\n        console.log(`   Selected: ${selected || '(none)'}`);\n      }\n\n      console.log('');\n    });\n\n    // Generate sample JSON\n    console.log('üìù Sample JSON structure:\\n');\n    const sampleData: FormData = {\n      fields: {},\n      options: {\n        flatten: true,\n        encrypt: false\n      }\n    };\n\n    fields.forEach(field => {\n      const name = field.getName();\n      if (field instanceof PDFTextField) {\n        sampleData.fields[name] = 'Sample text';\n      } else if (field instanceof PDFCheckBox) {\n        sampleData.fields[name] = false;\n      } else if (field instanceof PDFDropdown) {\n        const options = field.getOptions();\n        sampleData.fields[name] = options[0] || 'option';\n      } else if (field instanceof PDFRadioGroup) {\n        const options = field.getOptions();\n        sampleData.fields[name] = options[0] || 'option';\n      }\n    });\n\n    console.log(JSON.stringify(sampleData, null, 2));\n    console.log('\\n');\n  }\n\n  /**\n   * Validate form data\n   */\n  private validate(form: any, data: FormData): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    const formFieldNames = form.getFields().map((f: any) => f.getName());\n\n    // Check for missing required fields\n    for (const fieldName of formFieldNames) {\n      if (!(fieldName in data.fields)) {\n        warnings.push(`Field \"${fieldName}\" not provided in data`);\n      }\n    }\n\n    // Check for unknown fields\n    for (const fieldName of Object.keys(data.fields)) {\n      if (!formFieldNames.includes(fieldName)) {\n        warnings.push(`Field \"${fieldName}\" not found in PDF form`);\n      }\n    }\n\n    // Type validation\n    for (const [fieldName, fieldValue] of Object.entries(data.fields)) {\n      try {\n        const field = form.getField(fieldName);\n\n        if (field instanceof PDFTextField) {\n          if (typeof fieldValue !== 'string' && typeof fieldValue !== 'number') {\n            errors.push(`Field \"${fieldName}\" expects string/number, got ${typeof fieldValue}`);\n          }\n        } else if (field instanceof PDFCheckBox) {\n          if (typeof fieldValue !== 'boolean' && fieldValue !== 'true' && fieldValue !== 'false') {\n            warnings.push(`Field \"${fieldName}\" is checkbox, value \"${fieldValue}\" will be converted to boolean`);\n          }\n        } else if (field instanceof PDFDropdown) {\n          const options = field.getOptions();\n          if (!options.includes(String(fieldValue))) {\n            errors.push(`Field \"${fieldName}\" value \"${fieldValue}\" not in options: [${options.join(', ')}]`);\n          }\n        } else if (field instanceof PDFRadioGroup) {\n          const options = field.getOptions();\n          if (!options.includes(String(fieldValue))) {\n            errors.push(`Field \"${fieldName}\" value \"${fieldValue}\" not in options: [${options.join(', ')}]`);\n          }\n        }\n      } catch (err) {\n        // Field not found - already warned above\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Get field type as string\n   */\n  private getFieldType(field: any): string {\n    if (field instanceof PDFTextField) return 'Text';\n    if (field instanceof PDFCheckBox) return 'Checkbox';\n    if (field instanceof PDFDropdown) return 'Dropdown';\n    if (field instanceof PDFRadioGroup) return 'Radio';\n    return 'Unknown';\n  }\n\n  /**\n   * Generate secure random password\n   */\n  private generatePassword(): string {\n    const length = 16;\n    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';\n    let password = '';\n    for (let i = 0; i < length; i++) {\n      password += charset.charAt(Math.floor(Math.random() * charset.length));\n    }\n    return password;\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  const command = args[0];\n\n  const filler = new FormFiller();\n\n  switch (command) {\n    case 'fill': {\n      if (args.length < 4) {\n        console.error('Usage: npx tsx form_filler.ts fill <template.pdf> <data.json> <output.pdf>');\n        process.exit(1);\n      }\n\n      const templatePath = args[1];\n      const dataPath = args[2];\n      const outputPath = args[3];\n\n      const data: FormData = JSON.parse(fs.readFileSync(dataPath, 'utf-8'));\n      filler.fill(templatePath, data, outputPath);\n      break;\n    }\n\n    case 'batch': {\n      if (args.length < 4) {\n        console.error('Usage: npx tsx form_filler.ts batch <template.pdf> <data-dir/> <output-dir/>');\n        process.exit(1);\n      }\n\n      const templatePath = args[1];\n      const dataDir = args[2];\n      const outputDir = args[3];\n\n      filler.batch(templatePath, dataDir, outputDir);\n      break;\n    }\n\n    case 'inspect': {\n      if (args.length < 2) {\n        console.error('Usage: npx tsx form_filler.ts inspect <form.pdf>');\n        process.exit(1);\n      }\n\n      const pdfPath = args[1];\n      filler.inspect(pdfPath);\n      break;\n    }\n\n    default:\n      console.error('Unknown command. Available commands:');\n      console.error('  fill <template.pdf> <data.json> <output.pdf>');\n      console.error('  batch <template.pdf> <data-dir/> <output-dir/>');\n      console.error('  inspect <form.pdf>');\n      process.exit(1);\n  }\n}\n\nexport { FormFiller, FormData, FormFieldData, ValidationResult, FilledFormResult };\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "document-generation-pdf/SKILL.md",
      "size": 13043,
      "content": "---\nname: document-generation-pdf\ndescription: Generate, fill, and assemble PDF documents at scale. Handles legal forms, contracts, invoices, certificates. Supports form filling (pdf-lib), template rendering (Puppeteer, LaTeX), digital signatures (DocuSign), and document assembly. Use for legal tech, HR automation, invoice generation. Activate on \"PDF generation\", \"form filling\", \"document automation\", \"digital signatures\". NOT for simple PDF viewing, basic file conversion, or OCR text extraction.\nallowed-tools: Read,Write,Edit,Bash(npm:*,latex*)\n---\n\n# Document Generation & PDF Automation\n\nExpert in generating, filling, and assembling PDF documents programmatically for legal, HR, and business workflows.\n\n## When to Use\n\n‚úÖ **Use for**:\n- Legal form automation (expungement, immigration, contracts)\n- Invoice/receipt generation at scale\n- Certificate creation (completion, participation, awards)\n- Contract assembly from templates\n- Government form filling (IRS, court filings)\n- Multi-document packet creation\n\n‚ùå **NOT for**:\n- Simple PDF viewing (use browser or pdf.js)\n- Basic file conversion (use online tools)\n- OCR text extraction (use Tesseract.js or AWS Textract)\n- PDF editing by hand (use Adobe Acrobat)\n\n---\n\n## Technology Selection\n\n### pdf-lib vs Puppeteer vs LaTeX\n\n| Feature | pdf-lib | Puppeteer | LaTeX |\n|---------|---------|-----------|-------|\n| Form filling | ‚úÖ Native | ‚ùå Complex | ‚ùå No |\n| Template rendering | ‚ùå No | ‚úÖ HTML/CSS | ‚úÖ Templates |\n| Performance (1000 PDFs) | 5s | 60s | 30s |\n| File size | Small | Medium | Small |\n| Signature fields | ‚úÖ Yes | ‚ùå No | ‚ùå No |\n| Best for | Government forms | Invoices, reports | Academic papers |\n\n**Timeline**:\n- 2000s: LaTeX for academic documents\n- 2010: PDFKit (Node.js) for generation\n- 2017: Puppeteer for HTML ‚Üí PDF\n- 2019: pdf-lib for pure JS form filling\n- 2024: pdf-lib is gold standard for forms\n\n**Decision tree**:\n```\nNeed to fill existing form? ‚Üí pdf-lib\nNeed complex layouts? ‚Üí Puppeteer (HTML/CSS)\nNeed academic formatting? ‚Üí LaTeX\nNeed to merge PDFs? ‚Üí pdf-lib\nNeed digital signatures? ‚Üí pdf-lib + DocuSign API\n```\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: Using Puppeteer for Simple Form Filling\n\n**Novice thinking**: \"I'll use Puppeteer for everything, it's versatile\"\n\n**Problem**: 12x slower, 10x more memory, can't preserve form fields.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Puppeteer for simple form filling (SLOW!)\nimport puppeteer from 'puppeteer';\n\nasync function fillForm(data: FormData): Promise<Buffer> {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n  // Load PDF in browser\n  await page.goto(`file://${pdfPath}`);\n\n  // Somehow fill form fields? (hacky)\n  await page.evaluate((data) => {\n    // Can't easily access PDF form fields from DOM\n    // Would need to convert PDF ‚Üí HTML first\n  }, data);\n\n  const pdf = await page.pdf();\n  await browser.close();\n\n  return pdf;\n}\n```\n\n**Why wrong**:\n- Browser overhead (200MB+ RAM per instance)\n- Can't access native PDF form fields\n- Loses interactive form capabilities\n- 12x slower than pdf-lib\n\n**Correct approach**:\n```typescript\n// ‚úÖ pdf-lib for form filling (FAST!)\nimport { PDFDocument } from 'pdf-lib';\n\nasync function fillForm(templatePath: string, data: FormData): Promise<Uint8Array> {\n  // Load existing PDF form\n  const existingPdfBytes = await fs.readFile(templatePath);\n  const pdfDoc = await PDFDocument.load(existingPdfBytes);\n\n  // Get form\n  const form = pdfDoc.getForm();\n\n  // Fill text fields\n  form.getTextField('applicant_name').setText(data.name);\n  form.getTextField('case_number').setText(data.caseNumber);\n  form.getTextField('date_of_birth').setText(data.dob);\n\n  // Fill checkboxes\n  if (data.hasPriorConvictions) {\n    form.getCheckBox('prior_convictions').check();\n  }\n\n  // Fill dropdowns\n  form.getDropdown('state').select(data.state);\n\n  // Flatten form (make non-editable)\n  form.flatten();\n\n  // Save\n  return await pdfDoc.save();\n}\n```\n\n**Performance comparison** (1000 PDFs):\n- Puppeteer: 60 seconds, 4GB RAM\n- pdf-lib: 5 seconds, 200MB RAM\n\n**Timeline context**:\n- 2017: Puppeteer released, everyone used it for PDFs\n- 2019: pdf-lib released, proper form handling\n- 2024: pdf-lib is standard for government forms\n\n---\n\n### Anti-Pattern 2: Not Flattening Forms\n\n**Problem**: Users can edit filled forms, causing data inconsistencies.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Don't flatten - form stays editable\nconst pdfDoc = await PDFDocument.load(existingPdfBytes);\nconst form = pdfDoc.getForm();\n\nform.getTextField('name').setText('John Doe');\n\nconst pdfBytes = await pdfDoc.save();\n// User can open PDF and change \"John Doe\" to anything!\n```\n\n**Why wrong**:\n- User can modify official documents\n- Data doesn't match database\n- Violates document integrity\n\n**Correct approach**:\n```typescript\n// ‚úÖ Flatten form after filling\nconst pdfDoc = await PDFDocument.load(existingPdfBytes);\nconst form = pdfDoc.getForm();\n\nform.getTextField('name').setText('John Doe');\n\n// Flatten (convert fields to static text)\nform.flatten();\n\nconst pdfBytes = await pdfDoc.save();\n// User can't edit filled values ‚úÖ\n```\n\n**When NOT to flatten**:\n- Draft documents (user needs to review/edit)\n- Multi-step workflows (partial completion)\n- Templates for users to fill manually\n\n---\n\n### Anti-Pattern 3: Generating PDFs from HTML Without Page Breaks\n\n**Novice thinking**: \"HTML ‚Üí PDF is easy with Puppeteer\"\n\n**Problem**: Content splits mid-sentence across pages.\n\n**Wrong approach**:\n```typescript\n// ‚ùå No page break control\nconst html = `\n  <div class=\"contract\">\n    <h1>Mutual Agreement</h1>\n    <p>Long paragraph that might split across pages...</p>\n    <section>\n      <h2>Terms and Conditions</h2>\n      <ol>\n        <li>Term 1 that could get cut off...</li>\n        <li>Term 2...</li>\n      </ol>\n    </section>\n  </div>\n`;\n\nconst pdf = await page.pdf({ format: 'A4' });\n// Result: Ugly page breaks in middle of sections\n```\n\n**Correct approach**:\n```typescript\n// ‚úÖ Explicit page break control with CSS\nconst html = `\n  <style>\n    @media print {\n      .page-break { page-break-after: always; }\n      .avoid-break { page-break-inside: avoid; }\n\n      h1, h2, h3 {\n        page-break-after: avoid;\n        page-break-inside: avoid;\n      }\n\n      section {\n        page-break-inside: avoid;\n      }\n    }\n  </style>\n\n  <div class=\"contract\">\n    <section class=\"avoid-break\">\n      <h1>Mutual Agreement</h1>\n      <p>This entire section stays together...</p>\n    </section>\n\n    <div class=\"page-break\"></div>\n\n    <section class=\"avoid-break\">\n      <h2>Terms and Conditions</h2>\n      <ol>\n        <li>Term 1</li>\n        <li>Term 2</li>\n      </ol>\n    </section>\n  </div>\n`;\n\nconst pdf = await page.pdf({\n  format: 'A4',\n  printBackground: true,\n  margin: {\n    top: '1in',\n    right: '1in',\n    bottom: '1in',\n    left: '1in'\n  }\n});\n```\n\n**CSS print properties**:\n- `page-break-before: always` - Force new page before element\n- `page-break-after: always` - Force new page after element\n- `page-break-inside: avoid` - Keep element together\n\n---\n\n### Anti-Pattern 4: Not Handling Signature Fields\n\n**Problem**: Signature fields aren't clickable in generated PDFs.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Add signature as image (not a real signature field)\nconst pdfDoc = await PDFDocument.load(existingPdfBytes);\n\nconst signatureImage = await pdfDoc.embedPng(signaturePngBytes);\nconst page = pdfDoc.getPage(0);\n\npage.drawImage(signatureImage, {\n  x: 100,\n  y: 100,\n  width: 200,\n  height: 50\n});\n\nawait pdfDoc.save();\n// Not a real signature field - can't be signed digitally\n```\n\n**Why wrong**:\n- Not legally recognized (just an image)\n- Can't use DocuSign/Adobe Sign\n- No signature metadata (who, when)\n\n**Correct approach 1**: Create signature field (for DocuSign)\n```typescript\n// ‚úÖ Create signature field for electronic signing\nconst pdfDoc = await PDFDocument.load(existingPdfBytes);\nconst form = pdfDoc.getForm();\n\n// Create signature field\nconst signatureField = form.createTextField('applicant_signature');\nsignatureField.addToPage(pdfDoc.getPage(0), {\n  x: 100,\n  y: 100,\n  width: 200,\n  height: 50\n});\n\n// Mark as signature field (metadata)\nsignatureField.updateWidgets({\n  borderWidth: 1,\n  borderColor: { type: 'RGB', red: 0, green: 0, blue: 0 }\n});\n\nawait pdfDoc.save();\n// DocuSign can now detect and fill this field ‚úÖ\n```\n\n**Correct approach 2**: DocuSign API integration\n```typescript\n// ‚úÖ Send to DocuSign for e-signature\nimport { ApiClient, EnvelopesApi } from 'docusign-esign';\n\nasync function sendForSignature(pdfBytes: Uint8Array, signerEmail: string) {\n  const apiClient = new ApiClient();\n  apiClient.setBasePath('https://demo.docusign.net/restapi');\n\n  const envelopesApi = new EnvelopesApi(apiClient);\n\n  const envelope = {\n    emailSubject: 'Please sign: Expungement Petition',\n    documents: [{\n      documentBase64: Buffer.from(pdfBytes).toString('base64'),\n      name: 'Petition.pdf',\n      fileExtension: 'pdf',\n      documentId: '1'\n    }],\n    recipients: {\n      signers: [{\n        email: signerEmail,\n        name: 'John Doe',\n        recipientId: '1',\n        tabs: {\n          signHereTabs: [{\n            documentId: '1',\n            pageNumber: '1',\n            xPosition: '100',\n            yPosition: '100'\n          }]\n        }\n      }]\n    },\n    status: 'sent'\n  };\n\n  return await envelopesApi.createEnvelope(accountId, { envelopeDefinition: envelope });\n}\n```\n\n---\n\n### Anti-Pattern 5: Storing Filled PDFs Without Encryption\n\n**Problem**: Sensitive legal documents stored in plain text.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Save PDF to disk unencrypted\nconst pdfBytes = await pdfDoc.save();\nawait fs.writeFile(`./documents/${caseId}.pdf`, pdfBytes);\n// Sensitive data accessible to anyone with file system access\n```\n\n**Why wrong**:\n- Legal/medical data exposed\n- HIPAA/GDPR violations\n- Data breach liability\n\n**Correct approach 1**: Encrypt at rest\n```typescript\n// ‚úÖ Encrypt PDF with user password\nconst pdfBytes = await pdfDoc.save({\n  userPassword: generateSecurePassword(),\n  ownerPassword: process.env.PDF_OWNER_PASSWORD,\n  permissions: {\n    printing: 'highResolution',\n    modifying: false,\n    copying: false,\n    annotating: false,\n    fillingForms: false,\n    contentAccessibility: true,\n    documentAssembly: false\n  }\n});\n\nawait fs.writeFile(`./documents/${caseId}.pdf`, pdfBytes);\n```\n\n**Correct approach 2**: Store in encrypted storage (S3 with SSE)\n```typescript\n// ‚úÖ Upload to S3 with server-side encryption\nimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';\n\nconst s3Client = new S3Client({ region: 'us-east-1' });\n\nawait s3Client.send(new PutObjectCommand({\n  Bucket: 'expungement-documents',\n  Key: `cases/${caseId}/petition.pdf`,\n  Body: pdfBytes,\n  ServerSideEncryption: 'AES256',\n  Metadata: {\n    caseId: caseId,\n    documentType: 'petition',\n    generatedAt: new Date().toISOString()\n  },\n  ACL: 'private'  // Not publicly accessible\n}));\n\n// Store S3 URL in database (encrypted)\nawait db.documents.insert({\n  case_id: caseId,\n  s3_url: encrypt(`s3://expungement-documents/cases/${caseId}/petition.pdf`),\n  created_at: new Date()\n});\n```\n\n**Compliance requirements**:\n- HIPAA: Encryption at rest + in transit, access logging\n- GDPR: Right to deletion, data minimization\n- State bar rules: Attorney-client privilege protection\n\n---\n\n## Production Checklist\n\n```\n‚ñ° Form fields filled correctly (test with validation)\n‚ñ° Forms flattened after filling (non-editable)\n‚ñ° Page breaks controlled (no mid-sentence splits)\n‚ñ° Signature fields created (for DocuSign/Adobe Sign)\n‚ñ° PDFs encrypted at rest (S3 SSE or user password)\n‚ñ° Access logged (who viewed/downloaded)\n‚ñ° Auto-deletion scheduled (retention policy)\n‚ñ° Fonts embedded (cross-platform compatibility)\n‚ñ° File size optimized (&lt;5MB per document)\n‚ñ° Batch generation tested (1000+ PDFs)\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Appropriate? |\n|----------|--------------|\n| Fill 50+ government forms | ‚úÖ Yes - automate with pdf-lib |\n| Generate invoices from template | ‚úÖ Yes - Puppeteer from HTML |\n| Create certificates at scale | ‚úÖ Yes - pdf-lib or LaTeX |\n| Assemble multi-doc packets | ‚úÖ Yes - pdf-lib merge |\n| View PDFs in browser | ‚ùå No - use pdf.js or browser |\n| Edit PDF by hand | ‚ùå No - use Adobe Acrobat |\n| Extract text with OCR | ‚ùå No - use Tesseract/Textract |\n\n---\n\n## References\n\n- `/references/pdf-lib-guide.md` - Form filling, field types, flattening, encryption\n- `/references/puppeteer-templates.md` - HTML templates, page breaks, styling for print\n- `/references/document-assembly.md` - Merging PDFs, packet creation, watermarks\n\n## Scripts\n\n- `scripts/form_filler.ts` - Fill PDF forms from JSON data, batch processing\n- `scripts/document_assembler.ts` - Merge multiple PDFs, add cover pages, watermarks\n\n---\n\n**This skill guides**: PDF generation | Form filling | Document automation | Digital signatures | pdf-lib | Puppeteer | LaTeX | DocuSign\n"
    }
  ]
}