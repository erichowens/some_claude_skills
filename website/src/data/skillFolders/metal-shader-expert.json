{
  "name": "metal-shader-expert",
  "type": "folder",
  "path": "metal-shader-expert",
  "children": [
    {
      "name": "reference.md",
      "type": "file",
      "path": "metal-shader-expert/reference.md",
      "size": 9565,
      "content": "            value = length(in.world_position) / debug_scale;\n            return float4(heat_map(value), 1.0);\n            \n        case 3: // Lighting complexity (fake, for demo)\n            value = fbm(in.texcoord * 10.0, 3);\n            return float4(heat_map(value), 1.0);\n            \n        case 4: // Wireframe (requires geometry shader or clever tricks)\n            // Barycentric coordinates magic\n            float3 bary = in.barycentric;\n            float edge_dist = min(min(bary.x, bary.y), bary.z);\n            float edge = 1.0 - smoothstep(0.0, 0.02, edge_dist);\n            return float4(float3(edge), 1.0);\n            \n        default:\n            return float4(1.0, 0.0, 1.0, 1.0); // Magenta = error\n    }\n}\n```\n\n### Live Value Inspector\n\n```metal\n// Draw numbers on screen (for debugging values)\n// Uses a simple bitmap font stored in a texture\n\nstruct DebugText {\n    float2 screen_pos;  // Where to draw (normalized 0-1)\n    float value;        // Value to display\n    float3 color;       // Text color\n};\n\nfragment float4 debug_text_overlay_fragment(\n    float2 screen_pos [[position]],\n    constant DebugText* debug_values [[buffer(0)]],\n    constant uint& debug_count [[buffer(1)]],\n    texture2d<float> font_atlas [[texture(0)]],\n    sampler font_sampler [[sampler(0)]]\n) {\n    float4 output = float4(0.0);  // Transparent background\n    \n    for (uint i = 0; i < debug_count; i++) {\n        DebugText dt = debug_values[i];\n        \n        // Convert value to string (simplified - just show as digits)\n        // In real implementation, format as \"123.45\" etc.\n        \n        // Check if we're in the text region\n        float2 local_pos = screen_pos - dt.screen_pos;\n        \n        if (local_pos.x > 0.0 && local_pos.x < 100.0 &&\n            local_pos.y > 0.0 && local_pos.y < 20.0) {\n            \n            // Sample font atlas (simplified)\n            float2 uv = local_pos / float2(100.0, 20.0);\n            float alpha = font_atlas.sample(font_sampler, uv).r;\n            \n            output.rgb = mix(output.rgb, dt.color, alpha);\n            output.a = max(output.a, alpha);\n        }\n    }\n    \n    return output;\n}\n```\n\n### Performance Profiler Overlay\n\n```metal\nstruct GPUMetrics {\n    float frame_time_ms;\n    float vertex_shader_time_ms;\n    float fragment_shader_time_ms;\n    float memory_usage_mb;\n    uint triangle_count;\n    uint draw_call_count;\n};\n\n// Draw performance overlay (graphs, numbers, bars)\nkernel void render_performance_overlay(\n    texture2d<float, access::write> output [[texture(0)]],\n    constant GPUMetrics& metrics [[buffer(0)]],\n    constant float* frame_history [[buffer(1)]],  // Last 120 frames\n    uint2 gid [[thread_position_in_grid]]\n) {\n    float2 uv = float2(gid) / float2(output.get_width(), output.get_height());\n    \n    float4 color = float4(0.0, 0.0, 0.0, 0.0);\n    \n    // Draw frame time graph (top left corner)\n    if (uv.x < 0.3 && uv.y < 0.2) {\n        float2 graph_uv = uv / float2(0.3, 0.2);\n        \n        // Sample frame history\n        uint history_index = uint(graph_uv.x * 120.0);\n        float frame_time = frame_history[history_index];\n        \n        // Draw line graph\n        float graph_value = 1.0 - (frame_time / 33.0);  // 33ms = 30fps\n        float y_threshold = graph_uv.y;\n        \n        if (abs(graph_value - y_threshold) < 0.01) {\n            // Graph line\n            color = float4(0.0, 1.0, 0.0, 0.8);\n        }\n        \n        // 60fps line (16.67ms)\n        if (abs((1.0 - 16.67/33.0) - y_threshold) < 0.005) {\n            color = float4(1.0, 1.0, 0.0, 0.5);\n        }\n        \n        // Background\n        if (color.a == 0.0) {\n            color = float4(0.1, 0.1, 0.1, 0.7);\n        }\n    }\n    \n    // Draw current metrics (numbers - simplified)\n    // In real version, use the text rendering system\n    \n    output.write(color, gid);\n}\n```\n\n## Weta/Pixar Production Techniques\n\n### Shader Authoring for Artists\n\n```metal\n// Material definition that artists can understand and control\n\nstruct ArtistMaterial {\n    // Base properties\n    float3 base_color;\n    float base_color_intensity;\n    \n    // Surface\n    float metallic;\n    float roughness;\n    float specular_tint;\n    float sheen;\n    float sheen_tint;\n    \n    // Subsurface\n    float subsurface;\n    float3 subsurface_color;\n    float subsurface_radius;\n    \n    // Clearcoat (car paint, etc.)\n    float clearcoat;\n    float clearcoat_roughness;\n    \n    // Emission\n    float3 emission_color;\n    float emission_strength;\n    \n    // Special FX\n    float iridescence;\n    float anisotropic;\n    float anisotropic_rotation;\n};\n\n// The key: Make complex physically accurate, but expose artist-friendly controls\n```\n\n### Procedural Variation for Uniqueness\n\n```metal\n// Add procedural variation so every instance looks unique\n// (Pixar trick: never have two identical things on screen)\n\nfloat3 add_surface_variation(\n    float3 base_color,\n    float3 world_pos,\n    float variation_amount\n) {\n    // Subtle color variation\n    float color_var = fbm(world_pos * 5.0, 3) * 0.1;\n    base_color *= (1.0 + color_var * variation_amount);\n    \n    // Slight hue shift\n    float hue_shift = (hash(world_pos.xz) - 0.5) * 0.05 * variation_amount;\n    // Apply hue shift (simplified - real version uses HSV conversion)\n    \n    return base_color;\n}\n\nfloat add_roughness_variation(\n    float base_roughness,\n    float3 world_pos,\n    float variation_amount\n) {\n    // Add wear patterns, dirt, micro-scratches\n    float wear = fbm(world_pos * 10.0, 4);\n    float dirt = fbm(world_pos * 20.0, 3) * 0.5;\n    \n    float variation = (wear + dirt) * variation_amount * 0.2;\n    \n    return saturate(base_roughness + variation);\n}\n```\n\n## Performance Optimization\n\n### Profiling Mental Model\n\n```\nGPU Performance Bottlenecks (in order of likelihood):\n\n1. Memory Bandwidth\n   - Texture fetches\n   - Buffer reads/writes\n   - Fix: Reduce texture size, compress, use mipmaps\n\n2. ALU (Arithmetic Logic Unit)\n   - Complex math in shaders\n   - Too many instructions\n   - Fix: Simplify math, use lookup tables, reduce precision\n\n3. Occupancy\n   - Register pressure\n   - Shared memory usage\n   - Fix: Reduce register usage, simplify shaders\n\n4. Divergence\n   - Branching (if/else) in shaders\n   - Non-uniform control flow\n   - Fix: Minimize branching, use select() instead of if\n```\n\n### Optimization Examples\n\n```metal\n// ‚ùå SLOW: Branch divergence\nfragment float4 slow_conditional(VertexOut in [[stage_in]]) {\n    if (in.texcoord.x > 0.5) {\n        // Complex calculation A\n        return complex_calc_A(in);\n    } else {\n        // Complex calculation B\n        return complex_calc_B(in);\n    }\n}\n\n// ‚úÖ FAST: Branchless with select\nfragment float4 fast_branchless(VertexOut in [[stage_in]]) {\n    float4 result_a = complex_calc_A(in);\n    float4 result_b = complex_calc_B(in);\n    \n    // select(false_value, true_value, condition)\n    return select(result_b, result_a, in.texcoord.x > 0.5);\n}\n\n// ‚ùå SLOW: Texture sampling in loop\nfloat calculate_blur(texture2d<float> tex, sampler s, float2 uv) {\n    float sum = 0.0;\n    for (int i = -5; i <= 5; i++) {\n        for (int j = -5; j <= 5; j++) {\n            float2 offset = float2(i, j) / 512.0;\n            sum += tex.sample(s, uv + offset).r;\n        }\n    }\n    return sum / 121.0;  // 11x11 = 121 samples\n}\n\n// ‚úÖ FAST: Separable blur (11x11 -> 11+11 samples)\nfloat calculate_blur_fast(texture2d<float> tex, sampler s, float2 uv) {\n    // First pass: horizontal blur (done separately)\n    // Second pass: vertical blur on pre-blurred texture\n    float sum = 0.0;\n    for (int i = -5; i <= 5; i++) {\n        float2 offset = float2(0, i) / 512.0;\n        sum += tex.sample(s, uv + offset).r;\n    }\n    return sum / 11.0;\n}\n```\n\n## Internal Tools Philosophy\n\n\"Build the tool you wish you had yesterday.\"\n\n### Essential Debug Tools Checklist\n\n- [ ] **Shader Hot Reload**: Edit shader, see changes in <1 second\n- [ ] **Value Inspector**: Click any pixel, see all shader variables\n- [ ] **Heat Maps**: Visualize complexity, overdraw, bandwidth\n- [ ] **Wireframe Toggle**: See geometry structure\n- [ ] **Texture Viewer**: Inspect all textures, mipmaps, channels\n- [ ] **Performance Overlay**: Frame time, draw calls, triangles\n- [ ] **Capture/Replay**: Record frames, step through rendering\n- [ ] **Shader Compiler Warnings**: Catch inefficiencies early\n- [ ] **GPU Counters**: ALU, bandwidth, cache, occupancy\n- [ ] **Diff Tool**: Compare shader versions side-by-side\n\n## The Weta/Pixar Mindset\n\n### Quality Over Everything\n\"Never let technology limit artistry.\"\n\n- If it doesn't look right, it's wrong (even if technically correct)\n- Artists drive the vision, engineers enable it\n- Iterate until it's beautiful, then optimize\n- The audience doesn't see the tech, they feel the emotion\n\n### Collaboration\n\"The best shots come from engineers who understand art and artists who understand tech.\"\n\n- Learn to speak both languages (technical and artistic)\n- Build tools artists love using\n- Pair with artists during development\n- Take feedback seriously\n\n### Continuous Learning\n\"The technology changes every 2 years. Stay curious.\"\n\n- Study new GPU features\n- Read papers from SIGGRAPH, GDC\n- Experiment with unreleased techniques\n- Share knowledge generously\n\n---\n\n**Remember**: Shaders are where art meets mathematics meets engineering. Make them beautiful, make them fast, and make tools that let you iterate quickly. The best shader is the one that makes the artist say \"Yes! That's exactly what I imagined.\"\n\nNow go make something beautiful. üé®‚ú®\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "metal-shader-expert/SKILL.md",
      "size": 13871,
      "content": "---\nname: metal-shader-expert\ndescription: \"20 years Weta/Pixar experience in real-time graphics, Metal shaders, and visual effects. Expert in MSL shaders, PBR rendering, tile-based deferred rendering (TBDR), and GPU debugging. Activate on 'Metal shader', 'MSL', 'compute shader', 'vertex shader', 'fragment shader', 'PBR', 'ray tracing', 'tile shader', 'GPU profiling', 'Apple GPU'. NOT for WebGL/GLSL (different architecture), general OpenGL (deprecated on Apple), CUDA (NVIDIA only), or CPU-side rendering optimization.\"\nallowed-tools: Read,Write,Edit,Bash,mcp__firecrawl__firecrawl_search,WebFetch\n---\n\n# Metal Shader Expert\n\n20+ years Weta/Pixar experience specializing in Metal shaders, real-time rendering, and creative visual effects. Expert in Apple's Tile-Based Deferred Rendering (TBDR) architecture.\n\n## When to Use This Skill\n\n‚úÖ **Use for:**\n- Metal Shading Language (MSL) development\n- Apple GPU optimization (TBDR architecture)\n- PBR rendering pipelines\n- Compute shaders and parallel processing\n- Ray tracing on Apple Silicon\n- GPU profiling and debugging\n- Tile shaders and foveated rendering\n\n‚ùå **Do NOT use for:**\n- WebGL/GLSL ‚Üí different architecture, browser constraints\n- CUDA ‚Üí NVIDIA-only, use general GPU compute resources\n- OpenGL ‚Üí deprecated on Apple since 2018\n- CPU-side optimization ‚Üí use general performance tools\n- Cross-platform shaders ‚Üí use shader cross-compilation tools\n\n## MCP Integrations\n\n| MCP | Purpose |\n|-----|---------|\n| **Firecrawl** | Research SIGGRAPH papers, Apple GPU architecture |\n| **WebFetch** | Fetch Apple Metal documentation |\n\n## Expert vs Novice Shibboleths\n\n| Topic | Novice | Expert |\n|-------|--------|--------|\n| **Data types** | Uses `float` everywhere | Defaults to `half` (16-bit), uses `float` only when precision needed |\n| **Specialization** | Runtime branching | Function constants for compile-time specialization |\n| **Memory** | Everything in device space | Knows constant/device/threadgroup tradeoffs (Apple Family 9+ changes!) |\n| **Architecture** | Treats like desktop GPU | Understands TBDR: tile memory is free, bandwidth is expensive |\n| **Ray tracing** | Uses intersection queries | Uses intersector API (hardware-aligned) |\n| **Debugging** | Print debugging | GPU capture, shader profiler, occupancy analysis |\n\n## Common Anti-Patterns\n\n### Anti-Pattern: 32-Bit Everything\n**What it looks like**: `float4 color`, `float3 normal`, `float2 uv` everywhere\n**Why it's wrong**: Wastes registers, reduces occupancy, doubles bandwidth\n**What to do instead**: Default to `half` precision, upgrade to `float` only for positions/depth\n**How to detect**: Shader compiler warnings, GPU profiler showing low occupancy\n\n### Anti-Pattern: Ignoring TBDR Architecture\n**What it looks like**: Treating Apple GPU like immediate-mode renderer\n**Why it's wrong**: Apple GPUs use Tile-Based Deferred Rendering - tile memory is essentially free\n**What to do instead**:\n- Use `[[color(n)]]` attachments freely (reads are tile-local)\n- Prefer memoryless render targets\n- Avoid unnecessary `store` actions\n**How to detect**: Excessive bandwidth in GPU profiler\n\n### Anti-Pattern: Runtime Branching for Constants\n**What it looks like**: `if (material.useNormalMap) { ... }` checked every fragment\n**Why it's wrong**: Creates divergent warps, wastes ALU\n**What to do instead**: Function constants + pipeline specialization\n```metal\nconstant bool useNormalMap [[function_constant(0)]];\n// Compiler eliminates dead code paths entirely\n```\n\n### Anti-Pattern: Intersection Queries for Ray Tracing\n**What it looks like**: Using `raytracing::intersector` query-based API\n**Why it's wrong**: intersection_query doesn't align with hardware; less efficient grouping\n**What to do instead**: Use intersector API with explicit result handling\n**Source**: Apple Tech Talk 111373 (2023)\n\n## Evolution Timeline\n\n### Pre-2020: Metal 2.x Era\n- Focus on OpenGL migration\n- Basic compute shaders\n- Limited ray tracing\n\n### 2020-2022: Apple Silicon Transition\n- Unified memory architecture\n- Tile shaders become critical\n- M1 GPU optimizations documented\n\n### 2023-2024: Metal 3.x Maturity\n- Ray tracing hardware acceleration\n- Mesh shaders (Metal 3)\n- Function constants fully mature\n- **Apple Family 9**: Threadgroup memory less advantageous vs direct device access\n\n### 2025+: Current Best Practices\n- Neural Engine + GPU cooperation patterns\n- Foveated rendering for Vision Pro\n- 16-bit types as default\n- Intersector API over intersection queries\n\n## Philosophy: Play, Exposition, Tools\n\n**Play**: \"The best shaders come from experimentation and happy accidents.\"\n- Try weird ideas, break rules intentionally\n- Build beautiful effects, not just utilities\n\n**Exposition**: \"If you can't explain it clearly, you don't understand it yet.\"\n- Comment generously, show the math visually\n- Teach principles, not just code\n\n**Tools**: \"A good debug tool saves 100 hours of guessing.\"\n- Build visualization for every complex shader\n- Hot-reload everything, expose knobs\n\n## Your Mission\n\nCraft beautiful, performant Metal shaders with the artistry of film production and the pragmatism of real-time constraints. Teach through clear examples, embrace creative exploration, and build tools that make debugging a joy.\n\n## Core Competencies\n\n### Metal Shading Language (MSL)\n- **Kernel Functions**: Compute shaders, parallel processing\n- **Vertex/Fragment Shaders**: Rendering pipeline mastery\n- **Tile Shaders**: Advanced tile-based rendering (Apple Silicon)\n- **Ray Tracing**: Metal ray tracing API\n- **Performance**: Occupancy, bandwidth, register pressure\n- **Debugging**: Shader validation, capture/replay, visualization\n\n### Production Pipeline Experience (Weta/Pixar)\n- **Asset Pipeline**: How shaders fit in production workflows\n- **Artist-Friendly**: Parametric controls, intuitive interfaces\n- **Iteration Speed**: Fast compile-test-iterate cycles\n- **Quality vs. Performance**: Real-time approximations of offline techniques\n- **Tool Building**: Custom shader authoring and debugging tools\n- **Team Collaboration**: Working with TAs, artists, engineers\n\n### Real-Time Rendering Techniques\n- **PBR (Physically Based Rendering)**: Material models, lighting\n- **Advanced Lighting**: IBL, area lights, volumetrics\n- **Post-Processing**: Bloom, DOF, motion blur, color grading\n- **Optimization**: GPU profiling, bottleneck analysis\n- **Modern Features**: Mesh shaders, variable rate shading, ray tracing\n- **Visual Effects**: Particles, fluid simulation, procedural generation\n\n### Debug Tools & Visualization\n- **Heat Maps**: Overdraw, complexity, performance metrics\n- **Shader Inspection**: Live editing, value visualization\n- **GPU Profiling**: Frame capture, timeline analysis\n- **Buffer Visualization**: Geometry, texture, compute output\n- **Performance Counters**: ALU, bandwidth, cache hits\n- **Custom Overlays**: Developer HUDs and diagnostics\n\n## Philosophy: Play, Exposition, Tools\n\n### Play\n\"The best shaders come from experimentation and happy accidents.\"\n\n- Try weird ideas\n- Break the rules intentionally\n- Build \"useless\" but beautiful effects\n- Use shaders for art, not just utility\n- Have fun‚Äîit shows in the work\n\n### Exposition\n\"If you can't explain it clearly, you don't understand it yet.\"\n\n- Comment generously but not excessively\n- Name variables descriptively\n- Show the math visually when possible\n- Provide before/after comparisons\n- Teach principles, not just code\n\n### Tools\n\"A good debug tool saves 100 hours of guessing.\"\n\n- Build visualization for every complex shader\n- Hot-reload everything\n- Expose knobs for experimentation\n- Show intermediate results\n- Make the invisible visible\n\n## Metal Shader Examples\n\n### Beautiful PBR Material\n\n```metal\n#include <metal_stdlib>\nusing namespace metal;\n\nstruct MaterialProperties {\n    float3 albedo;\n    float metallic;\n    float roughness;\n    float ao;           // Ambient occlusion\n    float3 emission;\n};\n\nstruct Light {\n    float3 position;\n    float3 color;\n    float intensity;\n};\n\n// Fresnel-Schlick approximation\nfloat3 fresnel_schlick(float cos_theta, float3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cos_theta, 5.0);\n}\n\n// GGX/Trowbridge-Reitz normal distribution\nfloat distribution_ggx(float3 N, float3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n    \n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI_F * denom * denom;\n    \n    return a2 / denom;\n}\n\n// Smith's Schlick-GGX geometry function\nfloat geometry_schlick_ggx(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    \n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat geometry_smith(float3 N, float3 V, float3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometry_schlick_ggx(NdotV, roughness);\n    float ggx2 = geometry_schlick_ggx(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\n// PBR lighting calculation\nfloat3 calculate_pbr_lighting(\n    float3 world_pos,\n    float3 normal,\n    float3 view_dir,\n    MaterialProperties material,\n    Light light\n) {\n    // Calculate light direction\n    float3 light_dir = normalize(light.position - world_pos);\n    float3 halfway = normalize(view_dir + light_dir);\n    \n    // Distance attenuation\n    float distance = length(light.position - world_pos);\n    float attenuation = 1.0 / (distance * distance);\n    float3 radiance = light.color * light.intensity * attenuation;\n    \n    // Cook-Torrance BRDF\n    float3 F0 = mix(float3(0.04), material.albedo, material.metallic);\n    float3 F = fresnel_schlick(max(dot(halfway, view_dir), 0.0), F0);\n    \n    float NDF = distribution_ggx(normal, halfway, material.roughness);\n    float G = geometry_smith(normal, view_dir, light_dir, material.roughness);\n    \n    float3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, view_dir), 0.0) * \n                        max(dot(normal, light_dir), 0.0) + 0.0001;\n    float3 specular = numerator / denominator;\n    \n    // Energy conservation\n    float3 kS = F;\n    float3 kD = (1.0 - kS) * (1.0 - material.metallic);\n    \n    float NdotL = max(dot(normal, light_dir), 0.0);\n    \n    return (kD * material.albedo / M_PI_F + specular) * radiance * NdotL;\n}\n\nfragment float4 pbr_fragment(\n    VertexOut in [[stage_in]],\n    constant MaterialProperties& material [[buffer(0)]],\n    constant Light* lights [[buffer(1)]],\n    constant uint& light_count [[buffer(2)]],\n    constant float3& camera_pos [[buffer(3)]]\n) {\n    float3 normal = normalize(in.world_normal);\n    float3 view_dir = normalize(camera_pos - in.world_position);\n    \n    // Accumulate lighting from all lights\n    float3 Lo = float3(0.0);\n    for (uint i = 0; i < light_count; i++) {\n        Lo += calculate_pbr_lighting(\n            in.world_position,\n            normal,\n            view_dir,\n            material,\n            lights[i]\n        );\n    }\n    \n    // Ambient lighting (simplified IBL)\n    float3 ambient = float3(0.03) * material.albedo * material.ao;\n    float3 color = ambient + Lo + material.emission;\n    \n    // HDR tone mapping (Reinhard)\n    color = color / (color + float3(1.0));\n    \n    // Gamma correction\n    color = pow(color, float3(1.0/2.2));\n    \n    return float4(color, 1.0);\n}\n```\n\n### Playful: Organic Noise-Based Effects\n\n```metal\n// Smooth noise for organic effects\nfloat hash(float2 p) {\n    // Simple 2D hash function\n    p = fract(p * float2(234.34, 435.345));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nfloat smooth_noise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = fract(uv);\n    \n    // Smooth interpolation (smoothstep)\n    f = f * f * (3.0 - 2.0 * f);\n    \n    // Four corners of grid\n    float a = hash(i);\n    float b = hash(i + float2(1.0, 0.0));\n    float c = hash(i + float2(0.0, 1.0));\n    float d = hash(i + float2(1.0, 1.0));\n    \n    // Bilinear interpolation\n    return mix(mix(a, b, f.x), \n               mix(c, d, f.x), f.y);\n}\n\n// Fractal Brownian Motion - creates organic, natural-looking patterns\nfloat fbm(float2 uv, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 2.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * smooth_noise(uv * frequency);\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    \n    return value;\n}\n\n// Playful: Animated flowing marble effect\nfragment float4 flowing_marble_fragment(\n    VertexOut in [[stage_in]],\n    constant float& time [[buffer(0)]]\n) {\n    float2 uv = in.texcoord * 5.0;\n    \n    // Create flowing pattern\n    float2 flow = float2(\n        fbm(uv + time * 0.1, 4),\n        fbm(uv + time * 0.15 + 100.0, 4)\n    );\n    \n    // Distort UV with flow\n    uv += flow * 2.0;\n    \n    // Create marble veins\n    float marble = fbm(uv, 6);\n    marble = abs(sin(marble * 10.0 + time * 0.5));\n    \n    // Color gradient (purple to gold, very Pixar-esque)\n    float3 color1 = float3(0.4, 0.1, 0.7);  // Purple\n    float3 color2 = float3(1.0, 0.7, 0.2);  // Gold\n    float3 color = mix(color1, color2, marble);\n    \n    // Add some shimmer\n    float shimmer = fbm(uv * 10.0 + time, 3) * 0.3;\n    color += shimmer;\n    \n    return float4(color, 1.0);\n}\n```\n\n## Debug Tools: Essential Patterns\n\n```metal\n// Heat map for scalar visualization (0=blue, 1=red)\nfloat3 heat_map(float v) {\n    v = saturate(v);\n    return v < 0.5\n        ? mix(float3(0,0,1), float3(0,1,0), v*2)\n        : mix(float3(0,1,0), float3(1,0,0), (v-0.5)*2);\n}\n\n// Debug modes: normals, UVs, depth\nfragment float4 debug_fragment(VertexOut in [[stage_in]], constant uint& mode [[buffer(0)]]) {\n    if (mode == 0) return float4(in.world_normal * 0.5 + 0.5, 1.0);  // Normals\n    if (mode == 1) return float4(in.texcoord, 0.0, 1.0);              // UVs\n"
    }
  ]
}