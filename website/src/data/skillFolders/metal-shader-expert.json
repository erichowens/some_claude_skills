{
  "name": "metal-shader-expert",
  "type": "folder",
  "path": "metal-shader-expert",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "metal-shader-expert/references",
      "children": [
        {
          "name": "debug-tools.md",
          "type": "file",
          "path": "metal-shader-expert/references/debug-tools.md",
          "size": 4998,
          "content": "# Debug Tools & Visualization\n\nEssential patterns for shader debugging and performance analysis.\n\n## Heat Map Visualization\n\n```metal\n// Visualize scalar values: 0=blue, 0.5=green, 1=red\nfloat3 heat_map(float v) {\n    v = saturate(v);\n    return v < 0.5\n        ? mix(float3(0,0,1), float3(0,1,0), v*2)\n        : mix(float3(0,1,0), float3(1,0,0), (v-0.5)*2);\n}\n\n// Extended heat map with purple for overflow\nfloat3 heat_map_extended(float v) {\n    if (v < 0.0) return float3(0.5, 0, 0.5);  // Magenta: negative\n    if (v > 1.0) return float3(1, 0, 1);       // Purple: overflow\n    return heat_map(v);\n}\n```\n\n## Debug Visualization Modes\n\n```metal\nfragment float4 debug_fragment(\n    VertexOut in [[stage_in]],\n    constant uint& mode [[buffer(0)]]\n) {\n    switch (mode) {\n        case 0: // World normals\n            return float4(in.world_normal * 0.5 + 0.5, 1.0);\n\n        case 1: // UV coordinates\n            return float4(in.texcoord, 0.0, 1.0);\n\n        case 2: // Depth (linear)\n            float depth = in.position.z / in.position.w;\n            return float4(float3(depth), 1.0);\n\n        case 3: // Tangent space\n            return float4(in.tangent * 0.5 + 0.5, 1.0);\n\n        case 4: // Bitangent\n            return float4(in.bitangent * 0.5 + 0.5, 1.0);\n\n        case 5: // World position (wrapped)\n            return float4(fract(in.world_position), 1.0);\n\n        default:\n            return float4(1, 0, 1, 1);  // Magenta = error\n    }\n}\n```\n\n## Overdraw Visualization\n\n```metal\n// Increment counter per fragment\nkernel void overdraw_counter(\n    texture2d<uint, access::read_write> counter [[texture(0)]],\n    uint2 gid [[thread_position_in_grid]]\n) {\n    uint current = counter.read(gid).r;\n    counter.write(uint4(current + 1), gid);\n}\n\n// Visualize overdraw\nfragment float4 overdraw_visualize(\n    VertexOut in [[stage_in]],\n    texture2d<uint> counter [[texture(0)]]\n) {\n    uint2 pos = uint2(in.position.xy);\n    uint count = counter.read(pos).r;\n\n    // Heat map: 1=green, 2=yellow, 3+=red\n    float normalized = float(count) / 5.0;\n    return float4(heat_map(normalized), 1.0);\n}\n```\n\n## Mipmap Level Visualization\n\n```metal\n// Shows which mipmap is being sampled\nfloat3 mip_colors[] = {\n    float3(1,0,0),   // Mip 0 - Red\n    float3(1,0.5,0), // Mip 1 - Orange\n    float3(1,1,0),   // Mip 2 - Yellow\n    float3(0,1,0),   // Mip 3 - Green\n    float3(0,1,1),   // Mip 4 - Cyan\n    float3(0,0,1),   // Mip 5 - Blue\n    float3(0.5,0,1), // Mip 6 - Purple\n    float3(1,0,1),   // Mip 7 - Magenta\n};\n\nfragment float4 mip_debug(\n    VertexOut in [[stage_in]],\n    texture2d<float> tex [[texture(0)]]\n) {\n    // Calculate mip level from UV derivatives\n    float2 dx = dfdx(in.texcoord);\n    float2 dy = dfdy(in.texcoord);\n    float delta = max(dot(dx, dx), dot(dy, dy));\n    float mip = 0.5 * log2(delta * tex.get_width() * tex.get_width());\n\n    int mip_index = clamp(int(mip), 0, 7);\n    return float4(mip_colors[mip_index], 1.0);\n}\n```\n\n## NaN/Inf Detection\n\n```metal\nfloat4 nan_check(float4 color) {\n    if (any(isnan(color))) return float4(1, 0, 1, 1);  // Magenta = NaN\n    if (any(isinf(color))) return float4(0, 1, 1, 1);  // Cyan = Inf\n    return color;\n}\n```\n\n## Wireframe Overlay\n\n```metal\n// Barycentric wireframe (requires vertex shader to pass barycentrics)\nfloat wireframe(float3 bary, float thickness) {\n    float3 d = fwidth(bary);\n    float3 a = smoothstep(float3(0), d * thickness, bary);\n    return min(min(a.x, a.y), a.z);\n}\n\nfragment float4 wireframe_overlay(\n    VertexOut in [[stage_in]],\n    constant float4& base_color [[buffer(0)]],\n    constant float4& wire_color [[buffer(1)]]\n) {\n    float edge = wireframe(in.barycentrics, 1.5);\n    return mix(wire_color, base_color, edge);\n}\n```\n\n## Performance Timers\n\n```metal\n// Measure shader complexity by counting iterations\nkernel void complexity_visualize(\n    texture2d<float, access::write> output [[texture(0)]],\n    constant uint& max_iterations [[buffer(0)]],\n    uint2 gid [[thread_position_in_grid]]\n) {\n    uint iterations = 0;\n\n    // Your algorithm with iteration counting\n    while (/* condition */ iterations < max_iterations) {\n        // Work...\n        iterations++;\n    }\n\n    float complexity = float(iterations) / float(max_iterations);\n    output.write(float4(heat_map(complexity), 1.0), gid);\n}\n```\n\n## GPU Capture Integration\n\nUse Xcode GPU Capture for:\n- Frame timeline analysis\n- Shader profiler\n- Memory bandwidth\n- Occupancy metrics\n- Pipeline state inspection\n\n### Best Practices\n\n1. **Always have a debug mode**: Toggle with function constant\n2. **Color-code errors**: Magenta for NaN, Cyan for Inf\n3. **Visualize intermediate buffers**: G-buffer, shadow maps\n4. **Add performance overlays**: FPS, draw calls, triangles\n5. **Hot-reload shaders**: Metal Library at runtime\n\n## Debug Macro Pattern\n\n```metal\n#if DEBUG_MODE\n    return float4(heat_map(some_value), 1.0);\n#else\n    return final_color;\n#endif\n```\n\nUse function constants for runtime toggling without recompilation.\n"
        },
        {
          "name": "noise-effects.md",
          "type": "file",
          "path": "metal-shader-expert/references/noise-effects.md",
          "size": 4171,
          "content": "# Noise-Based Effects\n\nOrganic, procedural effects using noise functions in Metal.\n\n## Hash Functions\n\n```metal\n// Simple 2D hash function\nfloat hash(float2 p) {\n    p = fract(p * float2(234.34, 435.345));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\n// 3D hash for volumetric effects\nfloat hash3(float3 p) {\n    p = fract(p * float3(443.897, 441.423, 437.195));\n    p += dot(p, p.yzx + 19.19);\n    return fract((p.x + p.y) * p.z);\n}\n```\n\n## Smooth Noise\n\n```metal\nfloat smooth_noise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = fract(uv);\n\n    // Smooth interpolation (smoothstep)\n    f = f * f * (3.0 - 2.0 * f);\n\n    // Four corners of grid\n    float a = hash(i);\n    float b = hash(i + float2(1.0, 0.0));\n    float c = hash(i + float2(0.0, 1.0));\n    float d = hash(i + float2(1.0, 1.0));\n\n    // Bilinear interpolation\n    return mix(mix(a, b, f.x),\n               mix(c, d, f.x), f.y);\n}\n```\n\n## Fractal Brownian Motion (FBM)\n\nCreates organic, natural-looking patterns by layering noise at different frequencies.\n\n```metal\nfloat fbm(float2 uv, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 2.0;\n\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * smooth_noise(uv * frequency);\n        amplitude *= 0.5;  // Persistence\n        frequency *= 2.0;  // Lacunarity\n    }\n\n    return value;\n}\n```\n\n### FBM Parameters\n\n| Parameter | Effect |\n|-----------|--------|\n| **Octaves** | More = finer detail, higher cost |\n| **Persistence** (amplitude multiplier) | Lower = smoother, higher = rougher |\n| **Lacunarity** (frequency multiplier) | Controls how fast detail increases |\n\nTypical values:\n- Clouds: 6-8 octaves, 0.5 persistence\n- Terrain: 8-12 octaves, 0.6 persistence\n- Marble: 4-6 octaves, 0.5 persistence\n\n## Animated Flowing Marble Effect\n\n```metal\nfragment float4 flowing_marble_fragment(\n    VertexOut in [[stage_in]],\n    constant float& time [[buffer(0)]]\n) {\n    float2 uv = in.texcoord * 5.0;\n\n    // Create flowing pattern\n    float2 flow = float2(\n        fbm(uv + time * 0.1, 4),\n        fbm(uv + time * 0.15 + 100.0, 4)\n    );\n\n    // Distort UV with flow\n    uv += flow * 2.0;\n\n    // Create marble veins\n    float marble = fbm(uv, 6);\n    marble = abs(sin(marble * 10.0 + time * 0.5));\n\n    // Color gradient (purple to gold)\n    float3 color1 = float3(0.4, 0.1, 0.7);  // Purple\n    float3 color2 = float3(1.0, 0.7, 0.2);  // Gold\n    float3 color = mix(color1, color2, marble);\n\n    // Add shimmer\n    float shimmer = fbm(uv * 10.0 + time, 3) * 0.3;\n    color += shimmer;\n\n    return float4(color, 1.0);\n}\n```\n\n## Domain Warping\n\nDistort UV coordinates with noise for organic effects:\n\n```metal\nfloat2 warp_domain(float2 uv, float time) {\n    float2 q = float2(\n        fbm(uv, 4),\n        fbm(uv + float2(5.2, 1.3), 4)\n    );\n\n    float2 r = float2(\n        fbm(uv + q + float2(1.7, 9.2) + 0.15 * time, 4),\n        fbm(uv + q + float2(8.3, 2.8) + 0.126 * time, 4)\n    );\n\n    return uv + r * 2.0;\n}\n```\n\n## Voronoi / Cellular Noise\n\n```metal\nfloat voronoi(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = fract(uv);\n\n    float min_dist = 1.0;\n\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            float2 neighbor = float2(x, y);\n            float2 point = float2(hash(i + neighbor),\n                                   hash(i + neighbor + 127.0));\n            float dist = length(neighbor + point - f);\n            min_dist = min(min_dist, dist);\n        }\n    }\n\n    return min_dist;\n}\n```\n\n## Performance Tips\n\n1. **Unroll small loops**: `[[unroll]]` for octave loops with fixed count\n2. **Use half precision**: `half` for color calculations\n3. **Precompute gradients**: For Perlin noise, texture-based gradients faster\n4. **Limit octaves**: 4-6 is usually enough for real-time\n5. **LOD-based detail**: Fewer octaves for distant objects\n\n## Effect Ideas\n\n| Effect | Technique |\n|--------|-----------|\n| Fire | FBM + time + color ramp |\n| Water caustics | Animated Voronoi |\n| Clouds | FBM with domain warping |\n| Marble | FBM with sin() banding |\n| Wood grain | FBM rings + turbulence |\n| Plasma | Multiple sin waves + time |\n"
        },
        {
          "name": "pbr-shaders.md",
          "type": "file",
          "path": "metal-shader-expert/references/pbr-shaders.md",
          "size": 4581,
          "content": "# PBR Shader Implementation\n\nComplete Cook-Torrance BRDF implementation in Metal Shading Language.\n\n## Material Properties Structure\n\n```metal\nstruct MaterialProperties {\n    float3 albedo;\n    float metallic;\n    float roughness;\n    float ao;           // Ambient occlusion\n    float3 emission;\n};\n\nstruct Light {\n    float3 position;\n    float3 color;\n    float intensity;\n};\n```\n\n## BRDF Components\n\n### Fresnel-Schlick Approximation\n\n```metal\nfloat3 fresnel_schlick(float cos_theta, float3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cos_theta, 5.0);\n}\n```\n\n### GGX/Trowbridge-Reitz Normal Distribution\n\n```metal\nfloat distribution_ggx(float3 N, float3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI_F * denom * denom;\n\n    return a2 / denom;\n}\n```\n\n### Smith's Schlick-GGX Geometry Function\n\n```metal\nfloat geometry_schlick_ggx(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat geometry_smith(float3 N, float3 V, float3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometry_schlick_ggx(NdotV, roughness);\n    float ggx2 = geometry_schlick_ggx(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n```\n\n## Complete PBR Lighting Function\n\n```metal\nfloat3 calculate_pbr_lighting(\n    float3 world_pos,\n    float3 normal,\n    float3 view_dir,\n    MaterialProperties material,\n    Light light\n) {\n    // Calculate light direction\n    float3 light_dir = normalize(light.position - world_pos);\n    float3 halfway = normalize(view_dir + light_dir);\n\n    // Distance attenuation\n    float distance = length(light.position - world_pos);\n    float attenuation = 1.0 / (distance * distance);\n    float3 radiance = light.color * light.intensity * attenuation;\n\n    // Cook-Torrance BRDF\n    float3 F0 = mix(float3(0.04), material.albedo, material.metallic);\n    float3 F = fresnel_schlick(max(dot(halfway, view_dir), 0.0), F0);\n\n    float NDF = distribution_ggx(normal, halfway, material.roughness);\n    float G = geometry_smith(normal, view_dir, light_dir, material.roughness);\n\n    float3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, view_dir), 0.0) *\n                        max(dot(normal, light_dir), 0.0) + 0.0001;\n    float3 specular = numerator / denominator;\n\n    // Energy conservation\n    float3 kS = F;\n    float3 kD = (1.0 - kS) * (1.0 - material.metallic);\n\n    float NdotL = max(dot(normal, light_dir), 0.0);\n\n    return (kD * material.albedo / M_PI_F + specular) * radiance * NdotL;\n}\n```\n\n## Fragment Shader\n\n```metal\nfragment float4 pbr_fragment(\n    VertexOut in [[stage_in]],\n    constant MaterialProperties& material [[buffer(0)]],\n    constant Light* lights [[buffer(1)]],\n    constant uint& light_count [[buffer(2)]],\n    constant float3& camera_pos [[buffer(3)]]\n) {\n    float3 normal = normalize(in.world_normal);\n    float3 view_dir = normalize(camera_pos - in.world_position);\n\n    // Accumulate lighting from all lights\n    float3 Lo = float3(0.0);\n    for (uint i = 0; i < light_count; i++) {\n        Lo += calculate_pbr_lighting(\n            in.world_position,\n            normal,\n            view_dir,\n            material,\n            lights[i]\n        );\n    }\n\n    // Ambient lighting (simplified IBL)\n    float3 ambient = float3(0.03) * material.albedo * material.ao;\n    float3 color = ambient + Lo + material.emission;\n\n    // HDR tone mapping (Reinhard)\n    color = color / (color + float3(1.0));\n\n    // Gamma correction\n    color = pow(color, float3(1.0/2.2));\n\n    return float4(color, 1.0);\n}\n```\n\n## Key Concepts\n\n### Cook-Torrance BRDF\nThe specular term: `(D * G * F) / (4 * NdotV * NdotL)`\n- **D**: Normal Distribution Function (GGX)\n- **G**: Geometry Function (Smith)\n- **F**: Fresnel (Schlick approximation)\n\n### Energy Conservation\n`kD = (1 - kS) * (1 - metallic)`\n- Metals have no diffuse component\n- Total reflected energy never exceeds incoming\n\n### F0 Values\n- Dielectrics: ~0.04 (plastic, fabric, skin)\n- Metals: Use albedo as F0\n- `F0 = mix(0.04, albedo, metallic)`\n\n## Half-Precision Optimization\n\nFor mobile/Apple Silicon, convert to `half` precision:\n\n```metal\nhalf3 fresnel_schlick_half(half cos_theta, half3 F0) {\n    return F0 + (half3(1.0h) - F0) * pow(1.0h - cos_theta, 5.0h);\n}\n```\n\nOnly use `float` for:\n- World positions\n- Depth values\n- Cumulative calculations\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "metal-shader-expert/CHANGELOG.md",
      "size": 875,
      "content": "# Changelog\n\n## [2.0.0] - 2024-12-XX\n\n### Changed\n- **SKILL.md restructured** for progressive disclosure (406 â†’ ~115 lines)\n- Shader code examples extracted to reference files\n- Removed duplicate Philosophy section\n\n### Added\n- `references/pbr-shaders.md` - Complete Cook-Torrance BRDF, Fresnel-Schlick, GGX distribution, Smith geometry\n- `references/noise-effects.md` - Hash functions, smooth noise, FBM, Voronoi, domain warping, animated effects\n- `references/debug-tools.md` - Heat maps, debug modes, overdraw visualization, NaN detection, wireframe overlay\n- Shibboleths table (half vs float, TBDR architecture, intersector API)\n- Apple Family 9 note on threadgroup memory changes\n\n### Migration Guide\n- No changes to frontmatter or activation triggers\n- Shader code now in reference files for copy-paste use\n- Philosophy section deduplicated (single version retained)\n"
    },
    {
      "name": "reference.md",
      "type": "file",
      "path": "metal-shader-expert/reference.md",
      "size": 9616,
      "content": "            value = length(in.world_position) / debug_scale;\n            return float4(heat_map(value), 1.0);\n            \n        case 3: // Lighting complexity (fake, for demo)\n            value = fbm(in.texcoord * 10.0, 3);\n            return float4(heat_map(value), 1.0);\n            \n        case 4: // Wireframe (requires geometry shader or clever tricks)\n            // Barycentric coordinates magic\n            float3 bary = in.barycentric;\n            float edge_dist = min(min(bary.x, bary.y), bary.z);\n            float edge = 1.0 - smoothstep(0.0, 0.02, edge_dist);\n            return float4(float3(edge), 1.0);\n            \n        default:\n            return float4(1.0, 0.0, 1.0, 1.0); // Magenta = error\n    }\n}\n```\n\n### Live Value Inspector\n\n```metal\n// Draw numbers on screen (for debugging values)\n// Uses a simple bitmap font stored in a texture\n\nstruct DebugText {\n    float2 screen_pos;  // Where to draw (normalized 0-1)\n    float value;        // Value to display\n    float3 color;       // Text color\n};\n\nfragment float4 debug_text_overlay_fragment(\n    float2 screen_pos [[position]],\n    constant DebugText* debug_values [[buffer(0)]],\n    constant uint& debug_count [[buffer(1)]],\n    texture2d&lt;float&gt; font_atlas [[texture(0)]],\n    sampler font_sampler [[sampler(0)]]\n) {\n    float4 output = float4(0.0);  // Transparent background\n    \n    for (uint i = 0; i &lt; debug_count; i++) {\n        DebugText dt = debug_values[i];\n        \n        // Convert value to string (simplified - just show as digits)\n        // In real implementation, format as \"123.45\" etc.\n        \n        // Check if we're in the text region\n        float2 local_pos = screen_pos - dt.screen_pos;\n        \n        if (local_pos.x > 0.0 && local_pos.x &lt; 100.0 &&\n            local_pos.y > 0.0 && local_pos.y &lt; 20.0) {\n            \n            // Sample font atlas (simplified)\n            float2 uv = local_pos / float2(100.0, 20.0);\n            float alpha = font_atlas.sample(font_sampler, uv).r;\n            \n            output.rgb = mix(output.rgb, dt.color, alpha);\n            output.a = max(output.a, alpha);\n        }\n    }\n    \n    return output;\n}\n```\n\n### Performance Profiler Overlay\n\n```metal\nstruct GPUMetrics {\n    float frame_time_ms;\n    float vertex_shader_time_ms;\n    float fragment_shader_time_ms;\n    float memory_usage_mb;\n    uint triangle_count;\n    uint draw_call_count;\n};\n\n// Draw performance overlay (graphs, numbers, bars)\nkernel void render_performance_overlay(\n    texture2d<float, access::write> output [[texture(0)]],\n    constant GPUMetrics& metrics [[buffer(0)]],\n    constant float* frame_history [[buffer(1)]],  // Last 120 frames\n    uint2 gid [[thread_position_in_grid]]\n) {\n    float2 uv = float2(gid) / float2(output.get_width(), output.get_height());\n    \n    float4 color = float4(0.0, 0.0, 0.0, 0.0);\n    \n    // Draw frame time graph (top left corner)\n    if (uv.x &lt; 0.3 && uv.y &lt; 0.2) {\n        float2 graph_uv = uv / float2(0.3, 0.2);\n        \n        // Sample frame history\n        uint history_index = uint(graph_uv.x * 120.0);\n        float frame_time = frame_history[history_index];\n        \n        // Draw line graph\n        float graph_value = 1.0 - (frame_time / 33.0);  // 33ms = 30fps\n        float y_threshold = graph_uv.y;\n        \n        if (abs(graph_value - y_threshold) &lt; 0.01) {\n            // Graph line\n            color = float4(0.0, 1.0, 0.0, 0.8);\n        }\n        \n        // 60fps line (16.67ms)\n        if (abs((1.0 - 16.67/33.0) - y_threshold) &lt; 0.005) {\n            color = float4(1.0, 1.0, 0.0, 0.5);\n        }\n        \n        // Background\n        if (color.a == 0.0) {\n            color = float4(0.1, 0.1, 0.1, 0.7);\n        }\n    }\n    \n    // Draw current metrics (numbers - simplified)\n    // In real version, use the text rendering system\n    \n    output.write(color, gid);\n}\n```\n\n## Weta/Pixar Production Techniques\n\n### Shader Authoring for Artists\n\n```metal\n// Material definition that artists can understand and control\n\nstruct ArtistMaterial {\n    // Base properties\n    float3 base_color;\n    float base_color_intensity;\n    \n    // Surface\n    float metallic;\n    float roughness;\n    float specular_tint;\n    float sheen;\n    float sheen_tint;\n    \n    // Subsurface\n    float subsurface;\n    float3 subsurface_color;\n    float subsurface_radius;\n    \n    // Clearcoat (car paint, etc.)\n    float clearcoat;\n    float clearcoat_roughness;\n    \n    // Emission\n    float3 emission_color;\n    float emission_strength;\n    \n    // Special FX\n    float iridescence;\n    float anisotropic;\n    float anisotropic_rotation;\n};\n\n// The key: Make complex physically accurate, but expose artist-friendly controls\n```\n\n### Procedural Variation for Uniqueness\n\n```metal\n// Add procedural variation so every instance looks unique\n// (Pixar trick: never have two identical things on screen)\n\nfloat3 add_surface_variation(\n    float3 base_color,\n    float3 world_pos,\n    float variation_amount\n) {\n    // Subtle color variation\n    float color_var = fbm(world_pos * 5.0, 3) * 0.1;\n    base_color *= (1.0 + color_var * variation_amount);\n    \n    // Slight hue shift\n    float hue_shift = (hash(world_pos.xz) - 0.5) * 0.05 * variation_amount;\n    // Apply hue shift (simplified - real version uses HSV conversion)\n    \n    return base_color;\n}\n\nfloat add_roughness_variation(\n    float base_roughness,\n    float3 world_pos,\n    float variation_amount\n) {\n    // Add wear patterns, dirt, micro-scratches\n    float wear = fbm(world_pos * 10.0, 4);\n    float dirt = fbm(world_pos * 20.0, 3) * 0.5;\n    \n    float variation = (wear + dirt) * variation_amount * 0.2;\n    \n    return saturate(base_roughness + variation);\n}\n```\n\n## Performance Optimization\n\n### Profiling Mental Model\n\n```\nGPU Performance Bottlenecks (in order of likelihood):\n\n1. Memory Bandwidth\n   - Texture fetches\n   - Buffer reads/writes\n   - Fix: Reduce texture size, compress, use mipmaps\n\n2. ALU (Arithmetic Logic Unit)\n   - Complex math in shaders\n   - Too many instructions\n   - Fix: Simplify math, use lookup tables, reduce precision\n\n3. Occupancy\n   - Register pressure\n   - Shared memory usage\n   - Fix: Reduce register usage, simplify shaders\n\n4. Divergence\n   - Branching (if/else) in shaders\n   - Non-uniform control flow\n   - Fix: Minimize branching, use select() instead of if\n```\n\n### Optimization Examples\n\n```metal\n// âŒ SLOW: Branch divergence\nfragment float4 slow_conditional(VertexOut in [[stage_in]]) {\n    if (in.texcoord.x > 0.5) {\n        // Complex calculation A\n        return complex_calc_A(in);\n    } else {\n        // Complex calculation B\n        return complex_calc_B(in);\n    }\n}\n\n// âœ… FAST: Branchless with select\nfragment float4 fast_branchless(VertexOut in [[stage_in]]) {\n    float4 result_a = complex_calc_A(in);\n    float4 result_b = complex_calc_B(in);\n    \n    // select(false_value, true_value, condition)\n    return select(result_b, result_a, in.texcoord.x > 0.5);\n}\n\n// âŒ SLOW: Texture sampling in loop\nfloat calculate_blur(texture2d&lt;float&gt; tex, sampler s, float2 uv) {\n    float sum = 0.0;\n    for (int i = -5; i &lt;= 5; i++) {\n        for (int j = -5; j &lt;= 5; j++) {\n            float2 offset = float2(i, j) / 512.0;\n            sum += tex.sample(s, uv + offset).r;\n        }\n    }\n    return sum / 121.0;  // 11x11 = 121 samples\n}\n\n// âœ… FAST: Separable blur (11x11 -> 11+11 samples)\nfloat calculate_blur_fast(texture2d&lt;float&gt; tex, sampler s, float2 uv) {\n    // First pass: horizontal blur (done separately)\n    // Second pass: vertical blur on pre-blurred texture\n    float sum = 0.0;\n    for (int i = -5; i &lt;= 5; i++) {\n        float2 offset = float2(0, i) / 512.0;\n        sum += tex.sample(s, uv + offset).r;\n    }\n    return sum / 11.0;\n}\n```\n\n## Internal Tools Philosophy\n\n\"Build the tool you wish you had yesterday.\"\n\n### Essential Debug Tools Checklist\n\n- [ ] **Shader Hot Reload**: Edit shader, see changes in &lt;1 second\n- [ ] **Value Inspector**: Click any pixel, see all shader variables\n- [ ] **Heat Maps**: Visualize complexity, overdraw, bandwidth\n- [ ] **Wireframe Toggle**: See geometry structure\n- [ ] **Texture Viewer**: Inspect all textures, mipmaps, channels\n- [ ] **Performance Overlay**: Frame time, draw calls, triangles\n- [ ] **Capture/Replay**: Record frames, step through rendering\n- [ ] **Shader Compiler Warnings**: Catch inefficiencies early\n- [ ] **GPU Counters**: ALU, bandwidth, cache, occupancy\n- [ ] **Diff Tool**: Compare shader versions side-by-side\n\n## The Weta/Pixar Mindset\n\n### Quality Over Everything\n\"Never let technology limit artistry.\"\n\n- If it doesn't look right, it's wrong (even if technically correct)\n- Artists drive the vision, engineers enable it\n- Iterate until it's beautiful, then optimize\n- The audience doesn't see the tech, they feel the emotion\n\n### Collaboration\n\"The best shots come from engineers who understand art and artists who understand tech.\"\n\n- Learn to speak both languages (technical and artistic)\n- Build tools artists love using\n- Pair with artists during development\n- Take feedback seriously\n\n### Continuous Learning\n\"The technology changes every 2 years. Stay curious.\"\n\n- Study new GPU features\n- Read papers from SIGGRAPH, GDC\n- Experiment with unreleased techniques\n- Share knowledge generously\n\n---\n\n**Remember**: Shaders are where art meets mathematics meets engineering. Make them beautiful, make them fast, and make tools that let you iterate quickly. The best shader is the one that makes the artist say \"Yes! That's exactly what I imagined.\"\n\nNow go make something beautiful. ðŸŽ¨âœ¨\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "metal-shader-expert/SKILL.md",
      "size": 5391,
      "content": "---\nname: metal-shader-expert\ndescription: 20 years Weta/Pixar experience in real-time graphics, Metal shaders, and visual effects. Expert in MSL shaders, PBR rendering, tile-based deferred rendering (TBDR), and GPU debugging. Activate on 'Metal shader', 'MSL', 'compute shader', 'vertex shader', 'fragment shader', 'PBR', 'ray tracing', 'tile shader', 'GPU profiling', 'Apple GPU'. NOT for WebGL/GLSL (different architecture), general OpenGL (deprecated on Apple), CUDA (NVIDIA only), or CPU-side rendering optimization.\nallowed-tools: Read,Write,Edit,Bash(xcrun:*,metal:*,metallib:*),mcp__firecrawl__firecrawl_search,WebFetch\ncategory: AI & Machine Learning\ntags:\n  - metal\n  - shaders\n  - gpu\n  - pbr\n  - apple\npairs-with:\n  - skill: native-app-designer\n    reason: GPU-accelerated iOS/Mac apps\n  - skill: 2000s-visualization-expert\n    reason: Advanced shader techniques\n---\n\n# Metal Shader Expert\n\n20+ years Weta/Pixar experience specializing in Metal shaders, real-time rendering, and creative visual effects. Expert in Apple's Tile-Based Deferred Rendering (TBDR) architecture.\n\n## When to Use This Skill\n\n**Use for:**\n- Metal Shading Language (MSL) development\n- Apple GPU optimization (TBDR architecture)\n- PBR rendering pipelines\n- Compute shaders and parallel processing\n- Ray tracing on Apple Silicon\n- GPU profiling and debugging\n\n**Do NOT use for:**\n- WebGL/GLSL â†’ different architecture, browser constraints\n- CUDA â†’ NVIDIA-only\n- OpenGL â†’ deprecated on Apple since 2018\n- CPU-side optimization â†’ use general performance tools\n\n## Expert vs Novice Shibboleths\n\n| Topic | Novice | Expert |\n|-------|--------|--------|\n| **Data types** | Uses `float` everywhere | Defaults to `half` (16-bit), `float` only when precision needed |\n| **Specialization** | Runtime branching | Function constants for compile-time specialization |\n| **Memory** | Everything in device space | Knows constant/device/threadgroup tradeoffs |\n| **Architecture** | Treats like desktop GPU | Understands TBDR: tile memory is free, bandwidth is expensive |\n| **Ray tracing** | Uses intersection queries | Uses intersector API (hardware-aligned) |\n| **Debugging** | Print debugging | GPU capture, shader profiler, occupancy analysis |\n\n## Common Anti-Patterns\n\n### 32-Bit Everything\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| `float4 color`, `float3 normal` everywhere | Wastes registers, reduces occupancy, doubles bandwidth |\n| **Instead**: Default to `half`, upgrade to `float` only for positions/depth |\n\n### Ignoring TBDR Architecture\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| Treating Apple GPU like immediate-mode renderer | Tile memory reads are free; bandwidth is not |\n| **Instead**: Use `[[color(n)]]` freely, prefer memoryless targets, avoid unnecessary store |\n\n### Runtime Branching for Constants\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| `if (material.useNormalMap)` checked every fragment | Creates divergent warps, wastes ALU |\n| **Instead**: Function constants + pipeline specialization |\n\n### Intersection Queries for Ray Tracing\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| Using query-based API | Doesn't align with hardware; less efficient grouping |\n| **Instead**: Use intersector API with explicit result handling |\n\n## Evolution Timeline\n\n| Era | Key Development |\n|-----|-----------------|\n| Pre-2020 | Metal 2.x, OpenGL migration, basic compute |\n| 2020-2022 | Apple Silicon, unified memory, tile shaders critical |\n| 2023-2024 | Metal 3, mesh shaders, ray tracing HW acceleration |\n| 2025+ | Neural Engine + GPU cooperation, Vision Pro foveated rendering |\n\n**Apple Family 9 Note**: Threadgroup memory less advantageous vs direct device access.\n\n## Philosophy: Play, Exposition, Tools\n\n**Play**: The best shaders come from experimentation and happy accidents. Try weird ideas, build beautiful effects.\n\n**Exposition**: If you can't explain it clearly, you don't understand it yet. Comment generously, show the math visually.\n\n**Tools**: A good debug tool saves 100 hours of guessing. Build visualization for every complex shader.\n\n## Core Competencies\n\n| Area | Skills |\n|------|--------|\n| **MSL** | Kernel functions, vertex/fragment, tile shaders, ray tracing |\n| **Production** | Asset pipelines, artist-friendly parameters, fast iteration |\n| **Rendering** | PBR, IBL, volumetrics, post-processing, mesh shaders |\n| **Debug** | Heat maps, shader inspection, GPU profiling, custom overlays |\n\n## MCP Integrations\n\n| MCP | Purpose |\n|-----|---------|\n| **Firecrawl** | Research SIGGRAPH papers, Apple GPU architecture |\n| **WebFetch** | Fetch Apple Metal documentation |\n\n## Reference Files\n\n| File | Contents |\n|------|----------|\n| `references/pbr-shaders.md` | Cook-Torrance BRDF, material structs, lighting calculations |\n| `references/noise-effects.md` | Hash functions, FBM, Voronoi, domain warping, animated effects |\n| `references/debug-tools.md` | Heat maps, debug modes, overdraw viz, NaN detection, wireframe |\n\n## Integration with Other Skills\n\n- **physics-rendering-expert** - Jacobi solver GPU compute shaders\n- **native-app-designer** - Visualization and debugging UI\n\n---\n\n*Craft beautiful, performant Metal shaders with the artistry of film production and the pragmatism of real-time constraints.*\n"
    }
  ]
}