{
  "name": "recovery-social-features",
  "type": "folder",
  "path": "recovery-social-features",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "recovery-social-features/references",
      "children": [
        {
          "name": "accountability.md",
          "type": "file",
          "path": "recovery-social-features/references/accountability.md",
          "size": 4236,
          "content": "# Accountability Features\n\nPatterns for sharing recovery progress with trusted connections.\n\n## Share Check-In Component\n\n```tsx\n// components/ShareCheckIn.tsx\n'use client';\n\nimport { useState } from 'react';\nimport type { DailyCheckIn } from '@/lib/types';\n\ninterface Props {\n  checkIn: DailyCheckIn;\n  sponsors: { id: string; displayName: string }[];\n}\n\nexport function ShareCheckIn({ checkIn, sponsors }: Props) {\n  const [selectedSponsors, setSelectedSponsors] = useState<string[]>([]);\n  const [shared, setShared] = useState(false);\n\n  const handleShare = async () => {\n    // Share check-in summary with selected sponsors\n    for (const sponsorId of selectedSponsors) {\n      await sendCheckInToSponsor(sponsorId, {\n        date: checkIn.date,\n        mood: checkIn.mood,\n        halt: checkIn.halt, // Hungry, Angry, Lonely, Tired\n        gratitude: checkIn.gratitude,\n      });\n    }\n    setShared(true);\n  };\n\n  if (shared) {\n    return (\n      <p className=\"text-green-400\">Shared with your sponsor(s)!</p>\n    );\n  }\n\n  return (\n    <div className=\"space-y-3\">\n      <p className=\"text-sm text-leather-400\">\n        Share today's check-in with:\n      </p>\n\n      {sponsors.map((sponsor) => (\n        <label key={sponsor.id} className=\"flex items-center gap-3\">\n          <input\n            type=\"checkbox\"\n            checked={selectedSponsors.includes(sponsor.id)}\n            onChange={(e) => {\n              if (e.target.checked) {\n                setSelectedSponsors([...selectedSponsors, sponsor.id]);\n              } else {\n                setSelectedSponsors(selectedSponsors.filter((id) => id !== sponsor.id));\n              }\n            }}\n            className=\"w-5 h-5\"\n          />\n          <span>{sponsor.displayName}</span>\n        </label>\n      ))}\n\n      <button\n        onClick={handleShare}\n        disabled={selectedSponsors.length === 0}\n        className=\"w-full py-3 bg-ember-500 rounded disabled:opacity-50\"\n      >\n        Share Check-In\n      </button>\n    </div>\n  );\n}\n```\n\n## Sobriety Visibility Settings\n\n```tsx\n// components/SobrietyVisibility.tsx\n'use client';\n\nimport { useState } from 'react';\n\ntype Visibility = 'private' | 'sponsors' | 'friends' | 'community';\n\ninterface Props {\n  currentVisibility: Visibility;\n  onUpdate: (visibility: Visibility) => void;\n}\n\nconst OPTIONS: { value: Visibility; label: string; description: string }[] = [\n  {\n    value: 'private',\n    label: 'Just Me',\n    description: 'Only you can see your sobriety date',\n  },\n  {\n    value: 'sponsors',\n    label: 'Sponsors Only',\n    description: 'Your sponsors can see your progress',\n  },\n  {\n    value: 'friends',\n    label: 'Friends',\n    description: 'Friends and sponsors can see',\n  },\n  {\n    value: 'community',\n    label: 'Community',\n    description: 'Anyone in the app can see',\n  },\n];\n\nexport function SobrietyVisibility({ currentVisibility, onUpdate }: Props) {\n  return (\n    <div className=\"space-y-2\">\n      <label className=\"block text-sm text-leather-400 mb-2\">\n        Who can see your sobriety date?\n      </label>\n\n      {OPTIONS.map((option) => (\n        <button\n          key={option.value}\n          onClick={() => onUpdate(option.value)}\n          className={`\n            w-full p-3 rounded text-left\n            ${currentVisibility === option.value\n              ? 'bg-ember-500/20 border border-ember-500'\n              : 'bg-leather-800'\n            }\n          `}\n        >\n          <span className=\"font-medium\">{option.label}</span>\n          <span className=\"block text-sm text-leather-400\">\n            {option.description}\n          </span>\n        </button>\n      ))}\n    </div>\n  );\n}\n```\n\n## Visibility Levels\n\n| Level | Who Can See | Use Case |\n|-------|-------------|----------|\n| `private` | Only self | Maximum privacy |\n| `sponsors` | Self + sponsors | Accountability focus |\n| `friends` | Self + sponsors + friends | Peer support |\n| `community` | All app users | Public milestone celebrations |\n\n## HALT Check-In Data\n\n```typescript\ninterface DailyCheckIn {\n  date: string;\n  mood: 1 | 2 | 3 | 4 | 5;  // 1=worst, 5=best\n  halt: {\n    hungry: boolean;\n    angry: boolean;\n    lonely: boolean;\n    tired: boolean;\n  };\n  gratitude?: string;\n  notes?: string;\n}\n```\n"
        },
        {
          "name": "friendships.md",
          "type": "file",
          "path": "recovery-social-features/references/friendships.md",
          "size": 5337,
          "content": "# Friend Connections\n\nPeer-to-peer connections with mutual consent and real-time updates.\n\n## useFriendships Hook\n\n```tsx\n// hooks/useFriendships.ts\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { supabase } from '@/lib/supabase';\n\ninterface Friendship {\n  id: string;\n  status: 'pending' | 'accepted' | 'blocked';\n  isRequester: boolean;\n  profile: {\n    id: string;\n    displayName: string;\n    avatarIcon?: string;\n  };\n  createdAt: string;\n}\n\nexport function useFriendships() {\n  const [friends, setFriends] = useState<Friendship[]>([]);\n  const [pendingReceived, setPendingReceived] = useState<Friendship[]>([]);\n  const [pendingSent, setPendingSent] = useState<Friendship[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    loadFriendships();\n\n    // Subscribe to real-time updates\n    const subscription = supabase\n      .channel('friendships')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'friendships' },\n        () => loadFriendships()\n      )\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  const loadFriendships = async () => {\n    const userId = (await supabase.auth.getUser()).data.user?.id;\n    if (!userId) return;\n\n    const { data } = await supabase\n      .from('friendships')\n      .select(`\n        id,\n        status,\n        requester_id,\n        addressee_id,\n        created_at,\n        requester:profiles!requester_id(id, display_name, avatar_icon),\n        addressee:profiles!addressee_id(id, display_name, avatar_icon)\n      `)\n      .or(`requester_id.eq.${userId},addressee_id.eq.${userId}`);\n\n    if (!data) return;\n\n    const mapped = data.map((f) => {\n      const isRequester = f.requester_id === userId;\n      const otherProfile = isRequester ? f.addressee : f.requester;\n\n      return {\n        id: f.id,\n        status: f.status,\n        isRequester,\n        profile: {\n          id: otherProfile.id,\n          displayName: otherProfile.display_name,\n          avatarIcon: otherProfile.avatar_icon,\n        },\n        createdAt: f.created_at,\n      };\n    });\n\n    setFriends(mapped.filter((f) => f.status === 'accepted'));\n    setPendingReceived(mapped.filter((f) => f.status === 'pending' && !f.isRequester));\n    setPendingSent(mapped.filter((f) => f.status === 'pending' && f.isRequester));\n    setIsLoading(false);\n  };\n\n  const sendRequest = async (targetUserId: string) => {\n    await supabase.from('friendships').insert({\n      requester_id: (await supabase.auth.getUser()).data.user?.id,\n      addressee_id: targetUserId,\n      status: 'pending',\n    });\n  };\n\n  const acceptRequest = async (friendshipId: string) => {\n    await supabase\n      .from('friendships')\n      .update({ status: 'accepted' })\n      .eq('id', friendshipId);\n  };\n\n  const rejectRequest = async (friendshipId: string) => {\n    await supabase.from('friendships').delete().eq('id', friendshipId);\n  };\n\n  const removeFriend = async (friendshipId: string) => {\n    await supabase.from('friendships').delete().eq('id', friendshipId);\n  };\n\n  return {\n    friends,\n    pendingReceived,\n    pendingSent,\n    isLoading,\n    sendRequest,\n    acceptRequest,\n    rejectRequest,\n    removeFriend,\n  };\n}\n```\n\n## Friend Request Button\n\n```tsx\n// components/FriendRequest.tsx\n'use client';\n\nimport { useFriendships } from '@/hooks/useFriendships';\n\ninterface Props {\n  userId: string;\n  displayName: string;\n}\n\nexport function FriendRequestButton({ userId, displayName }: Props) {\n  const { friends, pendingSent, sendRequest } = useFriendships();\n\n  const isFriend = friends.some((f) => f.profile.id === userId);\n  const isPending = pendingSent.some((f) => f.profile.id === userId);\n\n  if (isFriend) {\n    return (\n      <span className=\"px-3 py-1 bg-green-900/30 text-green-400 rounded text-sm\">\n        Friends\n      </span>\n    );\n  }\n\n  if (isPending) {\n    return (\n      <span className=\"px-3 py-1 bg-leather-700 text-leather-400 rounded text-sm\">\n        Request Sent\n      </span>\n    );\n  }\n\n  return (\n    <button\n      onClick={() => sendRequest(userId)}\n      className=\"px-3 py-1 bg-ember-500 rounded text-sm min-h-[44px]\"\n    >\n      Add Friend\n    </button>\n  );\n}\n```\n\n## Pending Friend Requests Component\n\n```tsx\nexport function PendingFriendRequests() {\n  const { pendingReceived, acceptRequest, rejectRequest } = useFriendships();\n\n  if (pendingReceived.length === 0) return null;\n\n  return (\n    <div className=\"p-4 bg-leather-800 rounded-lg\">\n      <h3 className=\"font-semibold mb-3\">Friend Requests</h3>\n      <ul className=\"space-y-3\">\n        {pendingReceived.map((request) => (\n          <li key={request.id} className=\"flex items-center justify-between\">\n            <span>{request.profile.displayName}</span>\n            <div className=\"flex gap-2\">\n              <button\n                onClick={() => acceptRequest(request.id)}\n                className=\"px-3 py-2 bg-green-600 rounded min-h-[44px]\"\n              >\n                Accept\n              </button>\n              <button\n                onClick={() => rejectRequest(request.id)}\n                className=\"px-3 py-2 bg-leather-700 rounded min-h-[44px]\"\n              >\n                Decline\n              </button>\n            </div>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n"
        },
        {
          "name": "groups.md",
          "type": "file",
          "path": "recovery-social-features/references/groups.md",
          "size": 4176,
          "content": "# Meeting-Based Groups\n\nImplementation patterns for ephemeral and permanent meeting groups.\n\n## useMeetingGroup Hook\n\n```tsx\n// hooks/useMeetingGroup.ts\n'use client';\n\nimport { useState } from 'react';\nimport { supabase } from '@/lib/supabase';\n\ninterface GroupSettings {\n  name: string;\n  meetingId?: string;\n  visibility: 'public' | 'private' | 'invite';\n  ephemeral: boolean;  // Auto-delete after 24h\n  maxMembers: number;\n}\n\nexport function useMeetingGroup() {\n  const [isLoading, setIsLoading] = useState(false);\n\n  const createGroup = async (settings: GroupSettings) => {\n    setIsLoading(true);\n    try {\n      const { data, error } = await supabase\n        .from('groups')\n        .insert({\n          name: settings.name,\n          meeting_id: settings.meetingId,\n          visibility: settings.visibility,\n          max_members: settings.maxMembers,\n          expires_at: settings.ephemeral\n            ? new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n            : null,\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      // Auto-join creator as owner\n      await supabase.from('group_members').insert({\n        group_id: data.id,\n        user_id: (await supabase.auth.getUser()).data.user?.id,\n        role: 'owner',\n      });\n\n      return data;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const joinGroup = async (groupId: string) => {\n    const { error } = await supabase.from('group_members').insert({\n      group_id: groupId,\n      user_id: (await supabase.auth.getUser()).data.user?.id,\n      role: 'member',\n    });\n\n    if (error) {\n      if (error.message.includes('duplicate')) {\n        return; // Already a member\n      }\n      throw error;\n    }\n  };\n\n  const leaveGroup = async (groupId: string) => {\n    const userId = (await supabase.auth.getUser()).data.user?.id;\n    await supabase\n      .from('group_members')\n      .delete()\n      .eq('group_id', groupId)\n      .eq('user_id', userId);\n  };\n\n  return { createGroup, joinGroup, leaveGroup, isLoading };\n}\n```\n\n## Quick Meeting Group Component\n\nOne-tap group creation when attending a meeting.\n\n```tsx\n// components/QuickMeetingGroup.tsx\n'use client';\n\nimport { useState } from 'react';\nimport { useMeetingGroup } from '@/hooks/useMeetingGroup';\nimport type { Meeting } from '@/lib/meetings/types';\n\ninterface Props {\n  meeting: Meeting;\n}\n\nexport function QuickMeetingGroup({ meeting }: Props) {\n  const { createGroup, isLoading } = useMeetingGroup();\n  const [groupCreated, setGroupCreated] = useState(false);\n  const [inviteCode, setInviteCode] = useState('');\n\n  const handleCreate = async () => {\n    const group = await createGroup({\n      name: `${meeting.name} Group`,\n      meetingId: meeting.id,\n      visibility: 'invite',\n      ephemeral: true,\n      maxMembers: 20,\n    });\n\n    setInviteCode(group.invite_code);\n    setGroupCreated(true);\n  };\n\n  if (groupCreated) {\n    return (\n      <div className=\"p-4 bg-leather-800 rounded-lg\">\n        <p className=\"text-sm text-leather-400 mb-2\">\n          Group created! Share this code with others at the meeting:\n        </p>\n        <code className=\"block px-4 py-3 bg-leather-900 rounded text-center text-xl\">\n          {inviteCode}\n        </code>\n        <p className=\"text-xs text-leather-500 mt-2 text-center\">\n          This group expires in 24 hours\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <button\n      onClick={handleCreate}\n      disabled={isLoading}\n      className=\"flex items-center gap-2 px-4 py-2 bg-leather-700 rounded\"\n    >\n      <UsersIcon className=\"w-5 h-5\" />\n      <span>Start Group Chat</span>\n    </button>\n  );\n}\n```\n\n## Group Settings\n\n```typescript\ninterface GroupSettings {\n  name: string;\n  meetingId?: string;           // Link to meeting\n  visibility: 'public' | 'private' | 'invite';\n  ephemeral: boolean;           // Auto-delete after 24h\n  maxMembers: number;           // Member limit\n}\n```\n\n## Group Visibility Options\n\n| Visibility | Who Can See | Who Can Join |\n|------------|-------------|--------------|\n| `public` | Anyone | Anyone |\n| `private` | Members only | Invite only |\n| `invite` | Members only | Has invite code |\n"
        },
        {
          "name": "messaging.md",
          "type": "file",
          "path": "recovery-social-features/references/messaging.md",
          "size": 5725,
          "content": "# Safe Messaging\n\nRecovery-appropriate messaging with crisis detection and safety features.\n\n## useMessages Hook\n\n```tsx\n// hooks/useMessages.ts\n'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase } from '@/lib/supabase';\n\ninterface Message {\n  id: string;\n  senderId: string;\n  senderName: string;\n  content: string;\n  createdAt: string;\n  isOwn: boolean;\n}\n\nexport function useMessages(conversationId: string) {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  const loadMessages = useCallback(async () => {\n    const userId = (await supabase.auth.getUser()).data.user?.id;\n\n    const { data } = await supabase\n      .from('messages')\n      .select(`\n        id,\n        content,\n        created_at,\n        sender_id,\n        sender:profiles!sender_id(display_name)\n      `)\n      .eq('conversation_id', conversationId)\n      .is('deleted_at', null)\n      .order('created_at', { ascending: true });\n\n    if (data) {\n      setMessages(data.map((m) => ({\n        id: m.id,\n        senderId: m.sender_id,\n        senderName: m.sender.display_name,\n        content: m.content,\n        createdAt: m.created_at,\n        isOwn: m.sender_id === userId,\n      })));\n    }\n    setIsLoading(false);\n  }, [conversationId]);\n\n  useEffect(() => {\n    loadMessages();\n\n    // Real-time subscription\n    const subscription = supabase\n      .channel(`messages:${conversationId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'messages',\n          filter: `conversation_id=eq.${conversationId}`,\n        },\n        async (payload) => {\n          const userId = (await supabase.auth.getUser()).data.user?.id;\n          const { data: sender } = await supabase\n            .from('profiles')\n            .select('display_name')\n            .eq('id', payload.new.sender_id)\n            .single();\n\n          setMessages((prev) => [\n            ...prev,\n            {\n              id: payload.new.id,\n              senderId: payload.new.sender_id,\n              senderName: sender?.display_name || 'Unknown',\n              content: payload.new.content,\n              createdAt: payload.new.created_at,\n              isOwn: payload.new.sender_id === userId,\n            },\n          ]);\n        }\n      )\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [conversationId, loadMessages]);\n\n  const sendMessage = async (content: string) => {\n    const userId = (await supabase.auth.getUser()).data.user?.id;\n\n    await supabase.from('messages').insert({\n      conversation_id: conversationId,\n      sender_id: userId,\n      content,\n    });\n  };\n\n  return { messages, sendMessage, isLoading };\n}\n```\n\n## Message Input with Crisis Detection\n\n```tsx\n// components/MessageInput.tsx\n'use client';\n\nimport { useState, useRef } from 'react';\n\ninterface Props {\n  onSend: (content: string) => void;\n  placeholder?: string;\n}\n\n// Crisis keywords that should show resources\nconst CRISIS_KEYWORDS = [\n  'suicide', 'kill myself', 'want to die', 'end it all',\n  'relapse', 'using again', 'fell off the wagon',\n];\n\nexport function MessageInput({ onSend, placeholder = \"Type a message...\" }: Props) {\n  const [value, setValue] = useState('');\n  const [showCrisisPrompt, setShowCrisisPrompt] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const checkForCrisisKeywords = (text: string) => {\n    const lower = text.toLowerCase();\n    return CRISIS_KEYWORDS.some((kw) => lower.includes(kw));\n  };\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value;\n    setValue(newValue);\n\n    // Show crisis resources if needed\n    if (checkForCrisisKeywords(newValue)) {\n      setShowCrisisPrompt(true);\n    }\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (value.trim()) {\n      onSend(value.trim());\n      setValue('');\n      setShowCrisisPrompt(false);\n    }\n  };\n\n  return (\n    <div>\n      {showCrisisPrompt && (\n        <div className=\"mb-2 p-3 bg-red-900/30 border border-red-700 rounded-lg\">\n          <p className=\"text-sm text-red-300 mb-2\">\n            It sounds like you might be going through a hard time.\n          </p>\n          <a\n            href=\"/crisis\"\n            className=\"text-sm text-red-400 underline\"\n          >\n            Tap here for crisis resources →\n          </a>\n        </div>\n      )}\n\n      <form onSubmit={handleSubmit} className=\"flex gap-2\">\n        <input\n          ref={inputRef}\n          type=\"text\"\n          value={value}\n          onChange={handleChange}\n          placeholder={placeholder}\n          className=\"flex-1 px-4 py-3 bg-leather-800 rounded\"\n        />\n        <button\n          type=\"submit\"\n          disabled={!value.trim()}\n          className=\"px-4 py-3 bg-ember-500 rounded min-h-[44px] disabled:opacity-50\"\n        >\n          Send\n        </button>\n      </form>\n    </div>\n  );\n}\n```\n\n## Crisis Keywords List\n\nKeywords that trigger crisis resource prompts:\n\n```typescript\nconst CRISIS_KEYWORDS = [\n  // Suicidal ideation\n  'suicide', 'kill myself', 'want to die', 'end it all',\n  // Relapse indicators\n  'relapse', 'using again', 'fell off the wagon',\n  // Self-harm\n  'hurt myself', 'cutting', 'self-harm',\n];\n```\n\n## Best Practices\n\n1. **Non-blocking** - Crisis prompts suggest resources, don't block messages\n2. **Privacy-first** - Don't log or report crisis keywords automatically\n3. **Helpful tone** - Gentle, non-judgmental language\n4. **Direct resources** - Link to crisis page, not external sites\n5. **Offline capable** - Cache crisis resources for offline access\n"
        },
        {
          "name": "moderation.md",
          "type": "file",
          "path": "recovery-social-features/references/moderation.md",
          "size": 3069,
          "content": "# Safety & Moderation\n\nContent moderation and user blocking patterns for recovery apps.\n\n## Content Moderation Hook\n\n```tsx\n// hooks/useContentModeration.ts\n'use client';\n\ninterface ModerationResult {\n  approved: boolean;\n  flags: string[];\n  crisisDetected: boolean;\n}\n\nexport function useContentModeration() {\n  const checkContent = async (content: string): Promise<ModerationResult> => {\n    const response = await fetch(\n      'https://your-moderation-worker.workers.dev',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ content }),\n      }\n    );\n\n    return response.json();\n  };\n\n  return { checkContent };\n}\n```\n\n## User Blocking Hook\n\n```tsx\n// hooks/useBlocking.ts\n'use client';\n\nimport { supabase } from '@/lib/supabase';\n\nexport function useBlocking() {\n  const blockUser = async (userId: string) => {\n    const currentUser = (await supabase.auth.getUser()).data.user?.id;\n\n    // Create or update friendship to blocked\n    await supabase\n      .from('friendships')\n      .upsert({\n        requester_id: currentUser,\n        addressee_id: userId,\n        status: 'blocked',\n      });\n  };\n\n  const unblockUser = async (userId: string) => {\n    const currentUser = (await supabase.auth.getUser()).data.user?.id;\n\n    await supabase\n      .from('friendships')\n      .delete()\n      .eq('requester_id', currentUser)\n      .eq('addressee_id', userId)\n      .eq('status', 'blocked');\n  };\n\n  const isBlocked = async (userId: string): Promise<boolean> => {\n    const currentUser = (await supabase.auth.getUser()).data.user?.id;\n\n    const { data } = await supabase\n      .from('friendships')\n      .select('id')\n      .or(`\n        and(requester_id.eq.${currentUser},addressee_id.eq.${userId},status.eq.blocked),\n        and(requester_id.eq.${userId},addressee_id.eq.${currentUser},status.eq.blocked)\n      `)\n      .limit(1);\n\n    return (data?.length ?? 0) > 0;\n  };\n\n  return { blockUser, unblockUser, isBlocked };\n}\n```\n\n## Moderation Categories\n\n| Category | Description | Action |\n|----------|-------------|--------|\n| `crisis` | Suicidal ideation, self-harm | Show resources, don't block |\n| `sourcing` | Drug seeking, dealing | Block + flag for review |\n| `harassment` | Personal attacks, threats | Block + flag for review |\n| `spam` | Promotional content | Block |\n| `explicit` | Sexual/graphic content | Block |\n\n## Blocking Behavior\n\nWhen a user blocks another:\n- Blocked user cannot send messages\n- Blocked user cannot see blocker's profile\n- Blocked user cannot see blocker in groups\n- Existing messages are hidden (not deleted)\n- Blocking is one-way (blocked user doesn't know)\n\n## RLS Policy for Blocks\n\n```sql\n-- Hide content from blocked users\nCREATE POLICY \"Hide messages from blocked users\" ON messages\n  FOR SELECT USING (\n    NOT EXISTS (\n      SELECT 1 FROM friendships\n      WHERE status = 'blocked'\n      AND (\n        (requester_id = auth.uid() AND addressee_id = sender_id)\n        OR (addressee_id = auth.uid() AND requester_id = sender_id)\n      )\n    )\n  );\n```\n"
        },
        {
          "name": "sponsor-sponsee.md",
          "type": "file",
          "path": "recovery-social-features/references/sponsor-sponsee.md",
          "size": 6479,
          "content": "# Sponsor/Sponsee Implementation\n\nFull implementation patterns for invite-based sponsor relationships.\n\n## useSponsorInvite Hook\n\n```tsx\n// hooks/useSponsorInvite.ts\n'use client';\n\nimport { useState } from 'react';\nimport { supabase } from '@/lib/supabase';\n\ninterface SponsorInvite {\n  code: string;\n  expiresAt: Date;\n  program: string;\n}\n\nexport function useSponsorInvite() {\n  const [invite, setInvite] = useState<SponsorInvite | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Sponsor generates invite code\n  const createInvite = async (program: string): Promise<string> => {\n    setIsLoading(true);\n    try {\n      const { data, error } = await supabase.rpc('create_sponsor_invite', {\n        program_type: program,\n      });\n\n      if (error) throw error;\n\n      setInvite({\n        code: data.code,\n        expiresAt: new Date(data.expires_at),\n        program,\n      });\n\n      return data.code;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Sponsee accepts invite\n  const acceptInvite = async (code: string): Promise<boolean> => {\n    setIsLoading(true);\n    try {\n      const { data, error } = await supabase.rpc('accept_sponsor_invite', {\n        invite_code: code,\n      });\n\n      if (error) {\n        if (error.message.includes('expired')) {\n          throw new Error('This invite has expired. Ask your sponsor for a new one.');\n        }\n        if (error.message.includes('Invalid')) {\n          throw new Error('Invalid invite code. Please check and try again.');\n        }\n        throw error;\n      }\n\n      return true;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return { invite, createInvite, acceptInvite, isLoading };\n}\n```\n\n## Generate Sponsor Invite Component\n\n```tsx\n// components/SponsorInvite.tsx\n'use client';\n\nimport { useState } from 'react';\nimport { useSponsorInvite } from '@/hooks/useSponsorInvite';\n\nexport function GenerateSponsorInvite({ program }: { program: string }) {\n  const { invite, createInvite, isLoading } = useSponsorInvite();\n  const [copied, setCopied] = useState(false);\n\n  const handleCreate = async () => {\n    await createInvite(program);\n  };\n\n  const copyCode = async () => {\n    if (invite) {\n      await navigator.clipboard.writeText(invite.code);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    }\n  };\n\n  if (invite) {\n    return (\n      <div className=\"p-4 bg-leather-800 rounded-lg\">\n        <p className=\"text-sm text-leather-400 mb-2\">\n          Share this code with your sponsee:\n        </p>\n        <div className=\"flex items-center gap-2\">\n          <code className=\"flex-1 px-4 py-3 bg-leather-900 rounded text-xl font-mono tracking-wider\">\n            {invite.code}\n          </code>\n          <button\n            onClick={copyCode}\n            className=\"px-4 py-3 bg-ember-500 rounded min-h-[44px]\"\n          >\n            {copied ? 'Copied!' : 'Copy'}\n          </button>\n        </div>\n        <p className=\"text-xs text-leather-500 mt-2\">\n          Expires in 24 hours\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <button\n      onClick={handleCreate}\n      disabled={isLoading}\n      className=\"w-full py-3 bg-ember-500 rounded min-h-[44px]\"\n    >\n      {isLoading ? 'Generating...' : 'Generate Sponsee Invite'}\n    </button>\n  );\n}\n```\n\n## Accept Sponsor Invite Component\n\n```tsx\nexport function AcceptSponsorInvite() {\n  const { acceptInvite, isLoading } = useSponsorInvite();\n  const [code, setCode] = useState('');\n  const [error, setError] = useState('');\n  const [success, setSuccess] = useState(false);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError('');\n\n    try {\n      await acceptInvite(code.toUpperCase().trim());\n      setSuccess(true);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to accept invite');\n    }\n  };\n\n  if (success) {\n    return (\n      <div className=\"p-4 bg-green-900/30 border border-green-700 rounded-lg\">\n        <p className=\"text-green-400\">Connected with your sponsor!</p>\n      </div>\n    );\n  }\n\n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\n      <div>\n        <label className=\"block text-sm text-leather-400 mb-1\">\n          Enter invite code from your sponsor\n        </label>\n        <input\n          type=\"text\"\n          value={code}\n          onChange={(e) => setCode(e.target.value.toUpperCase())}\n          placeholder=\"ABCD1234\"\n          className=\"w-full px-4 py-3 bg-leather-900 rounded font-mono tracking-wider uppercase\"\n          maxLength={8}\n        />\n      </div>\n\n      {error && (\n        <p className=\"text-red-400 text-sm\">{error}</p>\n      )}\n\n      <button\n        type=\"submit\"\n        disabled={isLoading || code.length < 8}\n        className=\"w-full py-3 bg-ember-500 rounded min-h-[44px] disabled:opacity-50\"\n      >\n        {isLoading ? 'Connecting...' : 'Connect with Sponsor'}\n      </button>\n    </form>\n  );\n}\n```\n\n## Sponsor Dashboard Component\n\n```tsx\n// components/SponsorDashboard.tsx\n'use client';\n\nimport { useSponsorRelationships } from '@/hooks/useSponsorRelationships';\n\nexport function SponsorDashboard() {\n  const { sponsees, sponsors, isLoading } = useSponsorRelationships();\n\n  return (\n    <div className=\"space-y-6\">\n      {/* My Sponsors */}\n      <section>\n        <h2 className=\"text-lg font-semibold mb-3\">My Sponsors</h2>\n        {sponsors.length === 0 ? (\n          <p className=\"text-leather-400\">No sponsors yet</p>\n        ) : (\n          <ul className=\"space-y-2\">\n            {sponsors.map((sponsor) => (\n              <SponsorCard\n                key={sponsor.id}\n                profile={sponsor.profile}\n                program={sponsor.program}\n                connectedAt={sponsor.startedAt}\n              />\n            ))}\n          </ul>\n        )}\n      </section>\n\n      {/* My Sponsees */}\n      <section>\n        <h2 className=\"text-lg font-semibold mb-3\">My Sponsees</h2>\n        {sponsees.length === 0 ? (\n          <p className=\"text-leather-400\">No sponsees yet</p>\n        ) : (\n          <ul className=\"space-y-2\">\n            {sponsees.map((sponsee) => (\n              <SponseeCard\n                key={sponsee.id}\n                profile={sponsee.profile}\n                program={sponsee.program}\n                connectedAt={sponsee.startedAt}\n                lastCheckIn={sponsee.lastCheckIn}\n              />\n            ))}\n          </ul>\n        )}\n      </section>\n    </div>\n  );\n}\n```\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "recovery-social-features/SKILL.md",
      "size": 9966,
      "content": "---\nname: recovery-social-features\ndescription: Privacy-first social features for recovery apps - sponsors, groups, messaging, friend connections. Use for sponsor/sponsee systems, meeting-based groups, peer support, safe messaging. Activate on \"sponsor\", \"sponsee\", \"recovery group\", \"accountability partner\", \"sober network\", \"meeting group\", \"peer support\". NOT for general social media patterns (use standard social), dating features, or public profiles.\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Grep\n  - Glob\ncategory: Lifestyle & Personal\ntags:\n  - recovery\n  - social\n  - privacy\n  - sponsor\n  - groups\n  - messaging\n  - peer-support\n---\n\n# Recovery-Focused Social Features\n\nBuild privacy-first social features for addiction recovery apps. These patterns prioritize anonymity, safety, and the unique relationship structures in recovery communities.\n\n## When to Use\n\n✅ **USE this skill for:**\n- Sponsor/sponsee relationship systems\n- Recovery-focused group features (meeting groups, accountability circles)\n- Privacy-first friend connections with mutual consent\n- Safe messaging between recovery peers\n- Anonymity-preserving profile systems\n\n❌ **DO NOT use for:**\n- General social media patterns → use standard social feature docs\n- Dating or romantic connection features → not appropriate for recovery context\n- Public-facing profiles → recovery apps should default to privacy\n- Content recommendation algorithms → use `recovery-community-moderator` for content safety\n\n## Core Principles\n\n### Privacy by Default\n\nRecovery apps handle sensitive data. Default to maximum privacy, let users opt into visibility.\n\n```typescript\ninterface PrivacySettings {\n  profileVisibility: 'private' | 'friends' | 'community';\n  showSobrietyDate: boolean;\n  showProgram: boolean;        // AA, NA, CMA, etc.\n  showLocation: 'none' | 'city' | 'region';\n  allowMessages: 'none' | 'friends' | 'sponsors' | 'all';\n  anonymousInGroups: boolean;  // Use display name only\n}\n\n// Default to most private\nconst DEFAULT_PRIVACY: PrivacySettings = {\n  profileVisibility: 'friends',\n  showSobrietyDate: false,\n  showProgram: false,\n  showLocation: 'none',\n  allowMessages: 'friends',\n  anonymousInGroups: true,\n};\n```\n\n### Anonymity Support\n\nMany users need complete anonymity. Support display names separate from real identity.\n\n```typescript\ninterface Profile {\n  id: string;\n  // Private - never exposed publicly\n  email: string;\n  realName?: string;\n\n  // Public-facing identity\n  displayName: string;        // \"JohnD\" or \"GratefulMember\"\n  avatarType: 'initials' | 'icon' | 'custom';\n  avatarIcon?: string;        // Predefined icon set\n\n  // Recovery-specific\n  sobrietyDate?: Date;\n  programs: ('aa' | 'na' | 'cma' | 'smart' | 'refuge' | 'other')[];\n  homeGroup?: string;         // Primary meeting\n}\n```\n\n## Feature Overview\n\n### Sponsor/Sponsee Relationships\n\nThe sponsor relationship is hierarchical and private. Only the two parties should know about it.\n\n**Key concepts:**\n- Invite-based connection (sponsor generates code, sponsee accepts)\n- Time-limited invite codes (24h expiration)\n- Private by design - no public visibility\n- One sponsor per program, unlimited sponsees\n\n**Hooks provided:**\n- `useSponsorInvite()` - Generate and accept invite codes\n- `useSponsorRelationships()` - List sponsors and sponsees\n\n**Components:**\n- `GenerateSponsorInvite` - Sponsor creates shareable code\n- `AcceptSponsorInvite` - Sponsee enters code to connect\n- `SponsorDashboard` - View all sponsor/sponsee relationships\n\n> **See:** `references/sponsor-sponsee.md` for full implementation\n\n---\n\n### Meeting-Based Groups\n\nGroups that form organically around meetings. Ephemeral by default but can be made permanent.\n\n**Key concepts:**\n- Tied to specific meetings or standalone\n- Ephemeral groups auto-delete after 24 hours\n- Visibility options: public, private, invite-only\n- Member limits prevent overcrowding\n\n**Group Settings:**\n\n```typescript\ninterface GroupSettings {\n  name: string;\n  meetingId?: string;           // Link to meeting\n  visibility: 'public' | 'private' | 'invite';\n  ephemeral: boolean;           // Auto-delete after 24h\n  maxMembers: number;           // Member limit\n}\n```\n\n| Visibility | Who Can See | Who Can Join |\n|------------|-------------|--------------|\n| `public` | Anyone | Anyone |\n| `private` | Members only | Invite only |\n| `invite` | Members only | Has invite code |\n\n**Hooks provided:**\n- `useMeetingGroup()` - Create, join, leave groups\n\n**Components:**\n- `QuickMeetingGroup` - One-tap group creation at meetings\n\n> **See:** `references/groups.md` for full implementation\n\n---\n\n### Friend Connections\n\nPeer-to-peer connections without hierarchy. Mutual consent required.\n\n**Key concepts:**\n- Request/accept flow (no auto-follows)\n- Real-time updates via Supabase subscriptions\n- Blocking supported (one-way, discreet)\n- Status: pending, accepted, blocked\n\n**Hooks provided:**\n- `useFriendships()` - Full friendship management with real-time sync\n\n**Components:**\n- `FriendRequestButton` - Context-aware add/pending/friends states\n- `PendingFriendRequests` - Accept/decline UI\n\n> **See:** `references/friendships.md` for full implementation\n\n---\n\n### Safe Messaging\n\nRecovery-appropriate messaging with crisis detection and safety features.\n\n**Key concepts:**\n- Real-time message delivery via Supabase\n- Crisis keyword detection (non-blocking, shows resources)\n- Soft-delete (messages hidden, not destroyed)\n- Privacy-first (no read receipts by default)\n\n**Crisis Keywords (trigger resource prompt):**\n\n```typescript\nconst CRISIS_KEYWORDS = [\n  // Suicidal ideation\n  'suicide', 'kill myself', 'want to die', 'end it all',\n  // Relapse indicators\n  'relapse', 'using again', 'fell off the wagon',\n  // Self-harm\n  'hurt myself', 'cutting', 'self-harm',\n];\n```\n\n**Best Practices:**\n1. **Non-blocking** - Crisis prompts suggest resources, don't block messages\n2. **Privacy-first** - Don't log or report crisis keywords automatically\n3. **Helpful tone** - Gentle, non-judgmental language\n4. **Direct resources** - Link to crisis page, not external sites\n5. **Offline capable** - Cache crisis resources for offline access\n\n**Hooks provided:**\n- `useMessages()` - Real-time message thread with Supabase subscriptions\n\n**Components:**\n- `MessageInput` - Input with crisis detection overlay\n\n> **See:** `references/messaging.md` for full implementation\n\n---\n\n### Accountability Features\n\nSharing recovery progress with trusted connections.\n\n**Check-In Sharing:**\n- Share daily check-ins with selected sponsors\n- HALT tracking (Hungry, Angry, Lonely, Tired)\n- Mood and gratitude logging\n\n**Sobriety Visibility Settings:**\n\n| Level | Who Can See | Use Case |\n|-------|-------------|----------|\n| `private` | Only self | Maximum privacy |\n| `sponsors` | Self + sponsors | Accountability focus |\n| `friends` | Self + sponsors + friends | Peer support |\n| `community` | All app users | Public milestone celebrations |\n\n**HALT Check-In Data:**\n\n```typescript\ninterface DailyCheckIn {\n  date: string;\n  mood: 1 | 2 | 3 | 4 | 5;  // 1=worst, 5=best\n  halt: {\n    hungry: boolean;\n    angry: boolean;\n    lonely: boolean;\n    tired: boolean;\n  };\n  gratitude?: string;\n  notes?: string;\n}\n```\n\n**Components:**\n- `ShareCheckIn` - Select sponsors to share with\n- `SobrietyVisibility` - Privacy level picker\n\n> **See:** `references/accountability.md` for full implementation\n\n---\n\n### Safety & Moderation\n\nContent moderation and user blocking for safe communities.\n\n**Moderation Categories:**\n\n| Category | Description | Action |\n|----------|-------------|--------|\n| `crisis` | Suicidal ideation, self-harm | Show resources, don't block |\n| `sourcing` | Drug seeking, dealing | Block + flag for review |\n| `harassment` | Personal attacks, threats | Block + flag for review |\n| `spam` | Promotional content | Block |\n| `explicit` | Sexual/graphic content | Block |\n\n**Blocking Behavior:**\n- Blocked user cannot send messages\n- Blocked user cannot see blocker's profile\n- Blocked user cannot see blocker in groups\n- Existing messages are hidden (not deleted)\n- Blocking is one-way (blocked user doesn't know)\n\n**RLS Policy Pattern:**\n\n```sql\n-- Hide content from blocked users\nCREATE POLICY \"Hide messages from blocked users\" ON messages\n  FOR SELECT USING (\n    NOT EXISTS (\n      SELECT 1 FROM friendships\n      WHERE status = 'blocked'\n      AND (\n        (requester_id = auth.uid() AND addressee_id = sender_id)\n        OR (addressee_id = auth.uid() AND requester_id = sender_id)\n      )\n    )\n  );\n```\n\n**Hooks provided:**\n- `useContentModeration()` - Check content against moderation API\n- `useBlocking()` - Block/unblock users, check block status\n\n> **See:** `references/moderation.md` for full implementation\n\n---\n\n## Quick Reference\n\n| Feature | Privacy Default | Who Can See |\n|---------|-----------------|-------------|\n| Profile | Friends only | Configurable |\n| Sobriety date | Hidden | Configurable |\n| Sponsor relationship | Private | Only the two parties |\n| Group membership | Group members | Configurable per group |\n| Messages | Participants only | Never public |\n| Check-ins | Private | Opt-in sharing |\n\n## Database Schema\n\nSee `supabase-admin/references/social-schema.md` for complete Supabase schema including:\n- Friendships table with RLS\n- Sponsorships with invite codes\n- Groups and group members\n- Conversations and messages\n- Real-time subscription patterns\n\n## References\n\nDetailed implementations in `/references/`:\n\n| File | Contents |\n|------|----------|\n| `sponsor-sponsee.md` | useSponsorInvite hook, invite UI components, SponsorDashboard |\n| `groups.md` | useMeetingGroup hook, QuickMeetingGroup component |\n| `friendships.md` | useFriendships hook with real-time, friend request UI |\n| `messaging.md` | useMessages hook, MessageInput with crisis detection |\n| `accountability.md` | ShareCheckIn, SobrietyVisibility components |\n| `moderation.md` | useContentModeration, useBlocking hooks, RLS policies |\n"
    }
  ]
}