{
  "name": "react-performance-optimizer",
  "type": "folder",
  "path": "react-performance-optimizer",
  "children": [
    {
      "name": "assets",
      "type": "folder",
      "path": "react-performance-optimizer/assets",
      "children": []
    },
    {
      "name": "references",
      "type": "folder",
      "path": "react-performance-optimizer/references",
      "children": [
        {
          "name": "bundle-optimization.md",
          "type": "file",
          "path": "react-performance-optimizer/references/bundle-optimization.md",
          "size": 12997,
          "content": "# Bundle Optimization Strategies\n\nComprehensive guide to reducing JavaScript bundle size for faster load times.\n\n## Why Bundle Size Matters\n\n**Impact on User Experience**:\n- 100KB bundle (gzipped) ‚Üí ~1s load on 3G\n- 500KB bundle (gzipped) ‚Üí ~5s load on 3G\n- Every 100KB adds ~1s to Time to Interactive\n\n**Business Impact**:\n- Pinterest: -40% load time ‚Üí +15% conversions\n- AutoAnything: -50% load time ‚Üí +12-13% sales\n- BBC: Every 1s slower ‚Üí -10% users\n\n---\n\n## Current State Analysis\n\n### Step 1: Measure Your Bundle\n\n```bash\n# Next.js\nnpm run build\n\n# Webpack\nnpx webpack --profile --json > stats.json\nnpx webpack-bundle-analyzer stats.json\n\n# Vite\nnpm run build\n# Check dist/ folder size\n```\n\n### Step 2: Set Targets\n\n| Bundle Size (gzipped) | Rating | Action |\n|----------------------|--------|--------|\n| &lt;100KB | ‚úÖ Excellent | Maintain |\n| 100-300KB | ‚ö†Ô∏è Good | Monitor |\n| 300-500KB | üî¥ Large | Optimize |\n| &gt;500KB | üö® Critical | Immediate action |\n\n---\n\n## Strategy 1: Code Splitting\n\n### Route-Based Splitting (Easiest Win)\n\n**Before** (single bundle):\n```typescript\nimport Home from './pages/Home';\nimport About from './pages/About';\nimport Dashboard from './pages/Dashboard';  // 500KB\n```\n\n**After** (split by route):\n```typescript\nimport { lazy, Suspense } from 'react';\n\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n      </Routes>\n    </Suspense>\n  );\n}\n```\n\n**Impact**: Main bundle: 800KB ‚Üí 300KB (500KB lazy-loaded)\n\n---\n\n### Component-Based Splitting\n\nSplit heavy components that aren't always shown:\n\n```typescript\nimport { lazy, Suspense } from 'react';\n\n// ‚ùå Always loaded (even if modal never opens)\nimport PDFViewer from './PDFViewer';  // 200KB\n\n// ‚úÖ Loaded on demand\nconst PDFViewer = lazy(() => import('./PDFViewer'));\n\nfunction App() {\n  const [showPDF, setShowPDF] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowPDF(true)}>View PDF</button>\n\n      {showPDF && (\n        <Suspense fallback={<Spinner />}>\n          <PDFViewer url=\"/document.pdf\" />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n```\n\n**When to split**:\n- Modals/dialogs\n- Admin panels\n- Charts/visualizations\n- Rich text editors\n- Video players\n\n---\n\n### Vendor Splitting\n\nSeparate third-party code from your app code:\n\n**webpack.config.js**:\n```javascript\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        // Vendor chunk (rarely changes)\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all',\n        },\n        // Common code shared across pages\n        common: {\n          minChunks: 2,\n          priority: -10,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  },\n};\n```\n\n**Benefit**: Vendor bundle cached long-term (changes infrequently)\n\n---\n\n## Strategy 2: Tree Shaking\n\n### Use ES Modules (ESM)\n\n**‚ùå CommonJS** (entire library imported):\n```javascript\nconst _ = require('lodash');  // 500KB\n_.debounce(() => {}, 300);\n```\n\n**‚úÖ ES Modules** (only imported function included):\n```javascript\nimport { debounce } from 'lodash-es';  // ~5KB\ndebounce(() => {}, 300);\n```\n\n**Impact**: 500KB ‚Üí 5KB (99% reduction)\n\n---\n\n### Import Only What You Need\n\n**‚ùå Whole library**:\n```javascript\nimport * as MUI from '@mui/material';  // 300KB\n\nfunction App() {\n  return <MUI.Button>Click</MUI.Button>;\n}\n```\n\n**‚úÖ Specific imports**:\n```javascript\nimport Button from '@mui/material/Button';  // 50KB\n\nfunction App() {\n  return <Button>Click</Button>;\n}\n```\n\n---\n\n### Configure Babel for Tree Shaking\n\n**.babelrc**:\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"modules\": false  // Don't transform ES modules\n    }]\n  ]\n}\n```\n\nWithout `\"modules\": false`, Babel converts ESM to CommonJS, breaking tree-shaking.\n\n---\n\n## Strategy 3: Replace Heavy Dependencies\n\n### Common Swaps\n\n| Old Library | Size | New Library | Size | Savings |\n|-------------|------|-------------|------|---------|\n| moment.js | 288KB | date-fns | 28KB | 90% |\n| lodash | 500KB | lodash-es | 5KB* | 99%* |\n| axios | 50KB | native fetch | 0KB | 100% |\n| react-router-dom | 45KB | wouter | 1.2KB | 97% |\n| recharts | 400KB | victory-native | 50KB | 87% |\n\n\\* When importing only needed functions\n\n---\n\n### Example: Replace moment.js with date-fns\n\n**Before**:\n```javascript\nimport moment from 'moment';  // 288KB\n\nconst formatted = moment(date).format('MMM DD, YYYY');\nconst relative = moment(date).fromNow();\n```\n\n**After**:\n```javascript\nimport { format, formatDistanceToNow } from 'date-fns';  // 28KB\n\nconst formatted = format(date, 'MMM dd, yyyy');\nconst relative = formatDistanceToNow(date, { addSuffix: true });\n```\n\n**Impact**: -260KB (-90%)\n\n---\n\n### Example: Replace axios with fetch\n\n**Before**:\n```javascript\nimport axios from 'axios';  // 50KB\n\nconst response = await axios.get('/api/users');\nconst data = response.data;\n```\n\n**After**:\n```javascript\n// Native fetch (0KB)\nconst response = await fetch('/api/users');\nconst data = await response.json();\n```\n\n**Impact**: -50KB (-100%)\n\n**Note**: For complex use cases, consider `ky` (5KB) as lightweight axios alternative\n\n---\n\n## Strategy 4: Externalize Large Dependencies\n\nMove rarely-changing libraries to CDN:\n\n**index.html**:\n```html\n<!-- React from CDN -->\n<script crossorigin src=\"https://unpkg.com/react@18/umd/react.production.min.js\"></script>\n<script crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.production.min.js\"></script>\n```\n\n**webpack.config.js**:\n```javascript\nmodule.exports = {\n  externals: {\n    react: 'React',\n    'react-dom': 'ReactDOM',\n  },\n};\n```\n\n**Impact**: Bundle size: 500KB ‚Üí 450KB (React now loaded from CDN)\n\n**Trade-offs**:\n- ‚úÖ Smaller bundle\n- ‚úÖ CDN caching across sites\n- ‚ùå Extra HTTP request\n- ‚ùå Dependency on CDN availability\n\n---\n\n## Strategy 5: Remove Unused Code\n\n### Analyze with Bundle Analyzer\n\n```bash\nnpx webpack-bundle-analyzer stats.json\n```\n\n**Look for**:\n- Libraries you don't remember installing\n- Multiple versions of same library\n- Test utilities in production bundle\n- Polyfills for features you don't use\n\n---\n\n### Example: Remove Unused Polyfills\n\n**Before** (polyfills for IE11):\n```javascript\nimport 'core-js/stable';  // 200KB\nimport 'regenerator-runtime/runtime';  // 50KB\n```\n\n**After** (modern browsers only):\n```javascript\n// Remove polyfills\n// Assume target: \"es2020\" in tsconfig.json\n```\n\n**Impact**: -250KB if targeting modern browsers\n\n---\n\n### Remove Development-Only Code\n\n**.babelrc** (production):\n```json\n{\n  \"plugins\": [\n    [\"transform-remove-console\", { \"exclude\": [\"error\", \"warn\"] }]\n  ]\n}\n```\n\n**webpack.config.js**:\n```javascript\nmodule.exports = {\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n};\n```\n\nThis removes PropTypes, debug logs, and dev warnings.\n\n---\n\n## Strategy 6: Optimize Images and Assets\n\n### Use Next-Gen Formats\n\n| Format | Size | Browser Support |\n|--------|------|-----------------|\n| PNG | 100KB | All |\n| JPEG | 50KB | All |\n| WebP | 30KB | 96% |\n| AVIF | 20KB | 89% |\n\n**Implementation**:\n```html\n<picture>\n  <source srcset=\"image.avif\" type=\"image/avif\">\n  <source srcset=\"image.webp\" type=\"image/webp\">\n  <img src=\"image.jpg\" alt=\"Fallback\">\n</picture>\n```\n\n---\n\n### Lazy Load Images\n\n```typescript\nfunction ImageGallery({ images }) {\n  return (\n    <div>\n      {images.map(img => (\n        <img\n          key={img.id}\n          src={img.url}\n          loading=\"lazy\"  // Native lazy loading\n          alt={img.alt}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n**Impact**: Initial page load doesn't download off-screen images\n\n---\n\n### Inline Small Assets\n\n**webpack.config.js**:\n```javascript\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif|svg)$/,\n        type: 'asset',\n        parser: {\n          dataUrlCondition: {\n            maxSize: 8 * 1024  // Inline if &lt;8KB\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n**Benefit**: Small images become base64 data URLs (no extra HTTP requests)\n\n---\n\n## Strategy 7: Compression\n\n### Enable Gzip/Brotli\n\n**Server config** (nginx):\n```nginx\n# Gzip\ngzip on;\ngzip_types text/plain text/css application/json application/javascript;\ngzip_min_length 1000;\n\n# Brotli (better compression)\nbrotli on;\nbrotli_types text/plain text/css application/json application/javascript;\n```\n\n**Impact**: 500KB bundle ‚Üí 100KB gzipped (80% reduction)\n\n**Brotli vs Gzip**: Brotli ~20% smaller than Gzip for text\n\n---\n\n### Pre-compress at Build Time\n\n```bash\n# Generate .gz and .br files at build\nnpx webpack --mode production\ngzip -k dist/*.js\nbrotli dist/*.js\n```\n\n**Benefit**: Server doesn't compress on-the-fly (faster response)\n\n---\n\n## Strategy 8: Minification\n\n### Terser (Webpack Default)\n\n**webpack.config.js**:\n```javascript\nconst TerserPlugin = require('terser-webpack-plugin');\n\nmodule.exports = {\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          compress: {\n            drop_console: true,  // Remove console.log\n            drop_debugger: true,\n          },\n          mangle: true,  // Shorten variable names\n        },\n      }),\n    ],\n  },\n};\n```\n\n---\n\n### CSS Minification\n\n```bash\nnpm install -D css-minimizer-webpack-plugin\n```\n\n**webpack.config.js**:\n```javascript\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      '...',  // Keep existing minimizers\n      new CssMinimizerPlugin(),\n    ],\n  },\n};\n```\n\n---\n\n## Strategy 9: Dynamic Imports for Features\n\nSplit features that not all users need:\n\n```typescript\nfunction App() {\n  const [showAdmin, setShowAdmin] = useState(false);\n\n  const loadAdminPanel = async () => {\n    // Only load admin code when needed\n    const { AdminPanel } = await import('./AdminPanel');\n    setShowAdmin(true);\n  };\n\n  return (\n    <div>\n      {user.isAdmin && (\n        <button onClick={loadAdminPanel}>Open Admin</button>\n      )}\n\n      {showAdmin && <AdminPanel />}\n    </div>\n  );\n}\n```\n\n**Impact**: Admin code (200KB) not loaded for regular users\n\n---\n\n## Strategy 10: Prefetch/Preload Strategic Resources\n\n### Prefetch Next Page\n\n```typescript\nimport { lazy, Suspense } from 'react';\n\nconst Dashboard = lazy(() => import('./Dashboard'));\n\nfunction Home() {\n  useEffect(() => {\n    // Prefetch dashboard during idle time\n    const link = document.createElement('link');\n    link.rel = 'prefetch';\n    link.href = '/dashboard.js';\n    document.head.appendChild(link);\n  }, []);\n\n  return <div>Home</div>;\n}\n```\n\n**Benefit**: Dashboard loads instantly when user navigates to it\n\n---\n\n### Preload Critical Resources\n\n```html\n<head>\n  <!-- Load critical font before anything else -->\n  <link rel=\"preload\" href=\"/fonts/main.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n\n  <!-- Preload critical CSS -->\n  <link rel=\"preload\" href=\"/critical.css\" as=\"style\">\n</head>\n```\n\n---\n\n## Real-World Example\n\n### Problem: 2.5MB Bundle\n\n**Before**:\n```\nMain bundle:     2.5MB (uncompressed)\nGzipped:         650KB\nTime to Interactive: 8 seconds on 3G\n```\n\n**Issues Found**:\n1. Entire app in one bundle (no code splitting)\n2. moment.js (288KB) for simple date formatting\n3. Lodash CommonJS import (500KB)\n4. Chart library always loaded (400KB)\n5. Multiple polyfills (250KB)\n6. No compression\n\n**Fixes Applied**:\n1. Route-based code splitting ‚Üí -800KB\n2. Replace moment.js with date-fns ‚Üí -260KB\n3. Use lodash-es with tree shaking ‚Üí -495KB\n4. Lazy load chart component ‚Üí -400KB\n5. Remove unnecessary polyfills ‚Üí -250KB\n6. Enable Brotli compression ‚Üí 80% reduction\n\n**After**:\n```\nMain bundle:     250KB (uncompressed)\nBrotli:          50KB\nTime to Interactive: 1.2 seconds on 3G\n```\n\n**Result**: 8s ‚Üí 1.2s (85% faster)\n\n---\n\n## Production Checklist\n\n```\n‚ñ° Routes code-split with React.lazy\n‚ñ° Heavy components lazy-loaded\n‚ñ° Tree-shakeable imports (ES modules)\n‚ñ° Replaced heavy dependencies (moment ‚Üí date-fns)\n‚ñ° Removed unused code (bundle analyzer checked)\n‚ñ° Compression enabled (Brotli > Gzip)\n‚ñ° Images optimized and lazy-loaded\n‚ñ° Source maps not shipped to production\n‚ñ° Minification enabled (Terser for JS, CSSMini for CSS)\n‚ñ° Bundle analyzed (no duplicate dependencies)\n‚ñ° Target: Main bundle &lt;300KB gzipped\n‚ñ° Target: TTI &lt;3 seconds on 3G\n```\n\n---\n\n## Resources\n\n- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)\n- [Bundlephobia](https://bundlephobia.com/) - Find library sizes\n- [Bundle.js.org](https://bundle.js.org/) - Compare bundle sizes\n- [Can I Use](https://caniuse.com/) - Check browser support\n"
        },
        {
          "name": "memory-leaks.md",
          "type": "file",
          "path": "react-performance-optimizer/references/memory-leaks.md",
          "size": 14798,
          "content": "# React Memory Leaks Guide\n\nCommon memory leak patterns in React and how to detect and fix them.\n\n## What Are Memory Leaks?\n\n**Definition**: Memory that's allocated but never freed, causing increasing memory usage over time.\n\n**Symptoms**:\n- Page becomes slower over time\n- Browser tab crashes after extended use\n- High memory usage in Task Manager\n- Performance degrades after navigation\n\n**Impact**:\n- 100MB leak ‚Üí Tab crash after 30 minutes\n- 10MB leak ‚Üí Noticeable slowdown after 1 hour\n\n---\n\n## Detecting Memory Leaks\n\n### Method 1: Chrome DevTools Memory Profiler\n\n```\n1. Open DevTools ‚Üí Memory tab\n2. Take heap snapshot (baseline)\n3. Interact with app (open/close components, navigate)\n4. Take second snapshot\n5. Compare snapshots\n6. Look for objects that should have been freed\n```\n\n**What to look for**:\n- Detached DOM nodes (should be 0)\n- Event listeners still attached\n- Timers still running\n- Components in memory after unmount\n\n---\n\n### Method 2: Performance Monitor\n\n```\n1. Open DevTools ‚Üí Performance Monitor\n2. Watch \"JS heap size\"\n3. Interact with app\n4. Heap should return to baseline after actions\n```\n\n**Normal**: Memory spikes then drops (garbage collected)\n**Leak**: Memory increases steadily, never drops\n\n---\n\n### Method 3: Automated Detection\n\n```typescript\n// Add to development environment\nif (process.env.NODE_ENV === 'development') {\n  let previousHeap = 0;\n\n  setInterval(() => {\n    const current = (performance as any).memory?.usedJSHeapSize || 0;\n\n    if (current > previousHeap * 1.5) {\n      console.warn('Possible memory leak detected', {\n        previous: previousHeap,\n        current,\n        increase: current - previousHeap\n      });\n    }\n\n    previousHeap = current;\n  }, 5000);\n}\n```\n\n---\n\n## Common Leak Patterns\n\n### Pattern 1: Event Listeners Not Cleaned Up\n\n**Problem**: Event listener remains after component unmounts\n\n**‚ùå Leaking Code**:\n```typescript\nfunction SearchBox() {\n  useEffect(() => {\n    // Add listener\n    window.addEventListener('resize', handleResize);\n\n    // ‚ùå Missing cleanup\n  }, []);\n\n  return <input />;\n}\n```\n\n**Why it leaks**: `handleResize` references component, preventing garbage collection\n\n**‚úÖ Fixed Code**:\n```typescript\nfunction SearchBox() {\n  useEffect(() => {\n    const handleResize = () => {\n      // Handle resize\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    // ‚úÖ Clean up on unmount\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return <input />;\n}\n```\n\n---\n\n### Pattern 2: Timers Not Cleared\n\n**Problem**: setInterval/setTimeout continues after unmount\n\n**‚ùå Leaking Code**:\n```typescript\nfunction LiveClock() {\n  const [time, setTime] = useState(new Date());\n\n  useEffect(() => {\n    // Start interval\n    setInterval(() => {\n      setTime(new Date());\n    }, 1000);\n\n    // ‚ùå Interval never cleared\n  }, []);\n\n  return <div>{time.toLocaleTimeString()}</div>;\n}\n```\n\n**Why it leaks**: Interval continues forever, calling `setTime` on unmounted component\n\n**‚úÖ Fixed Code**:\n```typescript\nfunction LiveClock() {\n  const [time, setTime] = useState(new Date());\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setTime(new Date());\n    }, 1000);\n\n    // ‚úÖ Clear interval on unmount\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, []);\n\n  return <div>{time.toLocaleTimeString()}</div>;\n}\n```\n\n---\n\n### Pattern 3: Subscriptions Not Unsubscribed\n\n**Problem**: WebSocket/EventEmitter/Observable subscription persists\n\n**‚ùå Leaking Code**:\n```typescript\nfunction ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    const socket = io(`/rooms/${roomId}`);\n\n    socket.on('message', (msg) => {\n      setMessages(prev => [...prev, msg]);\n    });\n\n    // ‚ùå Socket never disconnected\n  }, [roomId]);\n\n  return <MessageList messages={messages} />;\n}\n```\n\n**‚úÖ Fixed Code**:\n```typescript\nfunction ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    const socket = io(`/rooms/${roomId}`);\n\n    socket.on('message', (msg) => {\n      setMessages(prev => [...prev, msg]);\n    });\n\n    // ‚úÖ Disconnect and clean up\n    return () => {\n      socket.disconnect();\n    };\n  }, [roomId]);\n\n  return <MessageList messages={messages} />;\n}\n```\n\n---\n\n### Pattern 4: State Updates on Unmounted Components\n\n**Problem**: Async operation completes after unmount, tries to update state\n\n**‚ùå Leaking Code**:\n```typescript\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser(userId).then(data => {\n      setUser(data);  // ‚ùå Might run after unmount\n    });\n  }, [userId]);\n\n  return <div>{user?.name}</div>;\n}\n```\n\n**Warning in console**: \"Can't perform a React state update on an unmounted component\"\n\n**‚úÖ Fixed Code (Option 1: Cleanup flag)**:\n```typescript\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true;\n\n    fetchUser(userId).then(data => {\n      if (isMounted) {\n        setUser(data);\n      }\n    });\n\n    return () => {\n      isMounted = false;\n    };\n  }, [userId]);\n\n  return <div>{user?.name}</div>;\n}\n```\n\n**‚úÖ Fixed Code (Option 2: AbortController)**:\n```typescript\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    fetchUser(userId, { signal: controller.signal })\n      .then(data => setUser(data))\n      .catch(err => {\n        if (err.name !== 'AbortError') {\n          console.error(err);\n        }\n      });\n\n    return () => {\n      controller.abort();\n    };\n  }, [userId]);\n\n  return <div>{user?.name}</div>;\n}\n```\n\n---\n\n### Pattern 5: Closures Capturing Large Objects\n\n**Problem**: Callback holds reference to large data structure\n\n**‚ùå Leaking Code**:\n```typescript\nfunction DataGrid({ data }) {  // data is 10MB array\n  const [selected, setSelected] = useState(null);\n\n  const handleClick = useCallback((id) => {\n    // ‚ùå Closure captures entire 'data' array\n    const item = data.find(d => d.id === id);\n    setSelected(item);\n  }, [data]);  // data is in dependency array\n\n  return <Table data={data} onRowClick={handleClick} />;\n}\n```\n\n**Why it leaks**: Every re-render creates new function capturing 10MB data\n\n**‚úÖ Fixed Code**:\n```typescript\nfunction DataGrid({ data }) {\n  const [selected, setSelected] = useState(null);\n\n  // Create lookup map (smaller memory footprint)\n  const dataMap = useMemo(() => {\n    return new Map(data.map(d => [d.id, d]));\n  }, [data]);\n\n  const handleClick = useCallback((id) => {\n    // ‚úÖ Closure only captures Map reference\n    const item = dataMap.get(id);\n    setSelected(item);\n  }, [dataMap]);\n\n  return <Table data={data} onRowClick={handleClick} />;\n}\n```\n\n---\n\n### Pattern 6: DOM References Not Cleared\n\n**Problem**: Ref holds reference to detached DOM node\n\n**‚ùå Leaking Code**:\n```typescript\nfunction ImageGallery() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const imageRefs = useRef<HTMLImageElement[]>([]);\n\n  useEffect(() => {\n    // Store refs to all images\n    imageRefs.current = Array.from(\n      containerRef.current?.querySelectorAll('img') || []\n    );\n\n    // ‚ùå Image refs never cleared\n  }, []);\n\n  return (\n    <div ref={containerRef}>\n      {/* Images render here */}\n    </div>\n  );\n}\n```\n\n**‚úÖ Fixed Code**:\n```typescript\nfunction ImageGallery() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const imageRefs = useRef<HTMLImageElement[]>([]);\n\n  useEffect(() => {\n    imageRefs.current = Array.from(\n      containerRef.current?.querySelectorAll('img') || []\n    );\n\n    // ‚úÖ Clear refs on unmount\n    return () => {\n      imageRefs.current = [];\n    };\n  }, []);\n\n  return (\n    <div ref={containerRef}>\n      {/* Images render here */}\n    </div>\n  );\n}\n```\n\n---\n\n### Pattern 7: Global State Not Cleaned\n\n**Problem**: Component adds data to global store but never removes it\n\n**‚ùå Leaking Code**:\n```typescript\nfunction UserSession({ userId }) {\n  useEffect(() => {\n    // Add user to global cache\n    globalCache.set(userId, fetchUser(userId));\n\n    // ‚ùå Never removed from cache\n  }, [userId]);\n\n  return <div>Session active</div>;\n}\n```\n\n**Why it leaks**: Cache grows indefinitely as users navigate\n\n**‚úÖ Fixed Code**:\n```typescript\nfunction UserSession({ userId }) {\n  useEffect(() => {\n    globalCache.set(userId, fetchUser(userId));\n\n    // ‚úÖ Clean up on unmount\n    return () => {\n      globalCache.delete(userId);\n    };\n  }, [userId]);\n\n  return <div>Session active</div>;\n}\n```\n\n---\n\n### Pattern 8: Third-Party Library Instances\n\n**Problem**: Library instance not destroyed\n\n**‚ùå Leaking Code**:\n```typescript\nimport mapboxgl from 'mapbox-gl';\n\nfunction MapView() {\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n\n  useEffect(() => {\n    mapRef.current = new mapboxgl.Map({\n      container: 'map',\n      style: 'mapbox://styles/mapbox/streets-v11'\n    });\n\n    // ‚ùå Map instance never destroyed\n  }, []);\n\n  return <div id=\"map\" />;\n}\n```\n\n**‚úÖ Fixed Code**:\n```typescript\nimport mapboxgl from 'mapbox-gl';\n\nfunction MapView() {\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n\n  useEffect(() => {\n    mapRef.current = new mapboxgl.Map({\n      container: 'map',\n      style: 'mapbox://styles/mapbox/streets-v11'\n    });\n\n    // ‚úÖ Destroy map on unmount\n    return () => {\n      mapRef.current?.remove();\n      mapRef.current = null;\n    };\n  }, []);\n\n  return <div id=\"map\" />;\n}\n```\n\n**Common libraries that need cleanup**:\n- Mapbox GL: `map.remove()`\n- Chart.js: `chart.destroy()`\n- Monaco Editor: `editor.dispose()`\n- Three.js: `renderer.dispose()`, `geometry.dispose()`\n\n---\n\n## Advanced Debugging\n\n### Using Chrome DevTools Memory Allocation Timeline\n\n```\n1. DevTools ‚Üí Performance tab\n2. Check \"Memory\" checkbox\n3. Click record\n4. Interact with app (open/close modal 10 times)\n5. Stop recording\n6. Look at heap size graph\n```\n\n**Healthy pattern**: Sawtooth (allocate, GC, allocate, GC)\n**Leak pattern**: Steady increase (allocate, allocate, allocate)\n\n---\n\n### Heap Snapshot Comparison\n\n```\n1. Take snapshot A\n2. Open modal\n3. Take snapshot B\n4. Close modal\n5. Force GC (DevTools ‚Üí Memory ‚Üí Collect garbage icon)\n6. Take snapshot C\n7. Compare B and C\n```\n\n**What to look for**:\n- Objects from modal still in snapshot C\n- Event listeners still attached\n- Timers still running\n\n**Filter by**:\n- Constructor name (e.g., \"Timer\", \"Listener\")\n- Retained size (objects holding most memory)\n\n---\n\n### React DevTools Profiler\n\n```\n1. React DevTools ‚Üí Profiler\n2. Enable \"Record why each component rendered\"\n3. Navigate to page\n4. Navigate away\n5. Force GC\n6. Check if components still in memory\n```\n\n---\n\n## Testing for Memory Leaks\n\n### Automated Test (Jest + Puppeteer)\n\n```typescript\nimport puppeteer from 'puppeteer';\n\ntest('Modal does not leak memory', async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n  await page.goto('http://localhost:3000');\n\n  // Take baseline heap size\n  const baseline = await page.evaluate(() => {\n    return (performance as any).memory.usedJSHeapSize;\n  });\n\n  // Open/close modal 20 times\n  for (let i = 0; i < 20; i++) {\n    await page.click('[data-testid=\"open-modal\"]');\n    await page.waitForSelector('[data-testid=\"modal\"]');\n    await page.click('[data-testid=\"close-modal\"]');\n    await page.waitForSelector('[data-testid=\"modal\"]', { hidden: true });\n  }\n\n  // Force garbage collection\n  await page.evaluate(() => {\n    if ((window as any).gc) {\n      (window as any).gc();\n    }\n  });\n\n  // Check final heap size\n  const final = await page.evaluate(() => {\n    return (performance as any).memory.usedJSHeapSize;\n  });\n\n  // Memory should not increase by more than 10MB\n  const increase = final - baseline;\n  expect(increase).toBeLessThan(10 * 1024 * 1024);\n\n  await browser.close();\n});\n```\n\n**Run with**:\n```bash\nnode --expose-gc node_modules/.bin/jest memory.test.ts\n```\n\n---\n\n## Prevention Checklist\n\n```\n‚ñ° All event listeners cleaned up in useEffect return\n‚ñ° All timers (setTimeout/setInterval) cleared\n‚ñ° All subscriptions (WebSocket, EventEmitter) closed\n‚ñ° AbortController used for fetch requests\n‚ñ° Third-party library instances destroyed (.remove(), .destroy(), .dispose())\n‚ñ° Global state cleaned up on unmount\n‚ñ° Large objects not captured in closures\n‚ñ° DOM refs cleared on unmount\n‚ñ° Tested with heap snapshots (no growth after actions)\n‚ñ° Automated memory leak test in CI\n```\n\n---\n\n## Common Libraries and Cleanup\n\n| Library | Cleanup Method |\n|---------|----------------|\n| Socket.IO | `socket.disconnect()` |\n| RxJS | `subscription.unsubscribe()` |\n| Chart.js | `chart.destroy()` |\n| Mapbox GL | `map.remove()` |\n| Monaco Editor | `editor.dispose()` |\n| Three.js | `renderer.dispose()`, `geometry.dispose()`, `material.dispose()` |\n| Video.js | `player.dispose()` |\n| Swiper | `swiper.destroy()` |\n\n---\n\n## Real-World Example\n\n### Problem: Dashboard Leaking 50MB per Navigation\n\n**Symptoms**:\n- Page slow after 5-10 navigation cycles\n- Chrome DevTools shows heap growing from 50MB ‚Üí 500MB\n- Tab crashes after 15 minutes\n\n**Investigation**:\n1. Heap snapshot comparison revealed:\n   - 1000+ event listeners still attached\n   - Chart.js instances not destroyed\n   - WebSocket connections not closed\n\n**Leaking Code**:\n```typescript\nfunction Dashboard() {\n  const chartRef = useRef<Chart | null>(null);\n\n  useEffect(() => {\n    // Create chart\n    chartRef.current = new Chart(ctx, config);\n\n    // Subscribe to updates\n    socket.on('data', updateChart);\n\n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n\n    // ‚ùå Nothing cleaned up\n  }, []);\n\n  return <canvas ref={canvasRef} />;\n}\n```\n\n**Fixed Code**:\n```typescript\nfunction Dashboard() {\n  const chartRef = useRef<Chart | null>(null);\n\n  useEffect(() => {\n    chartRef.current = new Chart(ctx, config);\n    socket.on('data', updateChart);\n    window.addEventListener('resize', handleResize);\n\n    // ‚úÖ Clean up everything\n    return () => {\n      chartRef.current?.destroy();\n      socket.off('data', updateChart);\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return <canvas ref={canvasRef} />;\n}\n```\n\n**Result**:\n- Memory stable at ~50MB regardless of navigation\n- No crashes after extended use\n- Page remains fast\n\n---\n\n## Resources\n\n- [Chrome DevTools Memory Profiling](https://developer.chrome.com/docs/devtools/memory-problems/)\n- [React useEffect Cleanup](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n- [JavaScript Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n"
        },
        {
          "name": "profiling-guide.md",
          "type": "file",
          "path": "react-performance-optimizer/references/profiling-guide.md",
          "size": 10958,
          "content": "# React DevTools Profiler Guide\n\nComplete guide to identifying and fixing performance issues using React DevTools Profiler.\n\n## Installation\n\n```bash\n# Chrome Extension\nhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\n\n# Firefox Add-on\nhttps://addons.mozilla.org/en-US/firefox/addon/react-devtools/\n\n# Standalone\nnpm install -g react-devtools\n```\n\n---\n\n## The Profiler Tab\n\n### Where to Find It\n\n1. Open React DevTools (browser extension or standalone)\n2. Click the **Profiler** tab\n3. You'll see:\n   - ‚è∫Ô∏è Record button - Start/stop profiling\n   - üîÑ Reload and profile button - Profile page load\n   - ‚öôÔ∏è Settings gear - Configure profiling options\n\n---\n\n## Recording a Profile\n\n### Method 1: User Interaction\n\n```\n1. Click ‚è∫Ô∏è Record\n2. Interact with your app (click button, type, scroll, etc.)\n3. Click ‚èπÔ∏è Stop\n4. Analyze the flame graph\n```\n\n### Method 2: Page Load\n\n```\n1. Click üîÑ Reload and profile\n2. Wait for page to fully load\n3. Profiler automatically stops\n4. Analyze initial render performance\n```\n\n---\n\n## Reading the Flame Graph\n\n### What Each Color Means\n\n**Colors** (gradient from green to yellow to red):\n- üü¢ **Green**: Fast render (&lt;1ms)\n- üü° **Yellow**: Moderate render (1-10ms)\n- üî¥ **Red**: Slow render (&gt;10ms)\n\n**Width**: How long the component took to render\n\n**Hover**: See exact render time and why it rendered\n\n### Example Interpretation\n\n```\nApp (25ms)\n‚îú‚îÄ‚îÄ Navbar (2ms)         ‚úÖ Fast\n‚îú‚îÄ‚îÄ Sidebar (1ms)        ‚úÖ Fast\n‚îî‚îÄ‚îÄ Dashboard (22ms)     üî¥ SLOW - investigate!\n    ‚îú‚îÄ‚îÄ UserList (20ms)  üî¥ SLOW - root cause\n    ‚îî‚îÄ‚îÄ Stats (2ms)      ‚úÖ Fast\n```\n\n**Diagnosis**: UserList is the bottleneck (20ms of 25ms total)\n\n---\n\n## Understanding \"Why Did This Render?\"\n\nClick on a component in the flame graph to see:\n\n### 1. Props Changed\n\n```\nWhy did this render?\n‚Ä¢ Props changed: { userId: 123 }\n```\n\n**Fix**: If props didn't actually change, wrap parent in `React.memo` or memoize the prop value.\n\n### 2. Parent Rendered\n\n```\nWhy did this render?\n‚Ä¢ Parent component rendered\n```\n\n**Fix**: Wrap this component in `React.memo` to prevent cascading re-renders.\n\n### 3. State Changed\n\n```\nWhy did this render?\n‚Ä¢ Hook 1 changed\n```\n\n**Fix**: This is expected. Ensure state updates are necessary.\n\n### 4. Context Changed\n\n```\nWhy did this render?\n‚Ä¢ Context changed\n```\n\n**Fix**: Split context into smaller pieces or memoize context value.\n\n---\n\n## Common Patterns and Fixes\n\n### Pattern 1: Entire Tree Re-renders on Unrelated State Change\n\n**Symptom**: Changing state in Header causes Footer to re-render\n\n**Flame Graph**:\n```\nApp (50ms)              üî¥\n‚îú‚îÄ‚îÄ Header (2ms)        üü°\n‚îú‚îÄ‚îÄ Content (40ms)      üî¥ Unnecessary\n‚îî‚îÄ‚îÄ Footer (8ms)        üî¥ Unnecessary\n```\n\n**Fix**: Wrap components in React.memo\n\n```typescript\nconst Header = React.memo(({ title }) => {\n  return <header>{title}</header>;\n});\n\nconst Content = React.memo(({ children }) => {\n  return <main>{children}</main>;\n});\n\nconst Footer = React.memo(() => {\n  return <footer>Footer</footer>;\n});\n```\n\n**Result**: Only Header re-renders\n\n```\nApp (2ms)               üü¢\n‚îî‚îÄ‚îÄ Header (2ms)        üü¢\n```\n\n---\n\n### Pattern 2: List Renders Slowly\n\n**Symptom**: Rendering 1000-item list takes &gt;500ms\n\n**Flame Graph**:\n```\nUserList (500ms)        üî¥\n‚îú‚îÄ‚îÄ UserCard (0.5ms) x1000\n```\n\n**Fix**: Virtualize with react-window\n\n```typescript\nimport { FixedSizeList } from 'react-window';\n\nfunction UserList({ users }) {\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={users.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {({ index, style }) => (\n        <div style={style}>\n          <UserCard user={users[index]} />\n        </div>\n      )}\n    </FixedSizeList>\n  );\n}\n```\n\n**Result**: Render time drops to &lt;50ms\n\n```\nUserList (50ms)         üü¢\n‚îî‚îÄ‚îÄ UserCard (0.5ms) x12  (only visible items)\n```\n\n---\n\n### Pattern 3: Parent Passes New Callback on Every Render\n\n**Symptom**: Child wrapped in React.memo still re-renders\n\n**Flame Graph**:\n```\nParent (30ms)\n‚îî‚îÄ‚îÄ Child (28ms)        üî¥ Re-renders despite React.memo\n```\n\n**Why**: Parent passes new function reference\n\n```typescript\n// ‚ùå Creates new function every render\nfunction Parent() {\n  return <Child onClick={() => console.log('clicked')} />;\n}\n```\n\n**Fix**: Memoize callback with useCallback\n\n```typescript\n// ‚úÖ Stable function reference\nfunction Parent() {\n  const handleClick = useCallback(() => {\n    console.log('clicked');\n  }, []);\n\n  return <Child onClick={handleClick} />;\n}\n\nconst Child = React.memo(({ onClick }) => {\n  return <button onClick={onClick}>Click me</button>;\n});\n```\n\n**Result**: Child no longer re-renders\n\n---\n\n### Pattern 4: Expensive Calculation on Every Render\n\n**Symptom**: Component takes 100ms but doesn't render anything complex\n\n**Flame Graph**:\n```\nProductList (100ms)     üî¥\n‚îî‚îÄ‚îÄ (no children, just slow)\n```\n\n**Code**:\n```typescript\nfunction ProductList({ products }) {\n  // ‚ùå Sorts on every render\n  const sorted = products.sort((a, b) => b.price - a.price);\n\n  return <div>{sorted.map(p => <Product product={p} />)}</div>;\n}\n```\n\n**Fix**: Memoize expensive calculation\n\n```typescript\nfunction ProductList({ products }) {\n  // ‚úÖ Only re-sorts when products change\n  const sorted = useMemo(\n    () => [...products].sort((a, b) => b.price - a.price),\n    [products]\n  );\n\n  return <div>{sorted.map(p => <Product product={p} />)}</div>;\n}\n```\n\n**Result**: Render time drops from 100ms ‚Üí 5ms\n\n---\n\n## Profiler Settings\n\n### Record Why Components Rendered\n\n**Enable**: Settings ‚öôÔ∏è ‚Üí \"Record why each component rendered while profiling\"\n\n**Benefit**: See exact cause (props, state, context, parent)\n\n**Trade-off**: Slight performance overhead during profiling\n\n### Highlight Updates\n\n**Enable**: Settings ‚öôÔ∏è ‚Üí \"Highlight updates when components render\"\n\n**Benefit**: See which components re-render in real-time (blue flash)\n\n**Use case**: Quickly spot unnecessary re-renders without profiling\n\n---\n\n## Profiling Production Builds\n\n### Why Profile Production?\n\n- Development mode is 2-5x slower (extra checks, warnings)\n- Only production profiling shows real user experience\n- Tree-shaking and minification affect bundle size\n\n### How to Profile Production\n\n**Option 1: Build with profiling enabled**\n\n```bash\n# React (webpack)\nnpx react-app-rewired build --profile\n\n# Next.js\nNEXT_PUBLIC_PROFILING=true npm run build\n```\n\n**Option 2: Use profiling build**\n\n```javascript\n// Use production build with profiling\nimport { unstable_trace as trace } from 'scheduler/tracing';\n```\n\n---\n\n## Metrics to Target\n\n| Metric | Excellent | Good | Needs Work |\n|--------|-----------|------|------------|\n| Component render time | &lt;5ms | 5-16ms | &gt;16ms (visible lag) |\n| Total page load | &lt;1s | 1-3s | &gt;3s |\n| Interaction response | &lt;100ms | 100-300ms | &gt;300ms (feels slow) |\n| List item render | &lt;1ms | 1-5ms | &gt;5ms (virtualize) |\n\n**The 16ms Rule**: 60 FPS = 16.67ms per frame. Renders &gt;16ms cause dropped frames.\n\n---\n\n## Real-World Example\n\n### Problem: Slow Dashboard\n\n**Flame Graph**:\n```\nDashboard (180ms)       üî¥\n‚îú‚îÄ‚îÄ Sidebar (2ms)\n‚îú‚îÄ‚îÄ Header (3ms)\n‚îî‚îÄ‚îÄ DataTable (175ms)   üî¥\n    ‚îú‚îÄ‚îÄ TableHeader (2ms)\n    ‚îî‚îÄ‚îÄ TableBody (173ms) üî¥\n        ‚îú‚îÄ‚îÄ Row (0.17ms) x1000\n```\n\n**Diagnosis**:\n1. DataTable is bottleneck (175ms of 180ms)\n2. Rendering 1000 rows (0.17ms each = 170ms total)\n3. Even though each row is fast, rendering 1000 is slow\n\n**Fix**:\n```typescript\nimport { FixedSizeList } from 'react-window';\n\nfunction DataTable({ rows }) {\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={rows.length}\n      itemSize={40}\n    >\n      {({ index, style }) => (\n        <Row style={style} data={rows[index]} />\n      )}\n    </FixedSizeList>\n  );\n}\n```\n\n**Result**:\n```\nDashboard (15ms)        üü¢\n‚îú‚îÄ‚îÄ Sidebar (2ms)\n‚îú‚îÄ‚îÄ Header (3ms)\n‚îî‚îÄ‚îÄ DataTable (10ms)    üü¢\n    ‚îî‚îÄ‚îÄ Row (0.17ms) x15  (only visible rows)\n```\n\n**Improvement**: 180ms ‚Üí 15ms (92% faster!)\n\n---\n\n## Debugging Workflow\n\n1. **Identify slow component**\n   - Record profile\n   - Look for red/yellow bars in flame graph\n   - Click to see render time\n\n2. **Understand why it's slow**\n   - Check \"Why did this render?\"\n   - Is it rendering unnecessarily?\n   - Is the render itself expensive?\n\n3. **Apply fix**\n   - Unnecessary re-renders? ‚Üí React.memo, useCallback\n   - Expensive calculation? ‚Üí useMemo\n   - Large list? ‚Üí Virtualization\n   - Heavy component? ‚Üí Code splitting with React.lazy\n\n4. **Verify improvement**\n   - Record new profile\n   - Compare before/after\n   - Target: Green bars, &lt;16ms render time\n\n---\n\n## Common Mistakes\n\n### Mistake 1: Profiling in Development\n\n**Problem**: Dev mode is 2-5x slower than production\n\n**Solution**: Always profile production builds for accurate measurements\n\n### Mistake 2: Optimizing Green Components\n\n**Problem**: Spending time memoizing fast components (&lt;5ms)\n\n**Solution**: Focus on red/yellow bars first (&gt;10ms)\n\n### Mistake 3: Ignoring \"Why Did This Render?\"\n\n**Problem**: Blindly adding useMemo/useCallback everywhere\n\n**Solution**: Click component to see actual render cause, then fix root issue\n\n### Mistake 4: Not Testing After Changes\n\n**Problem**: Optimization doesn't actually improve performance\n\n**Solution**: Record before/after profiles to verify improvement\n\n---\n\n## Advanced Techniques\n\n### Custom Profiler API\n\nProgrammatically measure render performance:\n\n```typescript\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(\n  id,                  // \"DataTable\"\n  phase,               // \"mount\" or \"update\"\n  actualDuration,      // Time spent rendering\n  baseDuration,        // Estimated time without memoization\n  startTime,           // When render started\n  commitTime,          // When render committed\n  interactions         // Set of interactions\n) {\n  console.log(`${id} took ${actualDuration}ms to render`);\n\n  // Send to analytics\n  if (actualDuration > 16) {\n    analytics.track('Slow Render', { id, actualDuration });\n  }\n}\n\nfunction App() {\n  return (\n    <Profiler id=\"DataTable\" onRender={onRenderCallback}>\n      <DataTable />\n    </Profiler>\n  );\n}\n```\n\n### User Timing API\n\nAdd custom markers:\n\n```typescript\nfunction DataTable() {\n  performance.mark('data-table-render-start');\n\n  // Rendering logic\n\n  performance.mark('data-table-render-end');\n  performance.measure(\n    'DataTable Render',\n    'data-table-render-start',\n    'data-table-render-end'\n  );\n\n  return <div>...</div>;\n}\n```\n\nView in Performance tab of browser DevTools.\n\n---\n\n## Resources\n\n- [React DevTools Profiler Docs](https://react.dev/learn/react-developer-tools)\n- [Profiling Performance](https://react.dev/reference/react/Profiler)\n- [Chrome Performance Tab](https://developer.chrome.com/docs/devtools/performance/)\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "react-performance-optimizer/scripts",
      "children": [
        {
          "name": "bundle_analyzer.sh",
          "type": "file",
          "path": "react-performance-optimizer/scripts/bundle_analyzer.sh",
          "size": 6638,
          "content": "#!/bin/bash\n# Bundle Analyzer Script\n#\n# Analyzes webpack bundle to identify large dependencies and optimization opportunities.\n#\n# Usage:\n#   ./bundle_analyzer.sh\n#   ./bundle_analyzer.sh --no-open    # Don't open browser\n#   ./bundle_analyzer.sh --json       # Generate JSON report\n#\n# Requirements:\n#   npm install -D webpack-bundle-analyzer\n#\n# For Next.js projects, install @next/bundle-analyzer instead\n\nset -e  # Exit on error\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Configuration\nOPEN_BROWSER=true\nJSON_MODE=false\nBUILD_DIR=\"dist\"\nSTATS_FILE=\"stats.json\"\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    --no-open)\n      OPEN_BROWSER=false\n      shift\n      ;;\n    --json)\n      JSON_MODE=true\n      shift\n      ;;\n    *)\n      echo \"Unknown option: $1\"\n      echo \"Usage: ./bundle_analyzer.sh [--no-open] [--json]\"\n      exit 1\n      ;;\n  esac\ndone\n\necho -e \"${BLUE}üì¶ Bundle Analyzer${NC}\\n\"\n\n# Detect project type\nif [ -f \"next.config.js\" ] || [ -f \"next.config.mjs\" ]; then\n  PROJECT_TYPE=\"nextjs\"\n  echo -e \"${GREEN}Detected: Next.js project${NC}\"\nelif [ -f \"vite.config.ts\" ] || [ -f \"vite.config.js\" ]; then\n  PROJECT_TYPE=\"vite\"\n  echo -e \"${GREEN}Detected: Vite project${NC}\"\nelif grep -q \"react-scripts\" package.json 2>/dev/null; then\n  PROJECT_TYPE=\"cra\"\n  echo -e \"${GREEN}Detected: Create React App${NC}\"\nelse\n  PROJECT_TYPE=\"webpack\"\n  echo -e \"${GREEN}Detected: Webpack project${NC}\"\nfi\n\n# Function to analyze Next.js bundle\nanalyze_nextjs() {\n  echo -e \"\\n${YELLOW}Setting up Next.js bundle analyzer...${NC}\"\n\n  # Check if analyzer is installed\n  if ! grep -q \"@next/bundle-analyzer\" package.json; then\n    echo -e \"${YELLOW}Installing @next/bundle-analyzer...${NC}\"\n    npm install -D @next/bundle-analyzer\n  fi\n\n  # Create or update next.config.js\n  if [ -f \"next.config.js\" ]; then\n    echo -e \"${YELLOW}Backup existing next.config.js...${NC}\"\n    cp next.config.js next.config.js.backup\n  fi\n\n  # Add analyzer to config\n  cat > next.config.analyzer.js << 'EOF'\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\n\nconst nextConfig = {\n  // Your existing config here\n}\n\nmodule.exports = withBundleAnalyzer(nextConfig)\nEOF\n\n  echo -e \"${GREEN}Running Next.js build with analyzer...${NC}\\n\"\n  ANALYZE=true npm run build\n\n  echo -e \"\\n${GREEN}‚úÖ Analysis complete!${NC}\"\n  echo -e \"Reports generated in .next/analyze/\"\n}\n\n# Function to analyze Vite bundle\nanalyze_vite() {\n  echo -e \"\\n${YELLOW}Setting up Vite bundle analyzer...${NC}\"\n\n  # Check if plugin is installed\n  if ! grep -q \"rollup-plugin-visualizer\" package.json; then\n    echo -e \"${YELLOW}Installing rollup-plugin-visualizer...${NC}\"\n    npm install -D rollup-plugin-visualizer\n  fi\n\n  # Add to vite.config.ts\n  echo -e \"${YELLOW}Add visualizer plugin to vite.config.ts:${NC}\"\n  cat << 'EOF'\n\nimport { visualizer } from 'rollup-plugin-visualizer';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    visualizer({\n      filename: 'dist/stats.html',\n      open: true,\n      gzipSize: true,\n      brotliSize: true\n    })\n  ]\n});\nEOF\n\n  echo -e \"\\n${YELLOW}Run: npm run build${NC}\"\n  echo -e \"Then open: dist/stats.html\\n\"\n}\n\n# Function to analyze CRA bundle\nanalyze_cra() {\n  echo -e \"\\n${YELLOW}Setting up CRA bundle analyzer...${NC}\"\n\n  # Install analyzer\n  if ! grep -q \"source-map-explorer\" package.json; then\n    echo -e \"${YELLOW}Installing source-map-explorer...${NC}\"\n    npm install -D source-map-explorer\n  fi\n\n  # Add script to package.json\n  echo -e \"${YELLOW}Add to package.json scripts:${NC}\"\n  cat << 'EOF'\n\n\"analyze\": \"source-map-explorer 'build/static/js/*.js'\"\nEOF\n\n  echo -e \"\\n${GREEN}Running production build...${NC}\\n\"\n  npm run build\n\n  echo -e \"\\n${GREEN}Analyzing bundle...${NC}\\n\"\n  npm run analyze\n}\n\n# Function to analyze webpack bundle\nanalyze_webpack() {\n  echo -e \"\\n${YELLOW}Setting up webpack bundle analyzer...${NC}\"\n\n  # Check if analyzer is installed\n  if ! grep -q \"webpack-bundle-analyzer\" package.json; then\n    echo -e \"${YELLOW}Installing webpack-bundle-analyzer...${NC}\"\n    npm install -D webpack-bundle-analyzer\n  fi\n\n  # Generate stats\n  echo -e \"\\n${GREEN}Building with stats...${NC}\\n\"\n\n  if [ -f \"webpack.config.js\" ]; then\n    npx webpack --profile --json > stats.json\n  else\n    npm run build -- --stats\n  fi\n\n  # Run analyzer\n  if [ -f \"stats.json\" ]; then\n    echo -e \"\\n${GREEN}Opening bundle analyzer...${NC}\\n\"\n\n    if [ \"$OPEN_BROWSER\" = true ]; then\n      npx webpack-bundle-analyzer stats.json\n    else\n      npx webpack-bundle-analyzer stats.json --no-open\n    fi\n  else\n    echo -e \"${RED}stats.json not found. Build may have failed.${NC}\"\n    exit 1\n  fi\n}\n\n# Main execution\ncase $PROJECT_TYPE in\n  nextjs)\n    analyze_nextjs\n    ;;\n  vite)\n    analyze_vite\n    ;;\n  cra)\n    analyze_cra\n    ;;\n  webpack)\n    analyze_webpack\n    ;;\nesac\n\n# Print optimization tips\necho -e \"\\n${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}\"\necho -e \"${BLUE}üìä Bundle Optimization Tips${NC}\"\necho -e \"${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}\\n\"\n\necho -e \"${YELLOW}Look for:${NC}\"\necho -e \"  üîç Large dependencies (>100KB)\"\necho -e \"  üîç Duplicate dependencies (different versions)\"\necho -e \"  üîç Unused dependencies\"\necho -e \"  üîç Development dependencies in production bundle\"\necho \"\"\n\necho -e \"${YELLOW}Common fixes:${NC}\"\necho -e \"  ‚úÖ Code splitting: Use dynamic import() for routes\"\necho -e \"  ‚úÖ Tree-shaking: Use ESM imports (import { x } from 'lib')\"\necho -e \"  ‚úÖ Smaller alternatives:\"\necho -e \"     - moment.js ‚Üí date-fns (10x smaller)\"\necho -e \"     - lodash ‚Üí lodash-es (tree-shakeable)\"\necho -e \"     - axios ‚Üí native fetch\"\necho -e \"  ‚úÖ Externalize: Move large libs to CDN\"\necho -e \"  ‚úÖ Lazy load: Use React.lazy() for components\"\necho \"\"\n\necho -e \"${YELLOW}Target bundle sizes (gzipped):${NC}\"\necho -e \"  üéØ Excellent: <100KB\"\necho -e \"  ‚ö†Ô∏è  Good: 100-300KB\"\necho -e \"  üî¥ Large: >300KB (needs optimization)\"\necho \"\"\n\n# Calculate current bundle size\nif [ -d \"$BUILD_DIR/static/js\" ]; then\n  TOTAL_SIZE=$(du -sh \"$BUILD_DIR/static/js\" | cut -f1)\n  echo -e \"${GREEN}Current JS bundle size: $TOTAL_SIZE${NC}\"\nelif [ -d \".next/static\" ]; then\n  TOTAL_SIZE=$(du -sh \".next/static\" | cut -f1)\n  echo -e \"${GREEN}Current bundle size: $TOTAL_SIZE${NC}\"\nfi\n\necho \"\"\n"
        },
        {
          "name": "performance_audit.ts",
          "type": "file",
          "path": "react-performance-optimizer/scripts/performance_audit.ts",
          "size": 9997,
          "content": "#!/usr/bin/env node\n/**\n * React Performance Audit Tool\n *\n * Analyzes React components for common performance issues.\n *\n * Usage: npx tsx performance_audit.ts [directory]\n *\n * Examples:\n *   npx tsx performance_audit.ts src/components\n *   npx tsx performance_audit.ts src/\n *\n * Checks for:\n * - Missing React.memo on expensive components\n * - Inline function definitions in JSX\n * - Missing useCallback/useMemo\n * - Large lists without virtualization\n * - Expensive operations in render\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface PerformanceIssue {\n  file: string;\n  line: number;\n  severity: 'critical' | 'warning' | 'info';\n  type: string;\n  message: string;\n  fix?: string;\n}\n\nclass PerformanceAuditor {\n  private issues: PerformanceIssue[] = [];\n  private fileCount = 0;\n  private componentCount = 0;\n\n  auditDirectory(dir: string): void {\n    const files = this.getReactFiles(dir);\n\n    files.forEach(file => {\n      this.auditFile(file);\n    });\n  }\n\n  private getReactFiles(dir: string): string[] {\n    const files: string[] = [];\n\n    const walk = (currentDir: string) => {\n      const entries = fs.readdirSync(currentDir, { withFileTypes: true });\n\n      entries.forEach(entry => {\n        const fullPath = path.join(currentDir, entry.name);\n\n        if (entry.isDirectory()) {\n          // Skip node_modules, build, dist\n          if (!['node_modules', 'build', 'dist', '.next'].includes(entry.name)) {\n            walk(fullPath);\n          }\n        } else if (entry.isFile()) {\n          // React files: .tsx, .jsx\n          if (/\\.(tsx|jsx)$/.test(entry.name)) {\n            files.push(fullPath);\n          }\n        }\n      });\n    };\n\n    walk(dir);\n    return files;\n  }\n\n  private auditFile(filePath: string): void {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const lines = content.split('\\n');\n\n    this.fileCount++;\n\n    // Check for component definitions\n    const componentMatches = content.match(/(?:function|const)\\s+([A-Z][a-zA-Z0-9]*)/g);\n    if (componentMatches) {\n      this.componentCount += componentMatches.length;\n    }\n\n    // Check each line\n    lines.forEach((line, index) => {\n      const lineNumber = index + 1;\n\n      // Critical: Inline arrow functions in JSX\n      if (this.hasInlineFunction(line) && this.isJSXLine(line)) {\n        this.addIssue(filePath, lineNumber, 'critical', 'inline-function',\n          'Inline arrow function in JSX creates new reference on every render',\n          'Extract to useCallback or define outside render');\n      }\n\n      // Critical: Large array.map without virtualization\n      if (this.hasUnvirtualizedList(line)) {\n        this.addIssue(filePath, lineNumber, 'critical', 'unvirtualized-list',\n          'Rendering large list without virtualization',\n          'Use react-window or react-virtualized for lists >100 items');\n      }\n\n      // Warning: Component not wrapped in React.memo\n      if (this.isPureComponent(line, content) && !this.hasMemo(content)) {\n        this.addIssue(filePath, lineNumber, 'warning', 'missing-memo',\n          'Pure component could benefit from React.memo',\n          'Wrap component in React.memo to prevent unnecessary re-renders');\n      }\n\n      // Warning: Expensive computation in render\n      if (this.hasExpensiveOperation(line) && !this.hasUseMemo(content, line)) {\n        this.addIssue(filePath, lineNumber, 'warning', 'expensive-render',\n          'Expensive operation in render without memoization',\n          'Wrap in useMemo to avoid recomputing on every render');\n      }\n\n      // Info: useState for derived state\n      if (this.hasDerivedState(line, lines, index)) {\n        this.addIssue(filePath, lineNumber, 'info', 'derived-state',\n          'Derived state should be computed from props/state, not stored',\n          'Calculate during render or use useMemo if expensive');\n      }\n    });\n  }\n\n  private hasInlineFunction(line: string): boolean {\n    // Matches: onClick={() => ...}, onChange={(e) => ...}\n    return /\\w+={(?:\\([^)]*\\)|[a-z])\\s*=>/i.test(line);\n  }\n\n  private isJSXLine(line: string): boolean {\n    return /<[A-Z]/.test(line) || /<[a-z]+\\s/.test(line);\n  }\n\n  private hasUnvirtualizedList(line: string): boolean {\n    // Matches: {items.map(...)} without FixedSizeList/VariableSizeList\n    return /\\{\\s*\\w+\\.map\\(/.test(line) &&\n           !/FixedSizeList|VariableSizeList|VirtualList/.test(line);\n  }\n\n  private isPureComponent(line: string, content: string): boolean {\n    // Component that only depends on props (no hooks, no state)\n    const match = line.match(/(?:function|const)\\s+([A-Z][a-zA-Z0-9]*)/);\n    if (!match) return false;\n\n    const componentName = match[1];\n    const componentBody = this.extractComponentBody(content, componentName);\n\n    // Has no useState, useReducer, useContext\n    return !/use(?:State|Reducer|Context)/.test(componentBody);\n  }\n\n  private hasMemo(content: string): boolean {\n    return /React\\.memo|memo\\(/.test(content);\n  }\n\n  private hasExpensiveOperation(line: string): boolean {\n    // Matches: .sort(), .filter().map(), new Date(), JSON.parse()\n    return /\\.sort\\(|\\.filter\\([^)]+\\)\\.map\\(|new Date\\(|JSON\\.parse\\(/.test(line);\n  }\n\n  private hasUseMemo(content: string, line: string): boolean {\n    // Check if this operation is already wrapped in useMemo\n    const lines = content.split('\\n');\n    const currentIndex = lines.indexOf(line);\n\n    // Look backwards for useMemo within 5 lines\n    for (let i = Math.max(0, currentIndex - 5); i < currentIndex; i++) {\n      if (/useMemo\\(/.test(lines[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private hasDerivedState(line: string, lines: string[], index: number): boolean {\n    // Matches: const [x, setX] = useState(computeFromProps(props))\n    if (!/useState\\(/.test(line)) return false;\n\n    const stateInitializer = line.match(/useState\\(([^)]+)\\)/)?.[1];\n    if (!stateInitializer) return false;\n\n    // If initializer calls a function with props/state, it's likely derived\n    return /(?:props|state)\\.\\w+/.test(stateInitializer);\n  }\n\n  private extractComponentBody(content: string, componentName: string): string {\n    const regex = new RegExp(`(?:function|const)\\\\s+${componentName}[^{]*{([^}]+)}`, 's');\n    const match = content.match(regex);\n    return match ? match[1] : '';\n  }\n\n  private addIssue(\n    file: string,\n    line: number,\n    severity: PerformanceIssue['severity'],\n    type: string,\n    message: string,\n    fix?: string\n  ): void {\n    this.issues.push({ file, line, severity, type, message, fix });\n  }\n\n  report(): void {\n    console.log('\\n‚ö° React Performance Audit Report\\n');\n    console.log('‚îÄ'.repeat(80));\n    console.log(`\\nScanned ${this.fileCount} files, found ${this.componentCount} components\\n`);\n\n    if (this.issues.length === 0) {\n      console.log('‚úÖ No performance issues detected!\\n');\n      return;\n    }\n\n    const critical = this.issues.filter(i => i.severity === 'critical');\n    const warnings = this.issues.filter(i => i.severity === 'warning');\n    const info = this.issues.filter(i => i.severity === 'info');\n\n    console.log(`Found ${critical.length} critical, ${warnings.length} warnings, ${info.length} suggestions\\n`);\n\n    if (critical.length > 0) {\n      console.log('üî¥ Critical Issues (fix immediately):\\n');\n      this.printIssues(critical);\n    }\n\n    if (warnings.length > 0) {\n      console.log('‚ö†Ô∏è  Warnings (fix for better performance):\\n');\n      this.printIssues(warnings);\n    }\n\n    if (info.length > 0) {\n      console.log('üí° Suggestions (consider optimizing):\\n');\n      this.printIssues(info);\n    }\n\n    console.log('‚îÄ'.repeat(80));\n    this.printSummary();\n  }\n\n  private printIssues(issues: PerformanceIssue[]): void {\n    // Group by file\n    const byFile = new Map<string, PerformanceIssue[]>();\n\n    issues.forEach(issue => {\n      if (!byFile.has(issue.file)) {\n        byFile.set(issue.file, []);\n      }\n      byFile.get(issue.file)!.push(issue);\n    });\n\n    byFile.forEach((fileIssues, file) => {\n      console.log(`üìÑ ${file}`);\n\n      fileIssues.forEach(issue => {\n        console.log(`  Line ${issue.line}: ${issue.message}`);\n        if (issue.fix) {\n          console.log(`  üí° Fix: ${issue.fix}`);\n        }\n      });\n\n      console.log('');\n    });\n  }\n\n  private printSummary(): void {\n    console.log('\\nüìä Summary by Issue Type:\\n');\n\n    const typeCount = new Map<string, number>();\n    this.issues.forEach(issue => {\n      typeCount.set(issue.type, (typeCount.get(issue.type) || 0) + 1);\n    });\n\n    const sortedTypes = Array.from(typeCount.entries())\n      .sort((a, b) => b[1] - a[1]);\n\n    sortedTypes.forEach(([type, count]) => {\n      const icon = this.getIconForType(type);\n      console.log(`${icon} ${type}: ${count}`);\n    });\n\n    console.log('\\nüéØ Recommended Actions:\\n');\n    console.log('1. Fix all critical issues first (inline functions, unvirtualized lists)');\n    console.log('2. Profile with React DevTools to confirm impact');\n    console.log('3. Add React.memo to components that re-render frequently');\n    console.log('4. Run bundle analyzer to identify code splitting opportunities');\n    console.log('');\n  }\n\n  private getIconForType(type: string): string {\n    const icons: Record<string, string> = {\n      'inline-function': 'üî•',\n      'unvirtualized-list': 'üìã',\n      'missing-memo': 'üîÑ',\n      'expensive-render': '‚è±Ô∏è',\n      'derived-state': 'üíæ'\n    };\n    return icons[type] || 'üìå';\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  const dir = args[0] || 'src';\n\n  if (!fs.existsSync(dir)) {\n    console.error(`‚ùå Directory not found: ${dir}`);\n    console.error('\\nUsage: npx tsx performance_audit.ts [directory]');\n    console.error('Example: npx tsx performance_audit.ts src/components');\n    process.exit(1);\n  }\n\n  const auditor = new PerformanceAuditor();\n  auditor.auditDirectory(dir);\n  auditor.report();\n}\n\nexport { PerformanceAuditor };\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "react-performance-optimizer/SKILL.md",
      "size": 10728,
      "content": "---\nname: react-performance-optimizer\ndescription: Optimize React apps for 60fps performance. Implements memoization, virtualization, code splitting, bundle optimization. Use for slow renders, large lists, bundle bloat. Activate on \"React performance\", \"slow render\", \"useMemo\", \"bundle size\", \"virtualization\". NOT for backend optimization, non-React frameworks, or premature optimization.\nallowed-tools: Read,Write,Edit,Bash(npm:*)\n---\n\n# React Performance Optimizer\n\nExpert in diagnosing and fixing React performance issues to achieve buttery-smooth 60fps experiences.\n\n## When to Use\n\n‚úÖ **Use for**:\n- Slow component re-renders\n- Large lists (&gt;100 items) causing lag\n- Bundle size &gt;500KB (gzipped)\n- Time to Interactive &gt;3 seconds\n- Janky scrolling or animations\n- Memory leaks from unmounted components\n\n‚ùå **NOT for**:\n- Apps with &lt;10 components (premature optimization)\n- Backend API slowness (fix the API)\n- Network latency (use caching/CDN)\n- Non-React frameworks (use framework-specific tools)\n\n## Quick Decision Tree\n\n```\nIs your React app slow?\n‚îú‚îÄ‚îÄ Profiler shows &gt;16ms renders? ‚Üí Use memoization\n‚îú‚îÄ‚îÄ Lists with &gt;100 items? ‚Üí Use virtualization\n‚îú‚îÄ‚îÄ Bundle size &gt;500KB? ‚Üí Code splitting\n‚îú‚îÄ‚îÄ Lighthouse score &lt;70? ‚Üí Multiple optimizations\n‚îî‚îÄ‚îÄ Feels fast enough? ‚Üí Don't optimize yet\n```\n\n---\n\n## Technology Selection\n\n### Performance Tools (2024)\n\n| Tool | Purpose | When to Use |\n|------|---------|-------------|\n| React DevTools Profiler | Find slow components | Always start here |\n| Lighthouse | Overall performance score | Before/after comparison |\n| webpack-bundle-analyzer | Identify large dependencies | Bundle &gt;500KB |\n| why-did-you-render | Unnecessary re-renders | Debug re-render storms |\n| React Compiler (2024+) | Automatic memoization | React 19+ |\n\n**Timeline**:\n- 2018: React.memo, useMemo, useCallback introduced\n- 2020: Concurrent Mode (now Concurrent Rendering)\n- 2022: Automatic batching in React 18\n- 2024: React Compiler (automatic optimization)\n- 2025+: React Compiler expected to replace manual memoization\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: Premature Memoization\n\n**Novice thinking**: \"Wrap everything in useMemo for speed\"\n\n**Problem**: Adds complexity and overhead for negligible gains.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Over-optimization\nfunction UserCard({ user }) {\n  const fullName = useMemo(() => `${user.first} ${user.last}`, [user]);\n  const age = useMemo(() => new Date().getFullYear() - user.birthYear, [user]);\n\n  return <div>{fullName}, {age}</div>;\n}\n```\n\n**Why wrong**: String concatenation is faster than useMemo overhead.\n\n**Correct approach**:\n```typescript\n// ‚úÖ Simple is fast\nfunction UserCard({ user }) {\n  const fullName = `${user.first} ${user.last}`;\n  const age = new Date().getFullYear() - user.birthYear;\n\n  return <div>{fullName}, {age}</div>;\n}\n```\n\n**Rule of thumb**: Only memoize if:\n1. Computation takes &gt;5ms (use Profiler to measure)\n2. Result used in dependency array\n3. Prevents child re-renders\n\n---\n\n### Anti-Pattern 2: Not Memoizing Callbacks\n\n**Problem**: New function instance on every render breaks React.memo.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Child re-renders on every parent render\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <Child onUpdate={() => setCount(count + 1)} />\n  );\n}\n\nconst Child = React.memo(({ onUpdate }) => {\n  return <button onClick={onUpdate}>Update</button>;\n});\n```\n\n**Why wrong**: Arrow function creates new reference ‚Üí React.memo useless.\n\n**Correct approach**:\n```typescript\n// ‚úÖ Stable callback reference\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  const handleUpdate = useCallback(() => {\n    setCount(c => c + 1);  // Updater function avoids dependency\n  }, []);\n\n  return <Child onUpdate={handleUpdate} />;\n}\n\nconst Child = React.memo(({ onUpdate }) => {\n  return <button onClick={onUpdate}>Update</button>;\n});\n```\n\n---\n\n### Anti-Pattern 3: Rendering Large Lists Without Virtualization\n\n**Problem**: Rendering 1000+ DOM nodes causes lag.\n\n**Symptom**: Scrolling feels janky, initial render slow.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Renders all 10,000 items\nfunction UserList({ users }) {\n  return (\n    <div>\n      {users.map(user => (\n        <UserCard key={user.id} user={user} />\n      ))}\n    </div>\n  );\n}\n```\n\n**Correct approach**:\n```typescript\n// ‚úÖ Only renders visible items\nimport { FixedSizeList } from 'react-window';\n\nfunction UserList({ users }) {\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={users.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {({ index, style }) => (\n        <div style={style}>\n          <UserCard user={users[index]} />\n        </div>\n      )}\n    </FixedSizeList>\n  );\n}\n```\n\n**Impact**: 10,000 items: 5 seconds ‚Üí 50ms render time.\n\n---\n\n### Anti-Pattern 4: No Code Splitting\n\n**Problem**: 2MB bundle downloaded upfront, slow initial load.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Everything in main bundle\nimport AdminPanel from './AdminPanel';  // 500KB\nimport Dashboard from './Dashboard';\nimport Settings from './Settings';\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/admin\" element={<AdminPanel />} />\n      <Route path=\"/dashboard\" element={<Dashboard />} />\n      <Route path=\"/settings\" element={<Settings />} />\n    </Routes>\n  );\n}\n```\n\n**Correct approach**:\n```typescript\n// ‚úÖ Lazy load routes\nimport { lazy, Suspense } from 'react';\n\nconst AdminPanel = lazy(() => import('./AdminPanel'));\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Settings = lazy(() => import('./Settings'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <Routes>\n        <Route path=\"/admin\" element={<AdminPanel />} />\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/settings\" element={<Settings />} />\n      </Routes>\n    </Suspense>\n  );\n}\n```\n\n**Impact**: Initial bundle: 2MB ‚Üí 300KB.\n\n---\n\n### Anti-Pattern 5: Expensive Operations in Render\n\n**Problem**: Heavy computation on every render.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Sorts on every render (even when data unchanged)\nfunction ProductList({ products }) {\n  const sorted = products.sort((a, b) => b.price - a.price);\n\n  return <div>{sorted.map(p => <Product product={p} />)}</div>;\n}\n```\n\n**Correct approach**:\n```typescript\n// ‚úÖ Memoize expensive operation\nfunction ProductList({ products }) {\n  const sorted = useMemo(\n    () => [...products].sort((a, b) => b.price - a.price),\n    [products]\n  );\n\n  return <div>{sorted.map(p => <Product product={p} />)}</div>;\n}\n```\n\n---\n\n## Implementation Patterns\n\n### Pattern 1: React.memo for Pure Components\n\n```typescript\n// Prevent re-render when props unchanged\nconst ExpensiveComponent = React.memo(({ data }) => {\n  // Complex rendering logic\n  return <div>{/* ... */}</div>;\n});\n\n// With custom comparison\nconst UserCard = React.memo(\n  ({ user }) => <div>{user.name}</div>,\n  (prevProps, nextProps) => {\n    // Return true if props equal (skip re-render)\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n```\n\n### Pattern 2: useMemo for Expensive Calculations\n\n```typescript\nfunction DataTable({ rows, columns }) {\n  const sortedAndFiltered = useMemo(() => {\n    console.log('Recomputing...');  // Only logs when rows/columns change\n\n    return rows\n      .filter(row => row.visible)\n      .sort((a, b) => a.timestamp - b.timestamp);\n  }, [rows, columns]);\n\n  return <Table data={sortedAndFiltered} />;\n}\n```\n\n### Pattern 3: useCallback for Stable References\n\n```typescript\nfunction SearchBox({ onSearch }) {\n  const [query, setQuery] = useState('');\n\n  // Stable reference, doesn't break child memoization\n  const handleSubmit = useCallback(() => {\n    onSearch(query);\n  }, [query, onSearch]);\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input value={query} onChange={e => setQuery(e.target.value)} />\n    </form>\n  );\n}\n```\n\n### Pattern 4: Virtualization (react-window)\n\n```typescript\nimport { VariableSizeList } from 'react-window';\n\nfunction MessageList({ messages }) {\n  const getItemSize = (index) => {\n    // Dynamic heights based on content\n    return messages[index].text.length > 100 ? 80 : 50;\n  };\n\n  return (\n    <VariableSizeList\n      height={600}\n      itemCount={messages.length}\n      itemSize={getItemSize}\n      width=\"100%\"\n    >\n      {({ index, style }) => (\n        <div style={style}>\n          <Message message={messages[index]} />\n        </div>\n      )}\n    </VariableSizeList>\n  );\n}\n```\n\n### Pattern 5: Code Splitting with React.lazy\n\n```typescript\n// Route-based splitting\nconst routes = [\n  { path: '/home', component: lazy(() => import('./Home')) },\n  { path: '/about', component: lazy(() => import('./About')) },\n  { path: '/contact', component: lazy(() => import('./Contact')) }\n];\n\n// Component-based splitting\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nfunction Dashboard() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>Show Chart</button>\n\n      {showChart && (\n        <Suspense fallback={<Spinner />}>\n          <HeavyChart />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n```\n\n---\n\n## Production Checklist\n\n```\n‚ñ° Profiler analysis completed (identified slow components)\n‚ñ° Large lists use virtualization (&gt;100 items)\n‚ñ° Routes code-split with React.lazy\n‚ñ° Heavy components lazy-loaded\n‚ñ° Callbacks memoized with useCallback\n‚ñ° Expensive computations use useMemo\n‚ñ° Pure components wrapped in React.memo\n‚ñ° Bundle analyzed (no duplicate dependencies)\n‚ñ° Tree-shaking enabled (ESM imports)\n‚ñ° Images optimized and lazy-loaded\n‚ñ° Lighthouse score &gt;90\n‚ñ° Time to Interactive &lt;3 seconds\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Optimize? |\n|----------|-----------|\n| Rendering 1000+ list items | ‚úÖ Yes - virtualize |\n| Sorting/filtering large arrays | ‚úÖ Yes - useMemo |\n| Passing callbacks to memoized children | ‚úÖ Yes - useCallback |\n| String concatenation | ‚ùå No - fast enough |\n| Simple arithmetic | ‚ùå No - don't memoize |\n| 10-item list | ‚ùå No - premature optimization |\n\n---\n\n## References\n\n- `/references/profiling-guide.md` - How to use React DevTools Profiler\n- `/references/bundle-optimization.md` - Reduce bundle size strategies\n- `/references/memory-leaks.md` - Detect and fix memory leaks\n\n## Scripts\n\n- `scripts/performance_audit.ts` - Automated performance checks\n- `scripts/bundle_analyzer.sh` - Analyze and visualize bundle\n\n---\n\n**This skill guides**: React performance optimization | Memoization | Virtualization | Code splitting | Bundle optimization | Profiling\n\n"
    }
  ]
}