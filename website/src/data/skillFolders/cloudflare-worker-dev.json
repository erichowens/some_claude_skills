{
  "name": "cloudflare-worker-dev",
  "type": "folder",
  "path": "cloudflare-worker-dev",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "cloudflare-worker-dev/references",
      "children": []
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "cloudflare-worker-dev/scripts",
      "children": []
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "cloudflare-worker-dev/SKILL.md",
      "size": 12901,
      "content": "---\nname: cloudflare-worker-dev\ndescription: Cloudflare Workers, KV, Durable Objects, and edge computing development. Use for serverless APIs, caching, rate limiting, real-time features. Activate on \"Workers\", \"KV\", \"Durable Objects\", \"wrangler\", \"edge function\", \"Cloudflare\". NOT for Cloudflare Pages configuration (use deployment docs), DNS management, or general CDN settings.\nallowed-tools: Read,Write,Edit,Bash,Grep,Glob\n---\n\n# Cloudflare Workers Development\n\nBuild high-performance edge APIs with Workers, KV for caching, and Durable Objects for real-time coordination.\n\n## Core Architecture\n\n### When to Use What\n\n| Service | Use Case | Characteristics |\n|---------|----------|-----------------|\n| **Workers** | Request handling, API logic | Stateless, 50ms CPU (free), 30s (paid) |\n| **KV** | Caching, config, sessions | Eventually consistent, fast reads |\n| **Durable Objects** | Real-time, coordination | Strongly consistent, single-threaded |\n| **R2** | File storage | S3-compatible, no egress fees |\n| **D1** | SQLite at edge | Serverless SQL, good for reads |\n\n## Worker Fundamentals\n\n### Basic Worker Structure\n\n```typescript\n// src/index.ts\nexport interface Env {\n  MEETING_CACHE: KVNamespace;\n  RATE_LIMIT: KVNamespace;\n  API_KEY: string;\n}\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    const url = new URL(request.url);\n\n    // CORS handling\n    if (request.method === 'OPTIONS') {\n      return handleCORS();\n    }\n\n    try {\n      // Route handling\n      if (url.pathname === '/health') {\n        return json({ status: 'ok' });\n      }\n\n      if (url.pathname.startsWith('/api/')) {\n        return handleAPI(request, env, ctx);\n      }\n\n      return new Response('Not Found', { status: 404 });\n    } catch (error) {\n      console.error('Worker error:', error);\n      return json({ error: 'Internal error' }, 500);\n    }\n  },\n\n  // Cron trigger\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    ctx.waitUntil(runScheduledTask(env));\n  }\n};\n```\n\n### CORS Headers (Essential)\n\n```typescript\nconst CORS_HEADERS = {\n  'Access-Control-Allow-Origin': '*', // Or specific origin\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n  'Access-Control-Max-Age': '86400',\n};\n\nfunction handleCORS(): Response {\n  return new Response(null, { status: 204, headers: CORS_HEADERS });\n}\n\nfunction json(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      ...CORS_HEADERS,\n      'Content-Type': 'application/json',\n    },\n  });\n}\n```\n\n### wrangler.toml Configuration\n\n```toml\nname = \"my-worker\"\nmain = \"src/index.ts\"\ncompatibility_date = \"2024-01-01\"\n\n# KV Namespaces\n[[kv_namespaces]]\nbinding = \"MEETING_CACHE\"\nid = \"abc123...\"  # Production\npreview_id = \"def456...\"  # Dev\n\n[[kv_namespaces]]\nbinding = \"RATE_LIMIT\"\nid = \"ghi789...\"\n\n# Environment variables\n[vars]\nCACHE_TTL = \"86400\"\nRATE_LIMIT_REQUESTS = \"100\"\nRATE_LIMIT_WINDOW = \"3600\"\n\n# Secrets (set via `wrangler secret put`)\n# API_KEY, DATABASE_URL, etc.\n\n# Cron triggers\n[triggers]\ncrons = [\"0 */6 * * *\"]  # Every 6 hours\n\n# Custom routes\n# routes = [{ pattern = \"api.example.com/*\", zone_name = \"example.com\" }]\n```\n\n## KV Storage Patterns\n\n### Basic KV Operations\n\n```typescript\n// Write with TTL\nawait env.CACHE.put('key', JSON.stringify(data), {\n  expirationTtl: 86400, // 24 hours in seconds\n});\n\n// Write with metadata\nawait env.CACHE.put('key', value, {\n  expirationTtl: 3600,\n  metadata: { createdAt: Date.now(), source: 'api' },\n});\n\n// Read\nconst value = await env.CACHE.get('key');\nconst parsed = await env.CACHE.get('key', 'json');\n\n// Read with metadata\nconst { value, metadata } = await env.CACHE.getWithMetadata('key', 'json');\n\n// Delete\nawait env.CACHE.delete('key');\n\n// List keys\nconst { keys, cursor } = await env.CACHE.list({ prefix: 'meetings:' });\n```\n\n### Geohash-Based Caching\n\n```typescript\nimport Geohash from 'latlon-geohash';\n\nfunction getCacheKey(lat: number, lng: number, radius: number): string {\n  // 3-char geohash = ~150km cells, good for metro areas\n  const geohash = Geohash.encode(lat, lng, 3);\n  return `meetings:${geohash}:${radius}`;\n}\n\nasync function getMeetingsWithCache(\n  lat: number,\n  lng: number,\n  radius: number,\n  env: Env\n): Promise<{ data: Meeting[]; cached: boolean; geohash: string }> {\n  const geohash = Geohash.encode(lat, lng, 3);\n  const cacheKey = `meetings:${geohash}:${radius}`;\n\n  // Try cache first\n  const cached = await env.MEETING_CACHE.get(cacheKey, 'json');\n  if (cached) {\n    return { data: cached, cached: true, geohash };\n  }\n\n  // Fetch fresh data\n  const data = await fetchMeetings(lat, lng, radius);\n\n  // Cache in background (don't await)\n  env.ctx.waitUntil(\n    env.MEETING_CACHE.put(cacheKey, JSON.stringify(data), {\n      expirationTtl: 86400,\n      metadata: { cachedAt: Date.now(), geohash },\n    })\n  );\n\n  return { data, cached: false, geohash };\n}\n```\n\n### Response Headers for Cache Debugging\n\n```typescript\nfunction meetingsResponse(data: Meeting[], cached: boolean, geohash: string): Response {\n  return new Response(JSON.stringify(data), {\n    headers: {\n      ...CORS_HEADERS,\n      'Content-Type': 'application/json',\n      'X-Cache': cached ? 'HIT' : 'MISS',\n      'X-Geohash': geohash,\n      'Cache-Control': 'public, max-age=3600',\n    },\n  });\n}\n```\n\n## Rate Limiting\n\n### IP-Based Rate Limiting\n\n```typescript\ninterface RateLimitConfig {\n  maxRequests: number;\n  windowSeconds: number;\n}\n\nasync function checkRateLimit(\n  ip: string,\n  env: Env,\n  config: RateLimitConfig\n): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {\n  const key = `rate:${ip}`;\n  const now = Math.floor(Date.now() / 1000);\n  const windowStart = now - config.windowSeconds;\n\n  // Get current state\n  const stored = await env.RATE_LIMIT.get(key, 'json') as {\n    count: number;\n    windowStart: number;\n  } | null;\n\n  // New window or expired\n  if (!stored || stored.windowStart < windowStart) {\n    await env.RATE_LIMIT.put(key, JSON.stringify({\n      count: 1,\n      windowStart: now,\n    }), { expirationTtl: config.windowSeconds });\n\n    return {\n      allowed: true,\n      remaining: config.maxRequests - 1,\n      resetAt: now + config.windowSeconds,\n    };\n  }\n\n  // Within window\n  if (stored.count >= config.maxRequests) {\n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: stored.windowStart + config.windowSeconds,\n    };\n  }\n\n  // Increment\n  await env.RATE_LIMIT.put(key, JSON.stringify({\n    count: stored.count + 1,\n    windowStart: stored.windowStart,\n  }), { expirationTtl: config.windowSeconds });\n\n  return {\n    allowed: true,\n    remaining: config.maxRequests - stored.count - 1,\n    resetAt: stored.windowStart + config.windowSeconds,\n  };\n}\n\n// Usage in handler\nasync function handleAPI(request: Request, env: Env): Promise<Response> {\n  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';\n  const rateLimit = await checkRateLimit(ip, env, {\n    maxRequests: parseInt(env.RATE_LIMIT_REQUESTS || '100'),\n    windowSeconds: parseInt(env.RATE_LIMIT_WINDOW || '3600'),\n  });\n\n  if (!rateLimit.allowed) {\n    return json({ error: 'Rate limit exceeded' }, 429, {\n      'X-RateLimit-Remaining': '0',\n      'X-RateLimit-Reset': rateLimit.resetAt.toString(),\n    });\n  }\n\n  // ... handle request\n}\n```\n\n## Durable Objects (Real-Time)\n\n### Chat Room Example\n\n```typescript\n// wrangler.toml\n// [[durable_objects.bindings]]\n// name = \"CHAT_ROOMS\"\n// class_name = \"ChatRoom\"\n// [[migrations]]\n// tag = \"v1\"\n// new_classes = [\"ChatRoom\"]\n\nexport class ChatRoom {\n  state: DurableObjectState;\n  sessions: WebSocket[] = [];\n\n  constructor(state: DurableObjectState) {\n    this.state = state;\n  }\n\n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n\n    if (url.pathname === '/websocket') {\n      if (request.headers.get('Upgrade') !== 'websocket') {\n        return new Response('Expected WebSocket', { status: 400 });\n      }\n\n      const [client, server] = Object.values(new WebSocketPair());\n\n      server.accept();\n      this.sessions.push(server);\n\n      server.addEventListener('message', (event) => {\n        this.broadcast(event.data as string, server);\n      });\n\n      server.addEventListener('close', () => {\n        this.sessions = this.sessions.filter(s => s !== server);\n      });\n\n      return new Response(null, { status: 101, webSocket: client });\n    }\n\n    return new Response('Not found', { status: 404 });\n  }\n\n  broadcast(message: string, exclude?: WebSocket) {\n    this.sessions.forEach(session => {\n      if (session !== exclude && session.readyState === WebSocket.OPEN) {\n        session.send(message);\n      }\n    });\n  }\n}\n\n// In main worker\nexport default {\n  async fetch(request: Request, env: Env) {\n    const url = new URL(request.url);\n\n    if (url.pathname.startsWith('/room/')) {\n      const roomId = url.pathname.split('/')[2];\n      const id = env.CHAT_ROOMS.idFromName(roomId);\n      const room = env.CHAT_ROOMS.get(id);\n      return room.fetch(request);\n    }\n  }\n};\n```\n\n## Deployment & Debugging\n\n### Commands\n\n```bash\n# Development\nnpx wrangler dev                    # Local dev server\nnpx wrangler dev --remote           # Dev against real KV/DO\n\n# Deployment\nnpx wrangler deploy                 # Deploy to production\nnpx wrangler deploy --env staging   # Deploy to staging\n\n# Secrets\nnpx wrangler secret put API_KEY     # Set secret\nnpx wrangler secret list            # List secrets\n\n# KV Management\nnpx wrangler kv:key list --namespace-id=xxx\nnpx wrangler kv:key get --namespace-id=xxx \"key\"\nnpx wrangler kv:key delete --namespace-id=xxx \"key\"\n\n# Logs\nnpx wrangler tail                   # Real-time logs\nnpx wrangler tail --format=pretty   # Formatted output\n```\n\n### Error Codes\n\n| Code | Meaning |\n|------|---------|\n| 1101 | Worker threw exception |\n| 1102 | CPU time limit exceeded |\n| 1015 | Rate limited by Cloudflare |\n| 524 | Origin timeout (&gt;100s) |\n\n## Quick Reference\n\n```typescript\n// Get client IP\nconst ip = request.headers.get('CF-Connecting-IP');\n\n// Get country\nconst country = request.cf?.country;\n\n// Background task (won't block response)\nctx.waitUntil(doBackgroundWork());\n\n// Streaming response\nreturn new Response(readableStream, {\n  headers: { 'Content-Type': 'text/event-stream' }\n});\n\n// Proxy request\nconst response = await fetch(upstreamUrl, request);\nreturn new Response(response.body, response);\n```\n\n## Anti-Patterns\n\n### ❌ Awaiting KV writes in hot path\n\n```typescript\n// ❌ ANTI-PATTERN: Blocks response on cache write\nasync function handler(request: Request, env: Env) {\n  const data = await fetchData();\n  await env.CACHE.put('key', data);  // Unnecessary wait!\n  return json(data);\n}\n\n// ✅ CORRECT: Background write with waitUntil\nasync function handler(request: Request, env: Env, ctx: ExecutionContext) {\n  const data = await fetchData();\n  ctx.waitUntil(env.CACHE.put('key', data));  // Non-blocking\n  return json(data);\n}\n```\n\n### ❌ Missing CORS handling\n\n```typescript\n// ❌ ANTI-PATTERN: No preflight handling = broken browser requests\nexport default {\n  async fetch(request: Request) {\n    return json({ data: 'hello' });  // OPTIONS requests fail!\n  }\n}\n\n// ✅ CORRECT: Handle OPTIONS preflight\nexport default {\n  async fetch(request: Request) {\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { status: 204, headers: CORS_HEADERS });\n    }\n    return json({ data: 'hello' });\n  }\n}\n```\n\n### ❌ Secrets in wrangler.toml\n\n```toml\n# ❌ ANTI-PATTERN: Secrets in config (committed to git!)\n[vars]\nAPI_KEY = \"sk-live-xxxxx\"\n\n# ✅ CORRECT: Use wrangler secret\n# Run: npx wrangler secret put API_KEY\n# Access: env.API_KEY\n```\n\n### ❌ Ignoring KV eventual consistency\n\n```typescript\n// ❌ ANTI-PATTERN: Read immediately after write\nawait env.KV.put('count', String(newCount));\nconst verify = await env.KV.get('count');  // May return old value!\n\n// ✅ CORRECT: Trust write succeeded, or use Durable Objects for consistency\nawait env.KV.put('count', String(newCount));\nreturn json({ count: newCount });  // Return what you wrote\n```\n\n### ❌ Blocking on external APIs without timeout\n\n```typescript\n// ❌ ANTI-PATTERN: External API can hang your worker\nconst data = await fetch('https://slow-api.com/data');\n\n// ✅ CORRECT: Add timeout with AbortController\nconst controller = new AbortController();\nconst timeout = setTimeout(() => controller.abort(), 5000);\ntry {\n  const data = await fetch('https://slow-api.com/data', {\n    signal: controller.signal\n  });\n} finally {\n  clearTimeout(timeout);\n}\n```\n\n## References\n\nSee `/references/` for detailed guides:\n- `kv-patterns.md` - Advanced KV usage patterns\n- `durable-objects.md` - Real-time features with DO\n- `debugging.md` - Troubleshooting common issues\n"
    }
  ]
}