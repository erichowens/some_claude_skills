{
  "name": "physics-rendering-expert",
  "type": "folder",
  "path": "physics-rendering-expert",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "physics-rendering-expert/references",
      "children": [
        {
          "name": "core-algorithms.md",
          "type": "file",
          "path": "physics-rendering-expert/references/core-algorithms.md",
          "size": 3045,
          "content": "# Core Physics Algorithms\n\nDetailed implementations for PBD, Verlet, and constraint solvers.\n\n## Position-Based Dynamics (PBD) Loop\n\n```cpp\nvoid pbd_update(float dt) {\n    // Step 1: Predict\n    for (auto& p : particles) {\n        if (p.inverse_mass == 0.0f) continue;\n        p.velocity += gravity * dt;\n        p.predicted = p.position + p.velocity * dt;\n    }\n\n    // Step 2: Solve constraints (5-10 iterations)\n    for (int i = 0; i < solver_iterations; ++i) {\n        solve_distance_constraints();\n        solve_bending_constraints();\n        solve_collisions();\n    }\n\n    // Step 3: Update\n    for (auto& p : particles) {\n        p.velocity = (p.predicted - p.position) / dt;\n        p.position = p.predicted;\n    }\n}\n```\n\n## Distance Constraint\n\n```cpp\nvoid solve_distance(Particle& p1, Particle& p2, float rest_length) {\n    vec3 delta = p2.predicted - p1.predicted;\n    float dist = length(delta);\n    if (dist < 1e-6f) return;\n\n    float error = dist - rest_length;\n    float w_sum = p1.inverse_mass + p2.inverse_mass;\n    if (w_sum < 1e-6f) return;\n\n    vec3 correction = (error / (dist * w_sum)) * delta;\n    p1.predicted += p1.inverse_mass * correction;\n    p2.predicted -= p2.inverse_mass * correction;\n}\n```\n\n## Verlet Integration\n\n**Why Verlet > Euler:**\n- Symplectic (conserves energy)\n- Second-order accurate\n- No explicit velocity storage needed\n- Time-reversible\n\n```cpp\nvoid verlet_step(Particle& p, vec3 accel, float dt) {\n    vec3 new_pos = 2.0f * p.position - p.prev_position + accel * dt * dt;\n    p.prev_position = p.position;\n    p.position = new_pos;\n    // Velocity if needed: (position - prev_position) / dt\n}\n```\n\n## Solver Comparison\n\n| Solver | Parallelizable | Convergence | Use Case |\n|--------|---------------|-------------|----------|\n| **Gauss-Seidel** | No | Fast | Chains, ropes (sequential structure) |\n| **Jacobi** | Yes (GPU) | Slower | Large meshes, cloth, GPU physics |\n\n**Gauss-Seidel**: Updates positions immediately; next constraint sees updated values.\n\n**Jacobi**: Accumulates corrections; applies averaged result. Requires more iterations but GPU-parallelizable.\n\n## Quaternion Operations\n\n**Why quaternions:**\n- No gimbal lock\n- Compact (4 floats vs 9 for matrix)\n- Smooth SLERP interpolation\n- Stable composition\n\n**Key operations:**\n- `q * q'` = compose rotations\n- `q * v * q*` = rotate vector\n- `normalize(q)` = after every operation\n- `slerp(q1, q2, t)` = smooth interpolation\n\n## Force-Based vs PBD\n\n```cpp\n// BAD: Force-based (requires tiny timesteps)\nvec3 force = normalize(delta) * k * (distance - rest_length);\n\n// GOOD: PBD constraint (stable at any timestep)\nfloat error = distance - rest_length;\nvec3 correction = (error / (distance * (w1 + w2))) * delta;\np1.position += w1 * correction;\np2.position -= w2 * correction;\n```\n\n## XPBD Compliance\n\nExtended PBD adds compliance for soft constraints:\n\n```cpp\n// XPBD with compliance\nfloat alpha = compliance / (dt * dt);\nfloat lambda = error / (w_sum + alpha);\n```\n\nThis allows controlling stiffness without changing iteration count.\n"
        },
        {
          "name": "implementations.md",
          "type": "file",
          "path": "physics-rendering-expert/references/implementations.md",
          "size": 22720,
          "content": "# Physics Implementation Reference\n\nDetailed code implementations for rope/cable physics simulation.\n\n## Complete PBD Rope Implementation\n\n```cpp\n#include <vector>\n#include <glm/glm.hpp>\n\nstruct Particle {\n    glm::vec3 position;\n    glm::vec3 predicted_position;\n    glm::vec3 velocity;\n    float mass;\n    float inverse_mass;  // Precomputed 1/mass (or 0 for static)\n\n    Particle(glm::vec3 pos, float m)\n        : position(pos), predicted_position(pos), velocity(0.0f), mass(m)\n    {\n        inverse_mass = (m > 0.0f) ? 1.0f / m : 0.0f;\n    }\n};\n\nclass RopeSimulation {\nprivate:\n    std::vector<Particle> particles;\n    std::vector<std::pair<int, int>> distance_constraints;\n    std::vector<float> rest_lengths;\n\n    float gravity = -9.81f;\n    float damping = 0.99f;\n    int solver_iterations = 5;\n\npublic:\n    RopeSimulation(glm::vec3 start, glm::vec3 end, int num_particles) {\n        for (int i = 0; i < num_particles; ++i) {\n            float t = static_cast<float>(i) / (num_particles - 1);\n            glm::vec3 pos = glm::mix(start, end, t);\n            particles.emplace_back(pos, 1.0f);\n\n            if (i == 0) particles[i].inverse_mass = 0.0f; // Fixed\n        }\n\n        for (int i = 0; i < num_particles - 1; ++i) {\n            distance_constraints.emplace_back(i, i + 1);\n            float length = glm::length(particles[i + 1].position - particles[i].position);\n            rest_lengths.push_back(length);\n        }\n    }\n\n    void update(float dt) {\n        // Step 1: Predict positions\n        for (auto& p : particles) {\n            if (p.inverse_mass == 0.0f) continue;\n            glm::vec3 acceleration(0.0f, gravity, 0.0f);\n            p.velocity += acceleration * dt;\n            p.velocity *= damping;\n            p.predicted_position = p.position + p.velocity * dt;\n        }\n\n        // Step 2: Solve constraints\n        for (int iter = 0; iter < solver_iterations; ++iter) {\n            solve_distance_constraints();\n            solve_collision_constraints();\n            solve_bending_constraints();\n        }\n\n        // Step 3: Update velocities and positions\n        for (auto& p : particles) {\n            if (p.inverse_mass == 0.0f) continue;\n            p.velocity = (p.predicted_position - p.position) / dt;\n            p.position = p.predicted_position;\n        }\n    }\n\n    void solve_distance_constraints() {\n        for (size_t i = 0; i < distance_constraints.size(); ++i) {\n            int idx1 = distance_constraints[i].first;\n            int idx2 = distance_constraints[i].second;\n            Particle& p1 = particles[idx1];\n            Particle& p2 = particles[idx2];\n\n            glm::vec3 delta = p2.predicted_position - p1.predicted_position;\n            float distance = glm::length(delta);\n            if (distance < 1e-6f) continue;\n\n            float constraint_error = distance - rest_lengths[i];\n            float w_sum = p1.inverse_mass + p2.inverse_mass;\n            if (w_sum < 1e-6f) continue;\n\n            glm::vec3 correction = (constraint_error / (distance * w_sum)) * delta;\n            p1.predicted_position += p1.inverse_mass * correction;\n            p2.predicted_position -= p2.inverse_mass * correction;\n        }\n    }\n\n    void solve_collision_constraints() {\n        float ground_y = 0.0f;\n        for (auto& p : particles) {\n            if (p.predicted_position.y < ground_y) {\n                p.predicted_position.y = ground_y;\n                p.velocity.y = 0.0f;\n                p.velocity.x *= 0.8f;\n                p.velocity.z *= 0.8f;\n            }\n        }\n    }\n\n    void solve_bending_constraints() {\n        for (size_t i = 1; i < particles.size() - 1; ++i) {\n            Particle& p_prev = particles[i - 1];\n            Particle& p_curr = particles[i];\n            Particle& p_next = particles[i + 1];\n\n            glm::vec3 v1 = p_curr.predicted_position - p_prev.predicted_position;\n            glm::vec3 v2 = p_next.predicted_position - p_curr.predicted_position;\n\n            float len1 = glm::length(v1);\n            float len2 = glm::length(v2);\n            if (len1 < 1e-6f || len2 < 1e-6f) continue;\n\n            glm::vec3 n1 = v1 / len1;\n            glm::vec3 n2 = v2 / len2;\n            float cos_angle = glm::dot(n1, n2);\n            float desired_cos = 0.5f;  // ~60 degrees max bend\n\n            if (cos_angle < desired_cos) {\n                glm::vec3 axis = glm::cross(n1, n2);\n                float axis_len = glm::length(axis);\n                if (axis_len > 1e-6f) {\n                    axis /= axis_len;\n                    p_curr.predicted_position += axis * 0.1f;\n                }\n            }\n        }\n    }\n\n    const std::vector<Particle>& get_particles() const { return particles; }\n};\n```\n\n## Quaternion Implementation\n\n```cpp\nstruct Quaternion {\n    float x, y, z, w;\n\n    static Quaternion identity() { return {0.0f, 0.0f, 0.0f, 1.0f}; }\n\n    static Quaternion from_axis_angle(glm::vec3 axis, float angle) {\n        float half_angle = angle * 0.5f;\n        float s = std::sin(half_angle);\n        return {axis.x * s, axis.y * s, axis.z * s, std::cos(half_angle)};\n    }\n\n    Quaternion operator*(const Quaternion& q) const {\n        return {\n            w * q.x + x * q.w + y * q.z - z * q.y,\n            w * q.y - x * q.z + y * q.w + z * q.x,\n            w * q.z + x * q.y - y * q.x + z * q.w,\n            w * q.w - x * q.x - y * q.y - z * q.z\n        };\n    }\n\n    glm::vec3 rotate(glm::vec3 v) const {\n        Quaternion v_quat = {v.x, v.y, v.z, 0.0f};\n        Quaternion result = (*this) * v_quat * conjugate();\n        return {result.x, result.y, result.z};\n    }\n\n    Quaternion conjugate() const { return {-x, -y, -z, w}; }\n\n    void normalize() {\n        float len = std::sqrt(x*x + y*y + z*z + w*w);\n        x /= len; y /= len; z /= len; w /= len;\n    }\n};\n```\n\n## Dual Quaternion (Rotation + Translation)\n\n```cpp\nstruct DualQuaternion {\n    Quaternion real;  // Rotation\n    Quaternion dual;  // Translation (encoded)\n\n    static DualQuaternion from_rotation_translation(Quaternion rotation, glm::vec3 translation) {\n        Quaternion t_quat = {translation.x, translation.y, translation.z, 0.0f};\n        Quaternion dual_part = (t_quat * rotation) * 0.5f;\n        return {rotation, dual_part};\n    }\n\n    glm::vec3 transform_point(glm::vec3 p) const {\n        Quaternion t_quat = (dual * 2.0f) * real.conjugate();\n        glm::vec3 translation = {t_quat.x, t_quat.y, t_quat.z};\n        return real.rotate(p) + translation;\n    }\n\n    static DualQuaternion blend(const std::vector<DualQuaternion>& dqs,\n                                 const std::vector<float>& weights) {\n        DualQuaternion result = {{0,0,0,0}, {0,0,0,0}};\n        for (size_t i = 0; i < dqs.size(); ++i) {\n            float sign = (i > 0 && dot(dqs[i].real, dqs[0].real) < 0) ? -1.0f : 1.0f;\n            result.real.x += weights[i] * sign * dqs[i].real.x;\n            result.real.y += weights[i] * sign * dqs[i].real.y;\n            result.real.z += weights[i] * sign * dqs[i].real.z;\n            result.real.w += weights[i] * sign * dqs[i].real.w;\n            result.dual.x += weights[i] * sign * dqs[i].dual.x;\n            result.dual.y += weights[i] * sign * dqs[i].dual.y;\n            result.dual.z += weights[i] * sign * dqs[i].dual.z;\n            result.dual.w += weights[i] * sign * dqs[i].dual.w;\n        }\n        result.real.normalize();\n        return result;\n    }\n};\n```\n\n## Three-Dog Leash Tangle System\n\n```cpp\nclass ThreeDogLeashSystem {\nprivate:\n    struct Dog {\n        glm::vec3 position;\n        glm::vec3 velocity;\n        int leash_id;\n    };\n\n    std::vector<Dog> dogs;\n    std::vector<RopeSimulation> leashes;\n    glm::vec3 handler_position;\n\npublic:\n    ThreeDogLeashSystem() {\n        dogs.push_back({glm::vec3(-2, 0, 0), glm::vec3(0), 0});\n        dogs.push_back({glm::vec3(0, 0, 2), glm::vec3(0), 1});\n        dogs.push_back({glm::vec3(2, 0, 0), glm::vec3(0), 2});\n        handler_position = glm::vec3(0, 1.5f, 0);\n\n        for (int i = 0; i < 3; ++i) {\n            leashes.emplace_back(handler_position, dogs[i].position, 20);\n        }\n    }\n\n    void update(float dt) {\n        // Update dog behavior\n        for (auto& dog : dogs) {\n            glm::vec3 random_accel = glm::vec3(\n                random_range(-1.0f, 1.0f), 0.0f, random_range(-1.0f, 1.0f)\n            );\n            dog.velocity += random_accel * dt;\n            dog.velocity *= 0.95f;\n            dog.position += dog.velocity * dt;\n        }\n\n        // Update leashes\n        for (size_t i = 0; i < leashes.size(); ++i) {\n            leashes[i].particles[0].position = handler_position;\n            leashes[i].particles[0].inverse_mass = 0.0f;\n            int last_idx = leashes[i].particles.size() - 1;\n            leashes[i].particles[last_idx].position = dogs[i].position;\n            leashes[i].update(dt);\n        }\n\n        detect_leash_tangles();\n    }\n\n    void detect_leash_tangles() {\n        for (size_t i = 0; i < leashes.size(); ++i) {\n            for (size_t j = i + 1; j < leashes.size(); ++j) {\n                check_leash_collision(leashes[i], leashes[j]);\n            }\n        }\n    }\n\n    float segment_segment_distance(glm::vec3 p1, glm::vec3 p2,\n                                    glm::vec3 q1, glm::vec3 q2) {\n        glm::vec3 u = p2 - p1, v = q2 - q1, w = p1 - q1;\n        float a = glm::dot(u, u), b = glm::dot(u, v), c = glm::dot(v, v);\n        float d = glm::dot(u, w), e = glm::dot(v, w);\n        float denom = a * c - b * b;\n\n        float s = (denom < 1e-6f) ? 0.0f : glm::clamp((b * e - c * d) / denom, 0.0f, 1.0f);\n        float t = (denom < 1e-6f) ? (b > c ? d / b : e / c) : glm::clamp((a * e - b * d) / denom, 0.0f, 1.0f);\n\n        return glm::length((q1 + t * v) - (p1 + s * u));\n    }\n};\n```\n\n## Jacobi Solver (GPU-Parallel)\n\n```cpp\nvoid jacobi_solve(std::vector<Constraint>& constraints,\n                  std::vector<Particle>& particles, int iterations) {\n    std::vector<glm::vec3> position_deltas(particles.size(), glm::vec3(0.0f));\n    std::vector<int> constraint_counts(particles.size(), 0);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        std::fill(position_deltas.begin(), position_deltas.end(), glm::vec3(0.0f));\n        std::fill(constraint_counts.begin(), constraint_counts.end(), 0);\n\n        #pragma omp parallel for\n        for (size_t i = 0; i < constraints.size(); ++i) {\n            auto correction = constraints[i].compute_correction();\n            #pragma omp atomic\n            position_deltas[correction.particle1_idx] += correction.delta1;\n            #pragma omp atomic\n            constraint_counts[correction.particle1_idx]++;\n            #pragma omp atomic\n            position_deltas[correction.particle2_idx] += correction.delta2;\n            #pragma omp atomic\n            constraint_counts[correction.particle2_idx]++;\n        }\n\n        #pragma omp parallel for\n        for (size_t i = 0; i < particles.size(); ++i) {\n            if (constraint_counts[i] > 0) {\n                particles[i].position += position_deltas[i] / float(constraint_counts[i]);\n            }\n        }\n    }\n}\n```\n\n## TangleConstraint Implementation (JavaScript)\n\nDynamic constraint created when rope crossings become physical tangles:\n\n```javascript\nclass TangleConstraint {\n    static nextId = 0;\n\n    constructor(particleA, particleB, ropeA, ropeB, crossingPoint, options = {}) {\n        this.id = TangleConstraint.nextId++;\n        this.particleA = particleA;\n        this.particleB = particleB;\n        this.ropeA = ropeA;\n        this.ropeB = ropeB;\n        this.crossingPoint = crossingPoint.copy();\n\n        // Physics parameters\n        this.friction = options.friction ?? 0.5;        // Capstan friction coefficient\n        this.stiffness = options.stiffness ?? 0.8;      // Constraint stiffness\n        this.maxDistance = options.maxDistance ?? 15;   // Break if exceeded\n        this.minDistance = options.minDistance ?? 2;    // Minimum (fully locked)\n\n        // Current state\n        this.restDistance = particleA.position.distanceTo(particleB.position);\n        this.restDistance = Math.max(this.minDistance, Math.min(this.restDistance, this.maxDistance));\n        this.wrapAngle = 0;                             // Accumulated wrap (radians)\n        this.tension = 0;                               // Current tension at crossing\n        this.age = 0;                                   // Frames since creation\n        this.isLocked = false;                          // Has tightened past threshold\n\n        // Thresholds\n        this.lockThreshold = this.minDistance * 2;      // Lock when rest < this\n        this.tightenRate = 0.02;                        // How fast it tightens under tension\n        this.breakTension = 200;                        // Force required to break\n    }\n\n    /**\n     * Solve the tangle constraint (call during PBD solver loop)\n     */\n    solve() {\n        const delta = this.particleB.position.subtract(this.particleA.position);\n        const dist = delta.length();\n\n        if (dist < 1e-6) return;\n\n        // Compute effective rest distance (locked tangles are tighter)\n        const effectiveRest = this.isLocked\n            ? this.restDistance * 0.5\n            : this.restDistance;\n\n        // Only pull together, don't push apart\n        if (dist <= effectiveRest) return;\n\n        const error = dist - effectiveRest;\n        const wA = this.particleA.inverseMass;\n        const wB = this.particleB.inverseMass;\n        const wSum = wA + wB;\n\n        if (wSum < 1e-6) return;\n\n        // Apply Capstan friction effect: friction amplifies with wrap angle\n        // T₂ = T₁ × e^(μθ) - but we cap it for stability\n        const frictionFactor = Math.min(Math.exp(this.friction * this.wrapAngle), 3.0);\n\n        // Compute correction with stiffness and friction\n        const correctionMag = (error * this.stiffness * frictionFactor) / (dist * wSum);\n        const correction = delta.scale(correctionMag);\n\n        // Apply corrections\n        this.particleA.position = this.particleA.position.add(correction.scale(wA));\n        this.particleB.position = this.particleB.position.subtract(correction.scale(wB));\n\n        // Record tension for tightening logic\n        this.tension = error * frictionFactor;\n    }\n\n    /**\n     * Update tangle state (call each frame after physics step)\n     */\n    update(dt) {\n        this.age++;\n\n        // Update wrap angle based on local rope geometry\n        this.wrapAngle = this._computeLocalWrapAngle();\n\n        // Tighten under tension (gradual, not instant)\n        if (this.tension > 10 && !this.isLocked) {\n            const tightenAmount = this.tightenRate * this.tension * dt;\n            this.restDistance = Math.max(\n                this.minDistance,\n                this.restDistance - tightenAmount\n            );\n        }\n\n        // Lock if tightened enough\n        if (this.restDistance < this.lockThreshold) {\n            this.isLocked = true;\n        }\n\n        // Update crossing point to midpoint\n        this.crossingPoint = this.particleA.position.add(this.particleB.position).scale(0.5);\n    }\n\n    /**\n     * Check if this tangle should break\n     */\n    shouldBreak() {\n        const dist = this.particleA.position.distanceTo(this.particleB.position);\n\n        // Break if stretched too far for too long\n        if (dist > this.maxDistance) {\n            return true;\n        }\n\n        // Locked tangles require much more force to break\n        if (this.isLocked) {\n            return this.tension > this.breakTension * 3;\n        }\n\n        // Young tangles break easily\n        if (this.age < 30) {\n            return dist > this.restDistance * 1.5;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get crossing sign for braid word tracking (+1 or -1)\n     */\n    getCrossingSign() {\n        // Determine which rope is \"over\" based on perpendicular direction\n        const delta = this.particleB.position.subtract(this.particleA.position);\n        // In 2D top-down: positive cross product = ropeA over ropeB\n        return delta.x * (this.particleA.position.y - this.crossingPoint.y) > 0 ? 1 : -1;\n    }\n\n    /**\n     * Compute local wrap angle from rope geometry\n     */\n    _computeLocalWrapAngle() {\n        // Get tangent directions of both ropes at crossing\n        const tangentA = this._getRopeTangentAt(this.ropeA, this.particleA);\n        const tangentB = this._getRopeTangentAt(this.ropeB, this.particleB);\n\n        if (!tangentA || !tangentB) return this.wrapAngle;\n\n        // Wrap angle is based on how perpendicular the ropes are\n        // Parallel = 0°, Perpendicular = 90°\n        const dot = Math.abs(tangentA.dot(tangentB));\n        const angle = Math.acos(Math.min(1, Math.max(-1, dot)));\n\n        // Smooth update (don't jump)\n        return this.wrapAngle * 0.9 + angle * 0.1;\n    }\n\n    _getRopeTangentAt(rope, particle) {\n        const idx = rope.particles.indexOf(particle);\n        if (idx < 0) return null;\n\n        const prev = rope.particles[Math.max(0, idx - 1)];\n        const next = rope.particles[Math.min(rope.particles.length - 1, idx + 1)];\n\n        return next.position.subtract(prev.position).normalize();\n    }\n}\n```\n\n### Tangle Detection and Management\n\n```javascript\nclass TangleManager {\n    constructor(world) {\n        this.world = world;\n        this.tangles = [];\n        this.tanglePairs = new Set(); // Track existing pairs\n    }\n\n    /**\n     * Detect and create new tangles (call after position prediction, before solving)\n     */\n    detectNewTangles() {\n        const ropes = this.world.ropes;\n        const ropeDiameter = 8; // Detection threshold\n\n        for (let i = 0; i < ropes.length; i++) {\n            for (let j = i + 1; j < ropes.length; j++) {\n                this._checkRopePair(ropes[i], ropes[j], ropeDiameter);\n            }\n        }\n    }\n\n    _checkRopePair(ropeA, ropeB, threshold) {\n        const particlesA = ropeA.particles;\n        const particlesB = ropeB.particles;\n\n        for (let ai = 0; ai < particlesA.length - 1; ai++) {\n            for (let bi = 0; bi < particlesB.length - 1; bi++) {\n                const result = this._checkSegmentPair(\n                    particlesA[ai], particlesA[ai + 1],\n                    particlesB[bi], particlesB[bi + 1],\n                    threshold\n                );\n\n                if (result.shouldFormTangle) {\n                    this._createTangle(\n                        result.closestA, result.closestB,\n                        ropeA, ropeB, result.crossingPoint\n                    );\n                }\n            }\n        }\n    }\n\n    _checkSegmentPair(a1, a2, b1, b2, threshold) {\n        // Segment-segment closest points\n        const result = segmentSegmentClosest(a1.position, a2.position, b1.position, b2.position);\n\n        if (result.distance > threshold) {\n            return { shouldFormTangle: false };\n        }\n\n        // Already have a tangle for these particles?\n        const pairKey = this._makePairKey(result.closestParticleA, result.closestParticleB);\n        if (this.tanglePairs.has(pairKey)) {\n            return { shouldFormTangle: false };\n        }\n\n        // Check tension direction - would pulling tighten this?\n        const tensionA = a2.position.subtract(a1.position).normalize();\n        const tensionB = b2.position.subtract(b1.position).normalize();\n        const separation = result.closestB.subtract(result.closestA).normalize();\n\n        const pullA = tensionA.dot(separation);\n        const pullB = tensionB.dot(separation.scale(-1));\n        const wouldTighten = pullA > 0.3 || pullB > 0.3;\n\n        // Check wrap angle\n        const wrapAngle = Math.acos(Math.min(1, Math.abs(tensionA.dot(tensionB))));\n        const sufficientWrap = wrapAngle > 0.5; // ~30 degrees\n\n        return {\n            shouldFormTangle: wouldTighten && sufficientWrap,\n            closestA: result.closestParticleA,\n            closestB: result.closestParticleB,\n            crossingPoint: result.closestA.add(result.closestB).scale(0.5)\n        };\n    }\n\n    _createTangle(particleA, particleB, ropeA, ropeB, crossingPoint) {\n        const tangle = new TangleConstraint(\n            particleA, particleB, ropeA, ropeB, crossingPoint\n        );\n\n        this.tangles.push(tangle);\n        this.tanglePairs.add(this._makePairKey(particleA, particleB));\n\n        // Emit event for braid tracking\n        if (this.world.onTangleFormed) {\n            this.world.onTangleFormed(tangle);\n        }\n    }\n\n    _makePairKey(pA, pB) {\n        const idA = pA.id ?? pA;\n        const idB = pB.id ?? pB;\n        return idA < idB ? `${idA}-${idB}` : `${idB}-${idA}`;\n    }\n\n    /**\n     * Solve all tangle constraints (call in PBD solver loop)\n     */\n    solveTangles() {\n        for (const tangle of this.tangles) {\n            tangle.solve();\n        }\n    }\n\n    /**\n     * Update tangles and remove broken ones (call after physics step)\n     */\n    updateTangles(dt) {\n        for (let i = this.tangles.length - 1; i >= 0; i--) {\n            const tangle = this.tangles[i];\n            tangle.update(dt);\n\n            if (tangle.shouldBreak()) {\n                this.tanglePairs.delete(\n                    this._makePairKey(tangle.particleA, tangle.particleB)\n                );\n                this.tangles.splice(i, 1);\n\n                if (this.world.onTangleBroken) {\n                    this.world.onTangleBroken(tangle);\n                }\n            }\n        }\n    }\n}\n```\n\n### Capstan Friction Utility\n\n```javascript\n/**\n * Calculate friction-amplified tension using Capstan equation\n * T₂ = T₁ × e^(μθ)\n *\n * @param tensionIn - Input tension\n * @param wrapAngle - Wrap angle in radians\n * @param mu - Friction coefficient (0.3-0.8 for rope-on-rope)\n * @returns Amplified tension\n */\nfunction capstanFriction(tensionIn, wrapAngle, mu = 0.5) {\n    return tensionIn * Math.exp(mu * wrapAngle);\n}\n\n/**\n * Example: 90° wrap with μ=0.5 gives 2.2× amplification\n * Full 360° wrap gives 23× amplification\n */\n```\n\n## Performance Benchmarks\n\n| Operation | CPU (single) | GPU |\n|-----------|-------------|-----|\n| PBD Rope (100 particles, 5 iter) | ~0.5ms | ~0.1ms |\n| Verlet Integration (1000 particles) | ~0.01ms | - |\n| Gauss-Seidel (100 constraints) | ~0.3ms | N/A |\n| Jacobi (100 constraints) | ~0.5ms | ~0.1ms |\n| Three-Dog Leash (60 particles) | ~0.7ms total | - |\n\n## References\n\n- Müller et al. (2006): \"Position Based Dynamics\"\n- Jakobsen (2001): \"Advanced Character Physics\" (GDC)\n- Baraff (1996): \"Linear-Time Dynamics using Lagrange Multipliers\"\n- Shoemake (1985): \"Animating Rotation with Quaternion Curves\"\n- Kavan et al. (2008): \"Geometric Skinning with Dual Quaternions\"\n- ALEM Method (2024 SIGGRAPH): \"Arbitrary Lagrangian-Eulerian Modal Analysis\"\n"
        },
        {
          "name": "knot-garden-physics.md",
          "type": "file",
          "path": "physics-rendering-expert/references/knot-garden-physics.md",
          "size": 28498,
          "content": "# Knot Garden Physics\n\nPhysics and rendering systems for mathematical knot visualization, Reidemeister move animation, and interactive manipulation via Pin+Pull mechanics.\n\n## Core Challenge: One-Mouse Knot Manipulation\n\nUnlike real-world knot manipulation (requiring two hands), mouse/touch interaction provides only **one point of contact**. This document defines the physics systems that make single-pointer knot manipulation feel natural.\n\n---\n\n## Pin Constraint System\n\n### The Problem\nTo untie or manipulate a knot, you need to:\n1. Hold one part steady\n2. Pull another part through/around\n\nWith one cursor, you can only do one thing at a time.\n\n### The Solution: Virtual Anchors (Pins)\n\nPins create temporary infinite-mass particles that serve as \"your other hand.\"\n\n```javascript\n/**\n * PinConstraint - A user-placed anchor point on the rope\n *\n * Unlike physical pins (which pierce rope), these are \"grip\" pins -\n * they hold a section of rope at a fixed world position.\n */\nclass PinConstraint {\n    constructor(particle, worldPosition) {\n        this.particle = particle;\n        this.anchorPosition = worldPosition.clone();\n        this.originalInverseMass = particle.inverseMass;\n\n        // Visual state\n        this.isHovered = false;\n        this.pulsePhase = 0;\n\n        // Pin immediately makes particle immovable\n        particle.inverseMass = 0;\n        particle.predicted.copy(worldPosition);\n        particle.position.copy(worldPosition);\n    }\n\n    /**\n     * Solve: Keep particle at anchor position\n     * Called during constraint solving loop\n     */\n    solve() {\n        this.particle.predicted.copy(this.anchorPosition);\n    }\n\n    /**\n     * Release: Restore original mass, allow movement\n     */\n    release() {\n        this.particle.inverseMass = this.originalInverseMass;\n        // Optionally give a small velocity push away from pin point\n        // to prevent instant re-pinning\n    }\n\n    /**\n     * Move: Drag the pin (and attached rope section)\n     */\n    move(newPosition) {\n        this.anchorPosition.copy(newPosition);\n        this.particle.predicted.copy(newPosition);\n        this.particle.position.copy(newPosition);\n    }\n}\n```\n\n### Pin Placement Rules\n\n| Rule | Implementation |\n|------|----------------|\n| Max pins | 3-5 simultaneous (prevents \"stapling\" the knot flat) |\n| Min distance | Pins must be 15+ pixels apart (prevents clustered pins) |\n| Auto-release | Pins older than 30 seconds auto-release (prevents forgotten pins) |\n| Visual feedback | Pins glow/pulse to remind user they exist |\n\n### Pin Interaction States\n\n```\nIDLE → HOVER → GRABBED → DRAGGING → RELEASED\n  │      │        │          │           │\n  │      │        │          │           └─ Pin stays, particle unfrozen\n  │      │        │          └─ Pin moves with cursor, particle follows\n  │      │        └─ Mouse down on pin, waiting for movement\n  │      └─ Cursor near existing pin\n  └─ Normal rope state\n```\n\n---\n\n## Pull Mechanics\n\n### The Grab+Drag Cycle\n\n```javascript\n/**\n * GrabState - Tracks active user manipulation of rope\n */\nclass GrabState {\n    constructor(particle, grabPoint) {\n        this.particle = particle;\n        this.grabOffset = grabPoint.sub(particle.position); // Where on particle user grabbed\n        this.grabTime = performance.now();\n        this.dragHistory = []; // For velocity calculation on release\n        this.maxDragForce = 500; // Clamp to prevent explosion\n    }\n\n    /**\n     * Update during drag - applies force toward cursor\n     */\n    update(cursorPosition, dt) {\n        const targetPosition = cursorPosition.sub(this.grabOffset);\n        const toTarget = targetPosition.sub(this.particle.position);\n        const distance = toTarget.length;\n\n        // Force scales with distance but is clamped\n        // This gives a \"rubbery\" feel - close = responsive, far = max pull\n        const forceMagnitude = Math.min(distance * 50, this.maxDragForce);\n        const force = toTarget.normalize().mul(forceMagnitude);\n\n        // Apply as acceleration (will be integrated in physics step)\n        this.particle.applyForce(force);\n\n        // Track for release velocity\n        this.dragHistory.push({ pos: cursorPosition.clone(), time: performance.now() });\n        if (this.dragHistory.length > 10) this.dragHistory.shift();\n    }\n\n    /**\n     * Release - optionally impart velocity from drag motion\n     */\n    release() {\n        if (this.dragHistory.length < 2) return;\n\n        const recent = this.dragHistory.slice(-3);\n        const dt = (recent[recent.length - 1].time - recent[0].time) / 1000;\n        if (dt < 0.001) return;\n\n        const displacement = recent[recent.length - 1].pos.sub(recent[0].pos);\n        const releaseVelocity = displacement.div(dt).mul(0.3); // Damped\n\n        this.particle.velocity.addMut(releaseVelocity);\n    }\n}\n```\n\n### Pull Behavior Near Pins\n\nWhen pulling rope that has pins placed:\n\n```\n    [PIN]────────────[GRAB]\n         ↖         ↗\n           ROPE FLOWS AROUND PIN\n\nPhysics: Rope particles between PIN and GRAB\nslide along their constraints while PIN stays fixed.\nThe PIN acts as a pulley/anchor point.\n```\n\n```javascript\n/**\n * When pulling rope with pins, the pin creates a fulcrum effect\n * Rope slides THROUGH the pin position (pin doesn't move with rope)\n */\nfunction updateRopeWithPins(rope, pins, grabState, dt) {\n    // Standard physics step\n    rope.applyGravity(gravity);\n    for (const particle of rope.particles) {\n        particle.integrate(dt);\n    }\n\n    // Constraint solving\n    for (let iter = 0; iter < SOLVER_ITERATIONS; iter++) {\n        // Distance constraints (rope stays connected)\n        for (const constraint of rope.distanceConstraints) {\n            constraint.solve();\n        }\n\n        // Pin constraints (anchors stay fixed)\n        for (const pin of pins) {\n            pin.solve();\n        }\n\n        // Grab constraint (pulled particle follows cursor)\n        if (grabState) {\n            grabState.particle.predicted.copy(grabState.targetPosition);\n        }\n    }\n}\n```\n\n---\n\n## Reidemeister Move Visualization\n\nThe three Reidemeister moves are the ONLY operations needed to transform any knot into any equivalent knot. Visualizing them clearly is the educational core of Knot Garden.\n\n### Move Detection\n\nBefore animating a move, we need to detect when the user (or algorithm) is attempting one:\n\n```javascript\n/**\n * Reidemeister Move Detector\n * Analyzes rope configuration to identify potential moves\n */\nclass ReidemeisterDetector {\n    /**\n     * Type I: Twist/Untwist\n     * Detects a loop where one strand crosses over itself\n     *\n     *     ╭─╮\n     *     │ │   ← Self-crossing loop\n     *     ╰─┼─\n     *       │\n     */\n    detectTypeI(rope) {\n        const candidates = [];\n\n        // Look for self-crossings within a small window\n        for (let i = 0; i < rope.particles.length - 4; i++) {\n            for (let j = i + 3; j < Math.min(i + 10, rope.particles.length - 1); j++) {\n                const seg1 = { start: rope.particles[i].position, end: rope.particles[i+1].position };\n                const seg2 = { start: rope.particles[j].position, end: rope.particles[j+1].position };\n\n                const intersection = Segment.segmentIntersection(seg1.start, seg1.end, seg2.start, seg2.end);\n\n                if (intersection.intersects) {\n                    // Calculate loop area - small area = tight twist\n                    const loopArea = this.calculateLoopArea(rope.particles.slice(i, j + 2));\n\n                    if (loopArea < TWIST_AREA_THRESHOLD) {\n                        candidates.push({\n                            type: 'I',\n                            startIndex: i,\n                            endIndex: j + 1,\n                            crossingPoint: intersection.point,\n                            loopArea: loopArea,\n                            // Sign: +1 for right-handed twist, -1 for left-handed\n                            sign: this.calculateTwistSign(rope.particles.slice(i, j + 2))\n                        });\n                    }\n                }\n            }\n        }\n\n        return candidates;\n    }\n\n    /**\n     * Type II: Poke/Unpoke\n     * Detects two parallel strands crossing each other twice\n     *\n     *    ╲    ╱\n     *     ╲  ╱    ← Two crossings that can cancel\n     *      ╲╱\n     *      ╱╲\n     *     ╱  ╲\n     *    ╱    ╲\n     */\n    detectTypeII(rope1, rope2) {\n        const candidates = [];\n\n        // Find all crossings between the two ropes (or two sections of same rope)\n        const crossings = this.findAllCrossings(rope1, rope2);\n\n        // Look for crossing pairs that could cancel\n        for (let i = 0; i < crossings.length; i++) {\n            for (let j = i + 1; j < crossings.length; j++) {\n                const c1 = crossings[i];\n                const c2 = crossings[j];\n\n                // Crossings must have opposite signs to cancel\n                if (c1.sign === c2.sign) continue;\n\n                // Crossings must be \"adjacent\" (no other crossings between them on either strand)\n                if (!this.areAdjacentCrossings(c1, c2, crossings)) continue;\n\n                // Distance between crossings - closer = easier to unpoke\n                const distance = c1.point.distanceTo(c2.point);\n\n                candidates.push({\n                    type: 'II',\n                    crossing1: c1,\n                    crossing2: c2,\n                    distance: distance,\n                    midpoint: c1.point.add(c2.point).div(2)\n                });\n            }\n        }\n\n        return candidates;\n    }\n\n    /**\n     * Type III: Slide\n     * Detects a strand that can slide over/under a crossing\n     *\n     *      │\n     *    ╲ │ ╱\n     *     ╲│╱     ← Third strand can slide across\n     *     ╱│╲\n     *    ╱ │ ╲\n     *      │\n     */\n    detectTypeIII(rope1, rope2, rope3) {\n        const candidates = [];\n\n        // Find the crossing between rope1 and rope2\n        const baseCrossing = this.findCrossing(rope1, rope2);\n        if (!baseCrossing) return candidates;\n\n        // Check if rope3 passes near this crossing\n        for (let i = 0; i < rope3.particles.length - 1; i++) {\n            const seg = {\n                start: rope3.particles[i].position,\n                end: rope3.particles[i+1].position\n            };\n\n            const distance = this.pointToSegmentDistance(baseCrossing.point, seg.start, seg.end);\n\n            if (distance < SLIDE_THRESHOLD) {\n                candidates.push({\n                    type: 'III',\n                    baseCrossing: baseCrossing,\n                    slidingSegment: { index: i, rope: rope3 },\n                    distance: distance\n                });\n            }\n        }\n\n        return candidates;\n    }\n}\n```\n\n### Move Animation System\n\n```javascript\n/**\n * Reidemeister Move Animator\n * Smoothly transforms rope configuration to complete a move\n */\nclass ReidemeisterAnimator {\n    constructor(rope, move) {\n        this.rope = rope;\n        this.move = move;\n        this.progress = 0;\n        this.duration = 1.0; // seconds\n        this.startPositions = [];\n        this.targetPositions = [];\n\n        // Capture start state\n        for (const p of rope.particles) {\n            this.startPositions.push(p.position.clone());\n        }\n\n        // Calculate target state based on move type\n        this.calculateTargetPositions();\n    }\n\n    calculateTargetPositions() {\n        switch (this.move.type) {\n            case 'I':\n                this.calculateTypeITarget();\n                break;\n            case 'II':\n                this.calculateTypeIITarget();\n                break;\n            case 'III':\n                this.calculateTypeIIITarget();\n                break;\n        }\n    }\n\n    /**\n     * Type I: Untwist\n     * Pull the loop straight, eliminating the crossing\n     */\n    calculateTypeITarget() {\n        const { startIndex, endIndex } = this.move;\n\n        // Start and end points of the twisted section\n        const startPos = this.startPositions[startIndex];\n        const endPos = this.startPositions[endIndex];\n\n        // Target: straight line between start and end\n        for (let i = 0; i < this.startPositions.length; i++) {\n            if (i < startIndex || i > endIndex) {\n                // Particles outside the twist stay put\n                this.targetPositions[i] = this.startPositions[i].clone();\n            } else {\n                // Particles inside the twist interpolate to straight line\n                const t = (i - startIndex) / (endIndex - startIndex);\n                this.targetPositions[i] = startPos.lerp(endPos, t);\n            }\n        }\n    }\n\n    /**\n     * Type II: Unpoke\n     * Pull the two strands apart, eliminating both crossings\n     */\n    calculateTypeIITarget() {\n        const { crossing1, crossing2 } = this.move;\n\n        // Calculate separation direction (perpendicular to strand direction)\n        const strandDir = crossing2.point.sub(crossing1.point).normalize();\n        const separationDir = new Vec2(-strandDir.y, strandDir.x);\n\n        // Move affected particles away from each other\n        // ... (complex implementation involving both ropes)\n    }\n\n    /**\n     * Update animation\n     * Returns true when complete\n     */\n    update(dt) {\n        this.progress += dt / this.duration;\n\n        if (this.progress >= 1.0) {\n            // Snap to final positions\n            for (let i = 0; i < this.rope.particles.length; i++) {\n                this.rope.particles[i].position.copy(this.targetPositions[i]);\n                this.rope.particles[i].predicted.copy(this.targetPositions[i]);\n                this.rope.particles[i].prevPosition.copy(this.targetPositions[i]);\n            }\n            return true; // Complete\n        }\n\n        // Smooth interpolation with easing\n        const easedProgress = this.easeInOutCubic(this.progress);\n\n        for (let i = 0; i < this.rope.particles.length; i++) {\n            const pos = this.startPositions[i].lerp(this.targetPositions[i], easedProgress);\n            this.rope.particles[i].position.copy(pos);\n            this.rope.particles[i].predicted.copy(pos);\n        }\n\n        return false; // Still animating\n    }\n\n    easeInOutCubic(t) {\n        return t < 0.5\n            ? 4 * t * t * t\n            : 1 - Math.pow(-2 * t + 2, 3) / 2;\n    }\n}\n```\n\n### Visual Feedback During Moves\n\n```javascript\n/**\n * Reidemeister Move Visualizer\n * Renders move in progress with educational annotations\n */\nclass ReidemeisterVisualizer {\n    /**\n     * Draw move-in-progress with highlights and labels\n     */\n    render(ctx, animator) {\n        const move = animator.move;\n        const progress = animator.progress;\n\n        // Highlight the affected region\n        this.drawAffectedRegion(ctx, move, progress);\n\n        // Draw crossing indicators\n        if (move.type === 'I') {\n            this.drawTwistIndicator(ctx, move, progress);\n        } else if (move.type === 'II') {\n            this.drawPokeIndicator(ctx, move.crossing1, move.crossing2, progress);\n        } else if (move.type === 'III') {\n            this.drawSlideIndicator(ctx, move, progress);\n        }\n\n        // Label the move type\n        const labelPos = this.getMoveCenter(move);\n        this.drawLabel(ctx, labelPos, `Reidemeister ${move.type}`, progress);\n\n        // Draw crossing count change\n        const crossingDelta = this.getCrossingDelta(move);\n        if (crossingDelta !== 0) {\n            this.drawCrossingChange(ctx, labelPos, crossingDelta, progress);\n        }\n    }\n\n    drawAffectedRegion(ctx, move, progress) {\n        ctx.save();\n\n        // Pulsing highlight\n        const alpha = 0.2 + 0.1 * Math.sin(progress * Math.PI * 4);\n        ctx.fillStyle = `rgba(255, 200, 50, ${alpha})`;\n\n        // Draw circular region around move\n        const center = this.getMoveCenter(move);\n        const radius = this.getMoveRadius(move) * (1.5 - 0.5 * progress);\n\n        ctx.beginPath();\n        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    getCrossingDelta(move) {\n        switch (move.type) {\n            case 'I': return -1;  // Removes 1 crossing\n            case 'II': return -2; // Removes 2 crossings\n            case 'III': return 0; // Crossing count unchanged\n        }\n    }\n}\n```\n\n---\n\n## Algorithmic Simplification\n\nThe \"Simplify\" button runs an algorithm to reduce the knot to minimal crossing number.\n\n### Greedy Simplification\n\n```javascript\n/**\n * Greedy Knot Simplifier\n * Repeatedly applies Reidemeister moves that reduce crossing count\n */\nclass GreedySimplifier {\n    constructor(rope) {\n        this.rope = rope;\n        this.detector = new ReidemeisterDetector();\n        this.animator = null;\n        this.moveQueue = [];\n        this.crossingCount = this.countCrossings();\n    }\n\n    /**\n     * Find all simplifying moves and execute them\n     */\n    async simplify() {\n        let improved = true;\n\n        while (improved) {\n            improved = false;\n\n            // Find Type I moves (always reduce by 1)\n            const typeI = this.detector.detectTypeI(this.rope);\n            for (const move of typeI) {\n                await this.executeMove(move);\n                improved = true;\n            }\n\n            // Find Type II moves (always reduce by 2)\n            const typeII = this.detector.detectTypeII(this.rope, this.rope);\n            for (const move of typeII) {\n                await this.executeMove(move);\n                improved = true;\n            }\n\n            // Type III moves don't change crossing count directly\n            // but may enable Type I or II moves\n            if (!improved) {\n                const typeIII = this.detector.detectTypeIII(this.rope, this.rope, this.rope);\n                if (typeIII.length > 0) {\n                    await this.executeMove(typeIII[0]);\n                    improved = true; // Try again after slide\n                }\n            }\n        }\n\n        return this.crossingCount;\n    }\n\n    async executeMove(move) {\n        return new Promise(resolve => {\n            this.animator = new ReidemeisterAnimator(this.rope, move);\n\n            const animate = () => {\n                const complete = this.animator.update(1/60);\n                if (complete) {\n                    this.crossingCount = this.countCrossings();\n                    this.animator = null;\n                    resolve();\n                } else {\n                    requestAnimationFrame(animate);\n                }\n            };\n\n            requestAnimationFrame(animate);\n        });\n    }\n}\n```\n\n### A* Search for Optimal Simplification\n\nFor finding the *shortest* sequence of moves:\n\n```javascript\n/**\n * A* Knot Simplifier\n * Finds optimal (shortest) sequence of Reidemeister moves\n *\n * State space: Knot configurations (up to ambient isotopy)\n * Operators: Reidemeister moves (I, II, III)\n * Goal: Minimize crossing number\n * Heuristic: Current crossing count (admissible since each move removes ≤2)\n */\nclass AStarSimplifier {\n    constructor(rope) {\n        this.rope = rope;\n        this.detector = new ReidemeisterDetector();\n    }\n\n    /**\n     * A* search for optimal simplification\n     */\n    findOptimalSequence() {\n        const startState = this.getKnotState();\n        const startCrossings = this.countCrossings(startState);\n\n        // Priority queue: [state, path, g-cost]\n        const frontier = new PriorityQueue((a, b) =>\n            (a.g + a.h) - (b.g + b.h)\n        );\n\n        frontier.push({\n            state: startState,\n            path: [],\n            g: 0,\n            h: startCrossings // Heuristic: crossing count\n        });\n\n        const visited = new Set();\n\n        while (!frontier.isEmpty()) {\n            const current = frontier.pop();\n\n            // Check if goal (unknot = 0 crossings, or local minimum)\n            const crossings = this.countCrossings(current.state);\n            if (crossings === 0) {\n                return current.path; // Found unknot!\n            }\n\n            // Generate canonical representation for visited check\n            const canonical = this.canonicalize(current.state);\n            if (visited.has(canonical)) continue;\n            visited.add(canonical);\n\n            // Expand: try all possible Reidemeister moves\n            const moves = this.getAllMoves(current.state);\n\n            for (const move of moves) {\n                const newState = this.applyMove(current.state, move);\n                const newCrossings = this.countCrossings(newState);\n\n                frontier.push({\n                    state: newState,\n                    path: [...current.path, move],\n                    g: current.g + 1,\n                    h: newCrossings\n                });\n            }\n        }\n\n        // No path to unknot found - knot is non-trivial\n        return null;\n    }\n}\n```\n\n---\n\n## 3D Knot Representation\n\nMathematical knots live in 3D space. Even when rendered on a 2D screen, we need proper 3D handling.\n\n### Particle Extension for 3D\n\n```javascript\n/**\n * Particle3D - Full 3D position with height/depth\n */\nclass Particle3D extends Particle {\n    constructor(x, y, z, mass = 1.0) {\n        super(x, y, mass);\n        this.z = z;\n        this.prevZ = z;\n        this.predictedZ = z;\n        this.velocityZ = 0;\n    }\n\n    integrate(dt) {\n        super.integrate(dt);\n\n        if (this.inverseMass === 0) {\n            this.predictedZ = this.z;\n            return;\n        }\n\n        // Z-axis velocity from position difference\n        this.velocityZ = (this.z - this.prevZ) / dt;\n        this.velocityZ *= (1.0 - this.damping);\n\n        // Predict new Z\n        this.predictedZ = this.z + this.velocityZ * dt + this.accelerationZ * dt * dt;\n        this.accelerationZ = 0;\n    }\n\n    updatePosition(dt) {\n        super.updatePosition(dt);\n        this.prevZ = this.z;\n        this.z = this.predictedZ;\n        this.velocityZ = (this.z - this.prevZ) / dt;\n    }\n}\n```\n\n### Distance Constraint in 3D\n\n```javascript\n/**\n * DistanceConstraint3D - Maintains rest length in full 3D\n */\nclass DistanceConstraint3D {\n    solve() {\n        const dx = this.particleB.predictedX - this.particleA.predictedX;\n        const dy = this.particleB.predictedY - this.particleA.predictedY;\n        const dz = this.particleB.predictedZ - this.particleA.predictedZ;\n\n        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);\n        if (distance < 1e-6) return;\n\n        const error = distance - this.restLength;\n        const wSum = this.particleA.inverseMass + this.particleB.inverseMass;\n        if (wSum < 1e-6) return;\n\n        const factor = (error * this.stiffness) / (distance * wSum);\n\n        const cx = dx * factor;\n        const cy = dy * factor;\n        const cz = dz * factor;\n\n        this.particleA.predictedX += this.particleA.inverseMass * cx;\n        this.particleA.predictedY += this.particleA.inverseMass * cy;\n        this.particleA.predictedZ += this.particleA.inverseMass * cz;\n\n        this.particleB.predictedX -= this.particleB.inverseMass * cx;\n        this.particleB.predictedY -= this.particleB.inverseMass * cy;\n        this.particleB.predictedZ -= this.particleB.inverseMass * cz;\n    }\n}\n```\n\n---\n\n## Crossing Detection in 3D\n\nDetermining over/under at crossings is crucial for knot identity.\n\n```javascript\n/**\n * Crossing3D - Represents a crossing with over/under information\n */\nclass Crossing3D {\n    /**\n     * Detect crossing between two 3D segments\n     * Returns crossing info including which strand is \"over\"\n     */\n    static detect(seg1Start, seg1End, seg2Start, seg2End) {\n        // Project to XY plane and find 2D intersection\n        const intersection2D = Segment.segmentIntersection(\n            new Vec2(seg1Start.x, seg1Start.y),\n            new Vec2(seg1End.x, seg1End.y),\n            new Vec2(seg2Start.x, seg2Start.y),\n            new Vec2(seg2End.x, seg2End.y)\n        );\n\n        if (!intersection2D.intersects) return null;\n\n        // Interpolate Z at intersection point for both segments\n        const t1 = intersection2D.t1; // Parameter along segment 1\n        const t2 = intersection2D.t2; // Parameter along segment 2\n\n        const z1 = seg1Start.z + t1 * (seg1End.z - seg1Start.z);\n        const z2 = seg2Start.z + t2 * (seg2End.z - seg2Start.z);\n\n        // Positive sign = segment 1 is over segment 2\n        const sign = z1 > z2 ? 1 : -1;\n\n        return {\n            point: intersection2D.point,\n            t1, t2,\n            z1, z2,\n            sign,\n            overSegment: sign > 0 ? 1 : 2\n        };\n    }\n}\n```\n\n---\n\n## Performance Considerations\n\n### Spatial Hashing for Collision Detection\n\n```javascript\n/**\n * SpatialHash - O(1) average case for nearby particle queries\n */\nclass SpatialHash {\n    constructor(cellSize = 20) {\n        this.cellSize = cellSize;\n        this.cells = new Map();\n    }\n\n    hash(x, y) {\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n        return `${cx},${cy}`;\n    }\n\n    insert(particle) {\n        const key = this.hash(particle.position.x, particle.position.y);\n        if (!this.cells.has(key)) this.cells.set(key, []);\n        this.cells.get(key).push(particle);\n    }\n\n    query(x, y, radius) {\n        const results = [];\n        const cellRadius = Math.ceil(radius / this.cellSize);\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n\n        for (let dx = -cellRadius; dx <= cellRadius; dx++) {\n            for (let dy = -cellRadius; dy <= cellRadius; dy++) {\n                const key = `${cx + dx},${cy + dy}`;\n                const cell = this.cells.get(key);\n                if (cell) {\n                    for (const p of cell) {\n                        const dist = Math.sqrt((p.position.x - x)**2 + (p.position.y - y)**2);\n                        if (dist <= radius) results.push(p);\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n}\n```\n\n### Performance Budgets\n\n| Component | Budget (60fps) | Notes |\n|-----------|----------------|-------|\n| Physics step | 4ms | 8 iterations, ~100 particles |\n| Reidemeister detection | 1ms | Cached, only recompute on change |\n| Crossing detection | 0.5ms | Spatial hash |\n| Render | 5ms | Three.js with LOD |\n| **Total** | **10.5ms** | Leaves headroom for GC |\n\n---\n\n## Integration with Existing Codebase\n\nThe existing `physics.js` provides solid PBD foundations. Extensions needed:\n\n| Existing | Extension for Knot Garden |\n|----------|---------------------------|\n| `Particle` | Add `z` coordinate for 3D |\n| `DistanceConstraint` | 3D variant for full knot physics |\n| `TangleConstraint` | Repurpose for mathematical knot crossings |\n| `Rope` | `Knot` class with closed-loop support |\n| `PhysicsWorld` | `KnotWorld` with Reidemeister detection |\n\n### Knot vs Rope: Key Difference\n\n```javascript\n/**\n * A Knot is a closed Rope - the ends connect\n */\nclass Knot extends Rope {\n    constructor(knotData, numParticles, options = {}) {\n        // Initialize as open rope first\n        super(knotData.startPos, knotData.endPos, numParticles, options);\n\n        // Add closing constraint (connect last to first)\n        this.closingConstraint = new DistanceConstraint(\n            this.particles[this.particles.length - 1],\n            this.particles[0],\n            this.distanceConstraints[0].restLength, // Same as other segments\n            1.0\n        );\n    }\n\n    // Override to include closing constraint\n    get distanceConstraints() {\n        return [...super.distanceConstraints, this.closingConstraint];\n    }\n}\n```\n\n---\n\n## Summary\n\n| System | Purpose | Key Classes |\n|--------|---------|-------------|\n| **Pin Constraints** | Virtual anchors for one-hand manipulation | `PinConstraint` |\n| **Pull Mechanics** | Responsive grab-and-drag | `GrabState` |\n| **Reidemeister Detection** | Find simplifying moves | `ReidemeisterDetector` |\n| **Move Animation** | Smooth visualization of moves | `ReidemeisterAnimator` |\n| **Simplification** | Reduce to minimal crossings | `GreedySimplifier`, `AStarSimplifier` |\n| **3D Representation** | True spatial knot physics | `Particle3D`, `Crossing3D` |\n\nThe physics of Knot Garden transforms abstract topology into tangible, playful interaction.\n"
        },
        {
          "name": "tangle-physics.md",
          "type": "file",
          "path": "physics-rendering-expert/references/tangle-physics.md",
          "size": 5249,
          "content": "# Tangle Physics\n\nMulti-rope collision, Capstan friction, and dynamic constraint creation.\n\n## Critical Insight\n\nTangle DETECTION is not tangle PHYSICS. Detecting crossings for braid words is different from simulating the physical constraint that forms when ropes interlock.\n\n**Detection only**: Ropes pass through each other, we just record the event\n**Physical tangle**: Ropes cannot pass through; crossing creates a new constraint point\n\n## Segment-Segment Distance\n\n```cpp\nfloat segment_distance(vec3 p1, vec3 p2, vec3 q1, vec3 q2) {\n    vec3 u = p2 - p1, v = q2 - q1, w = p1 - q1;\n    float a = dot(u,u), b = dot(u,v), c = dot(v,v);\n    float d = dot(u,w), e = dot(v,w);\n    float denom = a*c - b*b;\n\n    float s = clamp((b*e - c*d) / denom, 0, 1);\n    float t = clamp((a*e - b*d) / denom, 0, 1);\n\n    return length((q1 + t*v) - (p1 + s*u));\n}\n```\n\n## TangleConstraint: Dynamic Constraint Creation\n\nWhen a physical tangle forms, create a constraint between closest particles:\n\n```cpp\nclass TangleConstraint {\n    Particle* p1;           // Closest particle on rope A\n    Particle* p2;           // Closest particle on rope B\n    float rest_distance;    // Distance at formation (typically rope_diameter)\n    float friction;         // Capstan friction coefficient\n    float wrap_angle;       // Accumulated wrap (affects friction)\n    bool is_locked;         // Has tightened past threshold\n\n    void solve() {\n        vec3 delta = p2->predicted - p1->predicted;\n        float dist = length(delta);\n\n        float effective_rest = is_locked ?\n            rest_distance * 0.5f :  // Tightened\n            rest_distance;          // Initial\n\n        if (dist < effective_rest) return; // Don't push apart\n\n        float error = dist - effective_rest;\n        float w_sum = p1->inverse_mass + p2->inverse_mass;\n\n        // Apply friction-scaled correction (Capstan effect)\n        float friction_factor = exp(friction * wrap_angle);\n        vec3 correction = (error / (dist * w_sum)) * delta;\n        correction *= min(friction_factor, 3.0f); // Cap for stability\n\n        p1->predicted += p1->inverse_mass * correction;\n        p2->predicted -= p2->inverse_mass * correction;\n    }\n};\n```\n\n## Capstan Equation\n\n```\nT2 = T1 x e^(mu*theta)\n```\n\nWhere:\n- `T1` = tension on one side\n- `T2` = tension on other side (amplified by wrap)\n- `mu` = friction coefficient (0.3-0.8 for rope on rope)\n- `theta` = wrap angle in radians\n\n**Implication**: 90° wrap with mu=0.5 gives 2.2x amplification. 360° wrap gives 23x. This is why knots tighten!\n\n```cpp\nfloat capstan_friction(float tension_in, float wrap_angle, float mu = 0.5f) {\n    return tension_in * exp(mu * wrap_angle);\n}\n```\n\n## Tangle Formation Detection\n\n```cpp\nTangleCandidate check_tangle_formation(\n    Particle& a1, Particle& a2,  // Segment A\n    Particle& b1, Particle& b2,  // Segment B\n    float rope_diameter\n) {\n    auto [closest_a, closest_b, dist] = segment_closest_points(a1, a2, b1, b2);\n\n    if (dist > rope_diameter) return {.forms_physical_tangle = false};\n\n    // Check if tension would tighten (not just touch and separate)\n    vec3 tension_a = (a2.predicted - a1.predicted).normalized();\n    vec3 tension_b = (b2.predicted - b1.predicted).normalized();\n    vec3 separation = (closest_b - closest_a).normalized();\n\n    float pull_a = dot(tension_a, separation);\n    float pull_b = dot(tension_b, -separation);\n\n    bool would_tighten = (pull_a > 0.3f) || (pull_b > 0.3f);\n    float wrap_angle = acos(clamp(dot(tension_a, tension_b), -1.0f, 1.0f));\n\n    return {\n        .crossing_point = (closest_a + closest_b) * 0.5f,\n        .wrap_angle = wrap_angle,\n        .forms_physical_tangle = would_tighten && wrap_angle > 0.5f // ~30 degrees\n    };\n}\n```\n\n## Tangle Lifecycle\n\n1. **Detection**: Segment distance &lt; threshold\n2. **Formation**: Tension + geometry = physical constraint created\n3. **Tightening**: Under continued tension, rest_distance decreases\n4. **Locking**: Past threshold, tangle becomes \"locked\"\n5. **Breaking**: Extreme force OR deliberate untangling action\n\n## Tangle Decision Tree\n\n**Should this crossing become a TangleConstraint?**\n1. Distance &lt; rope_diameter? -> Continue\n2. Already have a TangleConstraint for this pair? -> Skip (update existing)\n3. Would tension tighten (not separate) the ropes? -> Continue\n4. Wrap angle &gt; 30 degrees? -> **Create TangleConstraint**\n5. Otherwise -> Ignore (transient contact)\n\n**When to break a TangleConstraint?**\n1. Distance &gt; 2x rest_distance for sustained period -> Break\n2. External \"untangle\" action triggered -> Break\n3. is_locked == true -> Much harder to break\n\n## Anti-Patterns\n\n### Detection Without Physics\nRecording braid words but ropes pass through each other. Create TangleConstraints when crossings form.\n\n### Treating All Crossings as Tangles\nEvery segment intersection creates a constraint. Check tension direction and wrap angle first.\n\n### Capsule Collision for Tangle Physics\nCauses instability and tunneling. Use point-based collision with adaptive particle placement.\n\n### Ignoring Directional Friction\nSymmetric friction feels wrong. Apply Capstan equation with wrap angle.\n\n### Immediate Lock on Contact\nReal tangles form gradually under tension. Use gradual tightening over time.\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "physics-rendering-expert/CHANGELOG.md",
      "size": 830,
      "content": "# Changelog\n\n## [2.0.0] - 2024-12-XX\n\n### Changed\n- **SKILL.md restructured** for progressive disclosure (471 → ~130 lines)\n- Detailed algorithms extracted to reference files\n- HTML entity escaping for MDX compatibility (`&lt;`, `&gt;`)\n\n### Added\n- `references/core-algorithms.md` - PBD loop, Verlet integration, quaternion math, solver implementations\n- `references/tangle-physics.md` - Multi-rope collision, Capstan friction, TangleConstraint\n- Shibboleths table comparing novice vs expert approaches\n- Performance budgets (single rope &lt;0.5ms, three-dog leash &lt;0.7ms)\n- Evolution timeline (2006 PBD → 2024 ALEM/BDEM)\n\n### Migration Guide\n- No changes to frontmatter or activation triggers\n- Code implementations now in reference files for copy-paste use\n- Main SKILL.md focuses on decision-making and quick reference\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "physics-rendering-expert/SKILL.md",
      "size": 5641,
      "content": "---\nname: physics-rendering-expert\ndescription: Real-time rope/cable physics using Position-Based Dynamics (PBD), Verlet integration, and constraint solvers. Expert in quaternion math, Gauss-Seidel/Jacobi solvers, and tangling detection. Activate on 'rope simulation', 'PBD', 'Position-Based Dynamics', 'Verlet', 'constraint solver', 'quaternion', 'cable dynamics', 'cloth simulation', 'leash physics'. NOT for fluid dynamics (SPH/MPM), fracture simulation (FEM), offline cinematic physics, molecular dynamics, or general game physics engines (use Unity/Unreal built-ins).\nallowed-tools: Read,Write,Edit,Bash,mcp__firecrawl__firecrawl_search,WebFetch\ncategory: AI & Machine Learning\ntags:\n  - physics\n  - pbd\n  - verlet\n  - simulation\n  - constraints\npairs-with:\n  - skill: metal-shader-expert\n    reason: GPU-accelerated physics rendering\n  - skill: native-app-designer\n    reason: Physics in app animations\n---\n\n# Physics & Rendering Expert: Rope Dynamics & Constraint Solving\n\nExpert in computational physics for real-time rope/cable dynamics, constraint solving, and physically-based simulations.\n\n## When to Use This Skill\n\n**Use for:**\n- Real-time rope/cable/chain simulation (leashes, climbing ropes)\n- Position-Based Dynamics (PBD) implementation\n- Constraint solvers (Gauss-Seidel, Jacobi)\n- Quaternion/dual-quaternion rotation math\n- Verlet integration for particle systems\n- Tangle detection (multi-rope collisions)\n\n**Do NOT use for:**\n- Fluid dynamics → specialized SPH/MPM solvers\n- Fracture simulation → requires FEM or MPM\n- Offline cinematic physics → different constraints\n- Unity/Unreal physics → use built-in systems\n\n## Expert vs Novice Shibboleths\n\n| Topic | Novice | Expert |\n|-------|--------|--------|\n| **Constraint approach** | Uses spring forces (F=ma) | Uses PBD (directly manipulates positions) |\n| **Why PBD** | \"Springs work fine\" | Springs require tiny timesteps; PBD is unconditionally stable |\n| **Solver choice** | \"Just iterate until done\" | Gauss-Seidel for chains, Jacobi for GPU |\n| **Iterations** | 20+ iterations | 5-10 is optimal; diminishing returns after |\n| **Rotation** | Uses Euler angles | Uses quaternions (no gimbal lock) |\n| **Integration** | Forward Euler | Verlet (symplectic, energy-conserving) |\n\n## Common Anti-Patterns\n\n### Force-Based Springs for Stiff Constraints\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| `force = k * (distance - rest_length)` with high k | High k requires tiny dt for stability; low k gives squishy ropes |\n| **Instead**: Use PBD - directly move particles to satisfy constraints |\n\n### Euler Angles for Rotation\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| `rotation = vec3(pitch, yaw, roll)` | Gimbal lock at 90° pitch; unstable composition |\n| **Instead**: Use quaternions - 4 numbers, no gimbal lock, stable SLERP |\n\n### Over-Iteration\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| `solver_iterations = 50` | Diminishing returns after 5-10; wastes cycles |\n| **Instead**: Use 5-10 iterations; if more needed, use XPBD compliance |\n\n### Single-Threaded Gauss-Seidel for Large Systems\n| What it looks like | Why it's wrong |\n|--------------------|----------------|\n| Gauss-Seidel on 1000+ constraints | Gauss-Seidel is inherently sequential |\n| **Instead**: Use Jacobi solver for GPU parallelization |\n\n## Quick Reference\n\n### Why PBD Beats Force-Based Physics\n\n- Unconditionally stable (large timesteps OK)\n- Direct control over constraint satisfaction\n- No spring constants to tune\n- Predictable behavior\n\n### Solver Choice\n\n| Solver | Parallelizable | Convergence | Use Case |\n|--------|---------------|-------------|----------|\n| **Gauss-Seidel** | No | Fast | Chains, ropes |\n| **Jacobi** | Yes (GPU) | Slower | Large meshes, cloth |\n\n### Rotation Representation\n\n- 3D rotation → Quaternion (never Euler)\n- Rotation + translation → Dual quaternion\n- Skinning/blending → Dual quaternion (no candy-wrapper artifact)\n\n### Performance Targets\n\n| System | Budget | Notes |\n|--------|--------|-------|\n| Single rope (100 particles) | &lt;0.5ms | 5 iterations sufficient |\n| Three-dog leash (60 particles) | &lt;0.7ms | Include tangle detection |\n| Cloth (1000 particles) | &lt;2ms | Use Jacobi on GPU |\n\n## Evolution Timeline\n\n| Era | Key Development |\n|-----|-----------------|\n| Pre-2006 | Mass-spring systems, stability issues |\n| 2006-2015 | PBD introduced (Müller et al.), unconditional stability |\n| 2016-2020 | XPBD adds compliance for soft constraints |\n| 2021-2024 | ALEM (2024 SIGGRAPH), BDEM, neural physics |\n| 2025+ | XPBD standard, hybrid CPU/GPU, learned corrections |\n\n## Decision Trees\n\n**Choosing constraint solver:**\n- Sequential structure (rope/chain)? → Gauss-Seidel\n- Large parallel system (cloth/hair)? → Jacobi (GPU)\n- Need soft constraints? → XPBD with compliance\n\n**Choosing integration:**\n- Position-only needed? → Basic Verlet\n- Need velocity for forces? → Velocity Verlet\n- High accuracy required? → RK4 (but PBD usually sufficient)\n\n## Integrates With\n\n- **metal-shader-expert** - GPU compute shaders for Jacobi solver\n- **native-app-designer** - Visualization and debugging UI\n\n## Reference Files\n\n| File | Contents |\n|------|----------|\n| `references/core-algorithms.md` | PBD loop, Verlet, quaternions, solver implementations |\n| `references/tangle-physics.md` | Multi-rope collision, Capstan friction, TangleConstraint |\n\n---\n\n**Remember**: Real-time physics is about stability and visual plausibility, not physical accuracy. PBD with 5-10 iterations at 60fps looks great and runs fast.\n"
    }
  ]
}