{
  "name": "physics-rendering-expert",
  "type": "folder",
  "path": "physics-rendering-expert",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "physics-rendering-expert/references",
      "children": [
        {
          "name": "implementations.md",
          "type": "file",
          "path": "physics-rendering-expert/references/implementations.md",
          "size": 22720,
          "content": "# Physics Implementation Reference\n\nDetailed code implementations for rope/cable physics simulation.\n\n## Complete PBD Rope Implementation\n\n```cpp\n#include <vector>\n#include <glm/glm.hpp>\n\nstruct Particle {\n    glm::vec3 position;\n    glm::vec3 predicted_position;\n    glm::vec3 velocity;\n    float mass;\n    float inverse_mass;  // Precomputed 1/mass (or 0 for static)\n\n    Particle(glm::vec3 pos, float m)\n        : position(pos), predicted_position(pos), velocity(0.0f), mass(m)\n    {\n        inverse_mass = (m > 0.0f) ? 1.0f / m : 0.0f;\n    }\n};\n\nclass RopeSimulation {\nprivate:\n    std::vector<Particle> particles;\n    std::vector<std::pair<int, int>> distance_constraints;\n    std::vector<float> rest_lengths;\n\n    float gravity = -9.81f;\n    float damping = 0.99f;\n    int solver_iterations = 5;\n\npublic:\n    RopeSimulation(glm::vec3 start, glm::vec3 end, int num_particles) {\n        for (int i = 0; i < num_particles; ++i) {\n            float t = static_cast<float>(i) / (num_particles - 1);\n            glm::vec3 pos = glm::mix(start, end, t);\n            particles.emplace_back(pos, 1.0f);\n\n            if (i == 0) particles[i].inverse_mass = 0.0f; // Fixed\n        }\n\n        for (int i = 0; i < num_particles - 1; ++i) {\n            distance_constraints.emplace_back(i, i + 1);\n            float length = glm::length(particles[i + 1].position - particles[i].position);\n            rest_lengths.push_back(length);\n        }\n    }\n\n    void update(float dt) {\n        // Step 1: Predict positions\n        for (auto& p : particles) {\n            if (p.inverse_mass == 0.0f) continue;\n            glm::vec3 acceleration(0.0f, gravity, 0.0f);\n            p.velocity += acceleration * dt;\n            p.velocity *= damping;\n            p.predicted_position = p.position + p.velocity * dt;\n        }\n\n        // Step 2: Solve constraints\n        for (int iter = 0; iter < solver_iterations; ++iter) {\n            solve_distance_constraints();\n            solve_collision_constraints();\n            solve_bending_constraints();\n        }\n\n        // Step 3: Update velocities and positions\n        for (auto& p : particles) {\n            if (p.inverse_mass == 0.0f) continue;\n            p.velocity = (p.predicted_position - p.position) / dt;\n            p.position = p.predicted_position;\n        }\n    }\n\n    void solve_distance_constraints() {\n        for (size_t i = 0; i < distance_constraints.size(); ++i) {\n            int idx1 = distance_constraints[i].first;\n            int idx2 = distance_constraints[i].second;\n            Particle& p1 = particles[idx1];\n            Particle& p2 = particles[idx2];\n\n            glm::vec3 delta = p2.predicted_position - p1.predicted_position;\n            float distance = glm::length(delta);\n            if (distance < 1e-6f) continue;\n\n            float constraint_error = distance - rest_lengths[i];\n            float w_sum = p1.inverse_mass + p2.inverse_mass;\n            if (w_sum < 1e-6f) continue;\n\n            glm::vec3 correction = (constraint_error / (distance * w_sum)) * delta;\n            p1.predicted_position += p1.inverse_mass * correction;\n            p2.predicted_position -= p2.inverse_mass * correction;\n        }\n    }\n\n    void solve_collision_constraints() {\n        float ground_y = 0.0f;\n        for (auto& p : particles) {\n            if (p.predicted_position.y < ground_y) {\n                p.predicted_position.y = ground_y;\n                p.velocity.y = 0.0f;\n                p.velocity.x *= 0.8f;\n                p.velocity.z *= 0.8f;\n            }\n        }\n    }\n\n    void solve_bending_constraints() {\n        for (size_t i = 1; i < particles.size() - 1; ++i) {\n            Particle& p_prev = particles[i - 1];\n            Particle& p_curr = particles[i];\n            Particle& p_next = particles[i + 1];\n\n            glm::vec3 v1 = p_curr.predicted_position - p_prev.predicted_position;\n            glm::vec3 v2 = p_next.predicted_position - p_curr.predicted_position;\n\n            float len1 = glm::length(v1);\n            float len2 = glm::length(v2);\n            if (len1 < 1e-6f || len2 < 1e-6f) continue;\n\n            glm::vec3 n1 = v1 / len1;\n            glm::vec3 n2 = v2 / len2;\n            float cos_angle = glm::dot(n1, n2);\n            float desired_cos = 0.5f;  // ~60 degrees max bend\n\n            if (cos_angle < desired_cos) {\n                glm::vec3 axis = glm::cross(n1, n2);\n                float axis_len = glm::length(axis);\n                if (axis_len > 1e-6f) {\n                    axis /= axis_len;\n                    p_curr.predicted_position += axis * 0.1f;\n                }\n            }\n        }\n    }\n\n    const std::vector<Particle>& get_particles() const { return particles; }\n};\n```\n\n## Quaternion Implementation\n\n```cpp\nstruct Quaternion {\n    float x, y, z, w;\n\n    static Quaternion identity() { return {0.0f, 0.0f, 0.0f, 1.0f}; }\n\n    static Quaternion from_axis_angle(glm::vec3 axis, float angle) {\n        float half_angle = angle * 0.5f;\n        float s = std::sin(half_angle);\n        return {axis.x * s, axis.y * s, axis.z * s, std::cos(half_angle)};\n    }\n\n    Quaternion operator*(const Quaternion& q) const {\n        return {\n            w * q.x + x * q.w + y * q.z - z * q.y,\n            w * q.y - x * q.z + y * q.w + z * q.x,\n            w * q.z + x * q.y - y * q.x + z * q.w,\n            w * q.w - x * q.x - y * q.y - z * q.z\n        };\n    }\n\n    glm::vec3 rotate(glm::vec3 v) const {\n        Quaternion v_quat = {v.x, v.y, v.z, 0.0f};\n        Quaternion result = (*this) * v_quat * conjugate();\n        return {result.x, result.y, result.z};\n    }\n\n    Quaternion conjugate() const { return {-x, -y, -z, w}; }\n\n    void normalize() {\n        float len = std::sqrt(x*x + y*y + z*z + w*w);\n        x /= len; y /= len; z /= len; w /= len;\n    }\n};\n```\n\n## Dual Quaternion (Rotation + Translation)\n\n```cpp\nstruct DualQuaternion {\n    Quaternion real;  // Rotation\n    Quaternion dual;  // Translation (encoded)\n\n    static DualQuaternion from_rotation_translation(Quaternion rotation, glm::vec3 translation) {\n        Quaternion t_quat = {translation.x, translation.y, translation.z, 0.0f};\n        Quaternion dual_part = (t_quat * rotation) * 0.5f;\n        return {rotation, dual_part};\n    }\n\n    glm::vec3 transform_point(glm::vec3 p) const {\n        Quaternion t_quat = (dual * 2.0f) * real.conjugate();\n        glm::vec3 translation = {t_quat.x, t_quat.y, t_quat.z};\n        return real.rotate(p) + translation;\n    }\n\n    static DualQuaternion blend(const std::vector<DualQuaternion>& dqs,\n                                 const std::vector<float>& weights) {\n        DualQuaternion result = {{0,0,0,0}, {0,0,0,0}};\n        for (size_t i = 0; i < dqs.size(); ++i) {\n            float sign = (i > 0 && dot(dqs[i].real, dqs[0].real) < 0) ? -1.0f : 1.0f;\n            result.real.x += weights[i] * sign * dqs[i].real.x;\n            result.real.y += weights[i] * sign * dqs[i].real.y;\n            result.real.z += weights[i] * sign * dqs[i].real.z;\n            result.real.w += weights[i] * sign * dqs[i].real.w;\n            result.dual.x += weights[i] * sign * dqs[i].dual.x;\n            result.dual.y += weights[i] * sign * dqs[i].dual.y;\n            result.dual.z += weights[i] * sign * dqs[i].dual.z;\n            result.dual.w += weights[i] * sign * dqs[i].dual.w;\n        }\n        result.real.normalize();\n        return result;\n    }\n};\n```\n\n## Three-Dog Leash Tangle System\n\n```cpp\nclass ThreeDogLeashSystem {\nprivate:\n    struct Dog {\n        glm::vec3 position;\n        glm::vec3 velocity;\n        int leash_id;\n    };\n\n    std::vector<Dog> dogs;\n    std::vector<RopeSimulation> leashes;\n    glm::vec3 handler_position;\n\npublic:\n    ThreeDogLeashSystem() {\n        dogs.push_back({glm::vec3(-2, 0, 0), glm::vec3(0), 0});\n        dogs.push_back({glm::vec3(0, 0, 2), glm::vec3(0), 1});\n        dogs.push_back({glm::vec3(2, 0, 0), glm::vec3(0), 2});\n        handler_position = glm::vec3(0, 1.5f, 0);\n\n        for (int i = 0; i < 3; ++i) {\n            leashes.emplace_back(handler_position, dogs[i].position, 20);\n        }\n    }\n\n    void update(float dt) {\n        // Update dog behavior\n        for (auto& dog : dogs) {\n            glm::vec3 random_accel = glm::vec3(\n                random_range(-1.0f, 1.0f), 0.0f, random_range(-1.0f, 1.0f)\n            );\n            dog.velocity += random_accel * dt;\n            dog.velocity *= 0.95f;\n            dog.position += dog.velocity * dt;\n        }\n\n        // Update leashes\n        for (size_t i = 0; i < leashes.size(); ++i) {\n            leashes[i].particles[0].position = handler_position;\n            leashes[i].particles[0].inverse_mass = 0.0f;\n            int last_idx = leashes[i].particles.size() - 1;\n            leashes[i].particles[last_idx].position = dogs[i].position;\n            leashes[i].update(dt);\n        }\n\n        detect_leash_tangles();\n    }\n\n    void detect_leash_tangles() {\n        for (size_t i = 0; i < leashes.size(); ++i) {\n            for (size_t j = i + 1; j < leashes.size(); ++j) {\n                check_leash_collision(leashes[i], leashes[j]);\n            }\n        }\n    }\n\n    float segment_segment_distance(glm::vec3 p1, glm::vec3 p2,\n                                    glm::vec3 q1, glm::vec3 q2) {\n        glm::vec3 u = p2 - p1, v = q2 - q1, w = p1 - q1;\n        float a = glm::dot(u, u), b = glm::dot(u, v), c = glm::dot(v, v);\n        float d = glm::dot(u, w), e = glm::dot(v, w);\n        float denom = a * c - b * b;\n\n        float s = (denom < 1e-6f) ? 0.0f : glm::clamp((b * e - c * d) / denom, 0.0f, 1.0f);\n        float t = (denom < 1e-6f) ? (b > c ? d / b : e / c) : glm::clamp((a * e - b * d) / denom, 0.0f, 1.0f);\n\n        return glm::length((q1 + t * v) - (p1 + s * u));\n    }\n};\n```\n\n## Jacobi Solver (GPU-Parallel)\n\n```cpp\nvoid jacobi_solve(std::vector<Constraint>& constraints,\n                  std::vector<Particle>& particles, int iterations) {\n    std::vector<glm::vec3> position_deltas(particles.size(), glm::vec3(0.0f));\n    std::vector<int> constraint_counts(particles.size(), 0);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        std::fill(position_deltas.begin(), position_deltas.end(), glm::vec3(0.0f));\n        std::fill(constraint_counts.begin(), constraint_counts.end(), 0);\n\n        #pragma omp parallel for\n        for (size_t i = 0; i < constraints.size(); ++i) {\n            auto correction = constraints[i].compute_correction();\n            #pragma omp atomic\n            position_deltas[correction.particle1_idx] += correction.delta1;\n            #pragma omp atomic\n            constraint_counts[correction.particle1_idx]++;\n            #pragma omp atomic\n            position_deltas[correction.particle2_idx] += correction.delta2;\n            #pragma omp atomic\n            constraint_counts[correction.particle2_idx]++;\n        }\n\n        #pragma omp parallel for\n        for (size_t i = 0; i < particles.size(); ++i) {\n            if (constraint_counts[i] > 0) {\n                particles[i].position += position_deltas[i] / float(constraint_counts[i]);\n            }\n        }\n    }\n}\n```\n\n## TangleConstraint Implementation (JavaScript)\n\nDynamic constraint created when rope crossings become physical tangles:\n\n```javascript\nclass TangleConstraint {\n    static nextId = 0;\n\n    constructor(particleA, particleB, ropeA, ropeB, crossingPoint, options = {}) {\n        this.id = TangleConstraint.nextId++;\n        this.particleA = particleA;\n        this.particleB = particleB;\n        this.ropeA = ropeA;\n        this.ropeB = ropeB;\n        this.crossingPoint = crossingPoint.copy();\n\n        // Physics parameters\n        this.friction = options.friction ?? 0.5;        // Capstan friction coefficient\n        this.stiffness = options.stiffness ?? 0.8;      // Constraint stiffness\n        this.maxDistance = options.maxDistance ?? 15;   // Break if exceeded\n        this.minDistance = options.minDistance ?? 2;    // Minimum (fully locked)\n\n        // Current state\n        this.restDistance = particleA.position.distanceTo(particleB.position);\n        this.restDistance = Math.max(this.minDistance, Math.min(this.restDistance, this.maxDistance));\n        this.wrapAngle = 0;                             // Accumulated wrap (radians)\n        this.tension = 0;                               // Current tension at crossing\n        this.age = 0;                                   // Frames since creation\n        this.isLocked = false;                          // Has tightened past threshold\n\n        // Thresholds\n        this.lockThreshold = this.minDistance * 2;      // Lock when rest < this\n        this.tightenRate = 0.02;                        // How fast it tightens under tension\n        this.breakTension = 200;                        // Force required to break\n    }\n\n    /**\n     * Solve the tangle constraint (call during PBD solver loop)\n     */\n    solve() {\n        const delta = this.particleB.position.subtract(this.particleA.position);\n        const dist = delta.length();\n\n        if (dist < 1e-6) return;\n\n        // Compute effective rest distance (locked tangles are tighter)\n        const effectiveRest = this.isLocked\n            ? this.restDistance * 0.5\n            : this.restDistance;\n\n        // Only pull together, don't push apart\n        if (dist <= effectiveRest) return;\n\n        const error = dist - effectiveRest;\n        const wA = this.particleA.inverseMass;\n        const wB = this.particleB.inverseMass;\n        const wSum = wA + wB;\n\n        if (wSum < 1e-6) return;\n\n        // Apply Capstan friction effect: friction amplifies with wrap angle\n        // T₂ = T₁ × e^(μθ) - but we cap it for stability\n        const frictionFactor = Math.min(Math.exp(this.friction * this.wrapAngle), 3.0);\n\n        // Compute correction with stiffness and friction\n        const correctionMag = (error * this.stiffness * frictionFactor) / (dist * wSum);\n        const correction = delta.scale(correctionMag);\n\n        // Apply corrections\n        this.particleA.position = this.particleA.position.add(correction.scale(wA));\n        this.particleB.position = this.particleB.position.subtract(correction.scale(wB));\n\n        // Record tension for tightening logic\n        this.tension = error * frictionFactor;\n    }\n\n    /**\n     * Update tangle state (call each frame after physics step)\n     */\n    update(dt) {\n        this.age++;\n\n        // Update wrap angle based on local rope geometry\n        this.wrapAngle = this._computeLocalWrapAngle();\n\n        // Tighten under tension (gradual, not instant)\n        if (this.tension > 10 && !this.isLocked) {\n            const tightenAmount = this.tightenRate * this.tension * dt;\n            this.restDistance = Math.max(\n                this.minDistance,\n                this.restDistance - tightenAmount\n            );\n        }\n\n        // Lock if tightened enough\n        if (this.restDistance < this.lockThreshold) {\n            this.isLocked = true;\n        }\n\n        // Update crossing point to midpoint\n        this.crossingPoint = this.particleA.position.add(this.particleB.position).scale(0.5);\n    }\n\n    /**\n     * Check if this tangle should break\n     */\n    shouldBreak() {\n        const dist = this.particleA.position.distanceTo(this.particleB.position);\n\n        // Break if stretched too far for too long\n        if (dist > this.maxDistance) {\n            return true;\n        }\n\n        // Locked tangles require much more force to break\n        if (this.isLocked) {\n            return this.tension > this.breakTension * 3;\n        }\n\n        // Young tangles break easily\n        if (this.age < 30) {\n            return dist > this.restDistance * 1.5;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get crossing sign for braid word tracking (+1 or -1)\n     */\n    getCrossingSign() {\n        // Determine which rope is \"over\" based on perpendicular direction\n        const delta = this.particleB.position.subtract(this.particleA.position);\n        // In 2D top-down: positive cross product = ropeA over ropeB\n        return delta.x * (this.particleA.position.y - this.crossingPoint.y) > 0 ? 1 : -1;\n    }\n\n    /**\n     * Compute local wrap angle from rope geometry\n     */\n    _computeLocalWrapAngle() {\n        // Get tangent directions of both ropes at crossing\n        const tangentA = this._getRopeTangentAt(this.ropeA, this.particleA);\n        const tangentB = this._getRopeTangentAt(this.ropeB, this.particleB);\n\n        if (!tangentA || !tangentB) return this.wrapAngle;\n\n        // Wrap angle is based on how perpendicular the ropes are\n        // Parallel = 0°, Perpendicular = 90°\n        const dot = Math.abs(tangentA.dot(tangentB));\n        const angle = Math.acos(Math.min(1, Math.max(-1, dot)));\n\n        // Smooth update (don't jump)\n        return this.wrapAngle * 0.9 + angle * 0.1;\n    }\n\n    _getRopeTangentAt(rope, particle) {\n        const idx = rope.particles.indexOf(particle);\n        if (idx < 0) return null;\n\n        const prev = rope.particles[Math.max(0, idx - 1)];\n        const next = rope.particles[Math.min(rope.particles.length - 1, idx + 1)];\n\n        return next.position.subtract(prev.position).normalize();\n    }\n}\n```\n\n### Tangle Detection and Management\n\n```javascript\nclass TangleManager {\n    constructor(world) {\n        this.world = world;\n        this.tangles = [];\n        this.tanglePairs = new Set(); // Track existing pairs\n    }\n\n    /**\n     * Detect and create new tangles (call after position prediction, before solving)\n     */\n    detectNewTangles() {\n        const ropes = this.world.ropes;\n        const ropeDiameter = 8; // Detection threshold\n\n        for (let i = 0; i < ropes.length; i++) {\n            for (let j = i + 1; j < ropes.length; j++) {\n                this._checkRopePair(ropes[i], ropes[j], ropeDiameter);\n            }\n        }\n    }\n\n    _checkRopePair(ropeA, ropeB, threshold) {\n        const particlesA = ropeA.particles;\n        const particlesB = ropeB.particles;\n\n        for (let ai = 0; ai < particlesA.length - 1; ai++) {\n            for (let bi = 0; bi < particlesB.length - 1; bi++) {\n                const result = this._checkSegmentPair(\n                    particlesA[ai], particlesA[ai + 1],\n                    particlesB[bi], particlesB[bi + 1],\n                    threshold\n                );\n\n                if (result.shouldFormTangle) {\n                    this._createTangle(\n                        result.closestA, result.closestB,\n                        ropeA, ropeB, result.crossingPoint\n                    );\n                }\n            }\n        }\n    }\n\n    _checkSegmentPair(a1, a2, b1, b2, threshold) {\n        // Segment-segment closest points\n        const result = segmentSegmentClosest(a1.position, a2.position, b1.position, b2.position);\n\n        if (result.distance > threshold) {\n            return { shouldFormTangle: false };\n        }\n\n        // Already have a tangle for these particles?\n        const pairKey = this._makePairKey(result.closestParticleA, result.closestParticleB);\n        if (this.tanglePairs.has(pairKey)) {\n            return { shouldFormTangle: false };\n        }\n\n        // Check tension direction - would pulling tighten this?\n        const tensionA = a2.position.subtract(a1.position).normalize();\n        const tensionB = b2.position.subtract(b1.position).normalize();\n        const separation = result.closestB.subtract(result.closestA).normalize();\n\n        const pullA = tensionA.dot(separation);\n        const pullB = tensionB.dot(separation.scale(-1));\n        const wouldTighten = pullA > 0.3 || pullB > 0.3;\n\n        // Check wrap angle\n        const wrapAngle = Math.acos(Math.min(1, Math.abs(tensionA.dot(tensionB))));\n        const sufficientWrap = wrapAngle > 0.5; // ~30 degrees\n\n        return {\n            shouldFormTangle: wouldTighten && sufficientWrap,\n            closestA: result.closestParticleA,\n            closestB: result.closestParticleB,\n            crossingPoint: result.closestA.add(result.closestB).scale(0.5)\n        };\n    }\n\n    _createTangle(particleA, particleB, ropeA, ropeB, crossingPoint) {\n        const tangle = new TangleConstraint(\n            particleA, particleB, ropeA, ropeB, crossingPoint\n        );\n\n        this.tangles.push(tangle);\n        this.tanglePairs.add(this._makePairKey(particleA, particleB));\n\n        // Emit event for braid tracking\n        if (this.world.onTangleFormed) {\n            this.world.onTangleFormed(tangle);\n        }\n    }\n\n    _makePairKey(pA, pB) {\n        const idA = pA.id ?? pA;\n        const idB = pB.id ?? pB;\n        return idA < idB ? `${idA}-${idB}` : `${idB}-${idA}`;\n    }\n\n    /**\n     * Solve all tangle constraints (call in PBD solver loop)\n     */\n    solveTangles() {\n        for (const tangle of this.tangles) {\n            tangle.solve();\n        }\n    }\n\n    /**\n     * Update tangles and remove broken ones (call after physics step)\n     */\n    updateTangles(dt) {\n        for (let i = this.tangles.length - 1; i >= 0; i--) {\n            const tangle = this.tangles[i];\n            tangle.update(dt);\n\n            if (tangle.shouldBreak()) {\n                this.tanglePairs.delete(\n                    this._makePairKey(tangle.particleA, tangle.particleB)\n                );\n                this.tangles.splice(i, 1);\n\n                if (this.world.onTangleBroken) {\n                    this.world.onTangleBroken(tangle);\n                }\n            }\n        }\n    }\n}\n```\n\n### Capstan Friction Utility\n\n```javascript\n/**\n * Calculate friction-amplified tension using Capstan equation\n * T₂ = T₁ × e^(μθ)\n *\n * @param tensionIn - Input tension\n * @param wrapAngle - Wrap angle in radians\n * @param mu - Friction coefficient (0.3-0.8 for rope-on-rope)\n * @returns Amplified tension\n */\nfunction capstanFriction(tensionIn, wrapAngle, mu = 0.5) {\n    return tensionIn * Math.exp(mu * wrapAngle);\n}\n\n/**\n * Example: 90° wrap with μ=0.5 gives 2.2× amplification\n * Full 360° wrap gives 23× amplification\n */\n```\n\n## Performance Benchmarks\n\n| Operation | CPU (single) | GPU |\n|-----------|-------------|-----|\n| PBD Rope (100 particles, 5 iter) | ~0.5ms | ~0.1ms |\n| Verlet Integration (1000 particles) | ~0.01ms | - |\n| Gauss-Seidel (100 constraints) | ~0.3ms | N/A |\n| Jacobi (100 constraints) | ~0.5ms | ~0.1ms |\n| Three-Dog Leash (60 particles) | ~0.7ms total | - |\n\n## References\n\n- Müller et al. (2006): \"Position Based Dynamics\"\n- Jakobsen (2001): \"Advanced Character Physics\" (GDC)\n- Baraff (1996): \"Linear-Time Dynamics using Lagrange Multipliers\"\n- Shoemake (1985): \"Animating Rotation with Quaternion Curves\"\n- Kavan et al. (2008): \"Geometric Skinning with Dual Quaternions\"\n- ALEM Method (2024 SIGGRAPH): \"Arbitrary Lagrangian-Eulerian Modal Analysis\"\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "physics-rendering-expert/SKILL.md",
      "size": 18408,
      "content": "---\nname: physics-rendering-expert\ndescription: \"Real-time rope/cable physics using Position-Based Dynamics (PBD), Verlet integration, and constraint solvers. Expert in quaternion math, Gauss-Seidel/Jacobi solvers, and tangling detection. Activate on 'rope simulation', 'PBD', 'Position-Based Dynamics', 'Verlet', 'constraint solver', 'quaternion', 'cable dynamics', 'cloth simulation', 'leash physics'. NOT for fluid dynamics (SPH/MPM), fracture simulation (FEM), offline cinematic physics, molecular dynamics, or general game physics engines (use Unity/Unreal built-ins).\"\nallowed-tools: Read,Write,Edit,Bash,mcp__firecrawl__firecrawl_search,WebFetch\n---\n\n# Physics & Rendering Expert: Rope Dynamics & Constraint Solving\n\nExpert in computational physics for real-time rope/cable dynamics, constraint solving, and physically-based simulations. Specializes in PBD, Verlet integration, quaternion math, and multi-body tangling.\n\n## When to Use This Skill\n\n✅ **Use for:**\n- Real-time rope/cable/chain simulation (leashes, climbing ropes)\n- Position-Based Dynamics (PBD) implementation\n- Constraint solvers (Gauss-Seidel, Jacobi)\n- Quaternion/dual-quaternion rotation math\n- Verlet integration for particle systems\n- Tangle detection (multi-rope collisions)\n- Character physics (hair, cloth attachments)\n\n❌ **Do NOT use for:**\n- Fluid dynamics → specialized SPH/MPM solvers\n- Fracture simulation → requires FEM or MPM\n- Offline cinematic physics → different constraints\n- Molecular dynamics → quantum-scale physics\n- Unity/Unreal physics → use built-in systems\n- Rigid body engines → use Bullet/PhysX directly\n\n## MCP Integrations\n\n| MCP | Purpose |\n|-----|---------|\n| **Firecrawl** | Research SIGGRAPH papers, physics algorithms |\n| **WebFetch** | Fetch documentation, academic papers |\n\n## Expert vs Novice Shibboleths\n\n| Topic | Novice | Expert |\n|-------|--------|--------|\n| **Constraint approach** | Uses spring forces (F=ma) | Uses PBD (directly manipulates positions) |\n| **Why PBD** | \"Springs work fine\" | Knows springs require tiny timesteps for stiffness; PBD is unconditionally stable |\n| **Solver choice** | \"Just iterate until done\" | Gauss-Seidel for chains (fast convergence), Jacobi for GPU (parallelizable) |\n| **Iterations** | 20+ iterations | Knows 5-10 is optimal; diminishing returns after |\n| **Rotation** | Uses Euler angles | Uses quaternions (no gimbal lock, stable composition) |\n| **Skinning** | Linear blend skinning | Dual quaternions (no candy-wrapper artifact) |\n| **Integration** | Forward Euler | Verlet (symplectic, energy-conserving, second-order) |\n| **Collision** | Per-frame point checks | Continuous collision detection with segment-segment distance |\n\n## Common Anti-Patterns\n\n### Anti-Pattern: Force-Based Springs for Stiff Constraints\n**What it looks like**: `force = k * (distance - rest_length)` with high spring constant\n**Why it's wrong**: High `k` requires tiny `dt` for stability; low `k` gives squishy ropes\n**What to do instead**: Use PBD - directly move particles to satisfy constraints\n```cpp\n// BAD: Requires tiny timesteps\nvec3 force = normalize(delta) * k * (distance - rest_length);\n\n// GOOD: PBD constraint (stable at any timestep)\nfloat error = distance - rest_length;\nvec3 correction = (error / (distance * (w1 + w2))) * delta;\np1.position += w1 * correction;\np2.position -= w2 * correction;\n```\n\n### Anti-Pattern: Euler Angles for Rotation\n**What it looks like**: `rotation = vec3(pitch, yaw, roll)` with sequential axis rotations\n**Why it's wrong**: Gimbal lock at 90° pitch; order-dependent; unstable under composition\n**What to do instead**: Use quaternions - 4 numbers, no gimbal lock, stable SLERP\n**How to detect**: Look for `euler`, `pitch/yaw/roll`, or 3x3 rotation matrices being composed repeatedly\n\n### Anti-Pattern: Synchronous Collision Detection\n**What it looks like**: Point-in-volume checks once per frame\n**Why it's wrong**: Fast-moving particles tunnel through obstacles between frames\n**What to do instead**: Continuous collision detection (CCD) with swept volumes or segment tests\n\n### Anti-Pattern: Over-Iteration\n**What it looks like**: `solver_iterations = 50` or higher\n**Why it's wrong**: Diminishing returns after 5-10 iterations; wastes CPU/GPU cycles\n**What to do instead**: Use 5-10 iterations with proper stiffness; if more needed, use XPBD compliance\n\n### Anti-Pattern: Single-Threaded Gauss-Seidel for Large Systems\n**What it looks like**: Gauss-Seidel on 1000+ constraints in a complex mesh\n**Why it's wrong**: Gauss-Seidel is inherently sequential; can't parallelize\n**What to do instead**: Use Jacobi solver for GPU parallelization (accumulate corrections, average)\n\n## Evolution Timeline\n\n### Pre-2006: Force-Based Physics\n- Mass-spring systems dominated\n- Stability required tiny timesteps\n- Stiff ropes = unstable simulations\n\n### 2006-2015: Position-Based Dynamics Era\n- Müller et al. (2006) introduced PBD\n- Unconditional stability revolutionized real-time physics\n- Gauss-Seidel became standard for game physics\n\n### 2016-2020: XPBD and Compliance\n- Extended PBD added compliance for soft constraints\n- Better control over stiffness vs. iteration count\n- GPU Jacobi solvers mature\n\n### 2021-2024: Modern Advances\n- **XPBD** now standard in Unreal/Unity\n- **ALEM** (2024 SIGGRAPH): Lagrangian-Eulerian modal analysis for cables\n- **BDEM** (2024): Bonded discrete element method with manifold optimization\n- Neural physics for learned dynamics\n\n### 2025+: Current Best Practices\n- XPBD with 5-10 iterations for real-time\n- Hybrid CPU/GPU pipelines\n- Learned corrections for complex materials\n- On-device physics for mobile/VR\n\n## Core Concepts\n\n### Position-Based Dynamics (PBD)\n\n**Why PBD beats force-based physics:**\n- ✅ Unconditionally stable (large timesteps OK)\n- ✅ Direct control over constraint satisfaction\n- ✅ No spring constants to tune\n- ✅ Predictable behavior\n\n**PBD Loop:**\n1. **Predict**: Apply forces, compute predicted positions\n2. **Solve**: Iteratively project constraints (distance, bending, collision)\n3. **Update**: Derive velocity from position change\n\n```cpp\nvoid pbd_update(float dt) {\n    // Step 1: Predict\n    for (auto& p : particles) {\n        if (p.inverse_mass == 0.0f) continue;\n        p.velocity += gravity * dt;\n        p.predicted = p.position + p.velocity * dt;\n    }\n\n    // Step 2: Solve constraints (5-10 iterations)\n    for (int i = 0; i < solver_iterations; ++i) {\n        solve_distance_constraints();\n        solve_bending_constraints();\n        solve_collisions();\n    }\n\n    // Step 3: Update\n    for (auto& p : particles) {\n        p.velocity = (p.predicted - p.position) / dt;\n        p.position = p.predicted;\n    }\n}\n```\n\n### Distance Constraint\n\n```cpp\nvoid solve_distance(Particle& p1, Particle& p2, float rest_length) {\n    vec3 delta = p2.predicted - p1.predicted;\n    float dist = length(delta);\n    if (dist < 1e-6f) return;\n\n    float error = dist - rest_length;\n    float w_sum = p1.inverse_mass + p2.inverse_mass;\n    if (w_sum < 1e-6f) return;\n\n    vec3 correction = (error / (dist * w_sum)) * delta;\n    p1.predicted += p1.inverse_mass * correction;\n    p2.predicted -= p2.inverse_mass * correction;\n}\n```\n\n### Solver Choice\n\n| Solver | Parallelizable | Convergence | Use Case |\n|--------|---------------|-------------|----------|\n| **Gauss-Seidel** | No | Fast | Chains, ropes (sequential structure) |\n| **Jacobi** | Yes (GPU) | Slower | Large meshes, cloth, GPU physics |\n\n**Gauss-Seidel**: Updates positions immediately; next constraint sees updated values.\n\n**Jacobi**: Accumulates corrections; applies averaged result. Requires more iterations but GPU-parallelizable.\n\n### Verlet Integration\n\n**Why Verlet > Euler:**\n- ✅ Symplectic (conserves energy)\n- ✅ Second-order accurate\n- ✅ No explicit velocity storage needed\n- ✅ Time-reversible\n\n```cpp\nvoid verlet_step(Particle& p, vec3 accel, float dt) {\n    vec3 new_pos = 2.0f * p.position - p.prev_position + accel * dt * dt;\n    p.prev_position = p.position;\n    p.position = new_pos;\n    // Velocity if needed: (position - prev_position) / dt\n}\n```\n\n### Quaternion Essentials\n\n**Why quaternions:**\n- ✅ No gimbal lock\n- ✅ Compact (4 floats vs 9 for matrix)\n- ✅ Smooth SLERP interpolation\n- ✅ Stable composition\n\n**Key operations:**\n- `q * q'` = compose rotations\n- `q * v * q*` = rotate vector\n- `normalize(q)` = after every operation\n- `slerp(q1, q2, t)` = smooth interpolation\n\n### Tangle Detection (Multi-Rope)\n\nFor leash/cable tangling, use segment-segment distance:\n\n```cpp\nfloat segment_distance(vec3 p1, vec3 p2, vec3 q1, vec3 q2) {\n    vec3 u = p2 - p1, v = q2 - q1, w = p1 - q1;\n    float a = dot(u,u), b = dot(u,v), c = dot(v,v);\n    float d = dot(u,w), e = dot(v,w);\n    float denom = a*c - b*b;\n\n    float s = clamp((b*e - c*d) / denom, 0, 1);\n    float t = clamp((a*e - b*d) / denom, 0, 1);\n\n    return length((q1 + t*v) - (p1 + s*u));\n}\n```\n\nCheck all segment pairs between ropes; if distance < rope_diameter, resolve collision.\n\n### Tangle Formation Physics (Crossings → Physical Constraints)\n\n**Critical insight**: Tangle DETECTION is not tangle PHYSICS. Detecting crossings for braid words is different from simulating the physical constraint that forms when ropes interlock.\n\n**When crossings become physical constraints:**\n1. Two rope segments cross (distance < rope_diameter)\n2. Tension exists on one or both ropes (pulling them apart)\n3. The crossing geometry prevents separation (wrap angle > threshold)\n\n**The key difference:**\n- **Detection only**: Ropes pass through each other, we just record the event\n- **Physical tangle**: Ropes cannot pass through; crossing creates a new constraint point\n\n#### TangleConstraint: Dynamic Constraint Creation\n\nWhen a physical tangle forms, create a **TangleConstraint** between the closest particles on each rope:\n\n```cpp\nclass TangleConstraint {\n    Particle* p1;           // Closest particle on rope A\n    Particle* p2;           // Closest particle on rope B\n    float rest_distance;    // Distance at formation (typically rope_diameter)\n    float friction;         // Capstan friction coefficient\n    float wrap_angle;       // Accumulated wrap (affects friction)\n    bool is_locked;         // Has tightened past threshold\n\n    void solve() {\n        vec3 delta = p2->predicted - p1->predicted;\n        float dist = length(delta);\n\n        // Tangle constraint acts like distance constraint\n        // but with friction-dependent rest length\n        float effective_rest = is_locked ?\n            rest_distance * 0.5f :  // Tightened\n            rest_distance;          // Initial\n\n        if (dist < effective_rest) return; // Don't push apart\n\n        float error = dist - effective_rest;\n        float w_sum = p1->inverse_mass + p2->inverse_mass;\n\n        // Apply friction-scaled correction (Capstan effect)\n        float friction_factor = exp(friction * wrap_angle);\n        vec3 correction = (error / (dist * w_sum)) * delta;\n        correction *= min(friction_factor, 3.0f); // Cap for stability\n\n        p1->predicted += p1->inverse_mass * correction;\n        p2->predicted -= p2->inverse_mass * correction;\n    }\n};\n```\n\n#### Capstan Equation: Friction at Crossings\n\nThe **Capstan equation** governs friction amplification at rope crossings:\n\n```\nT₂ = T₁ × e^(μθ)\n```\n\nWhere:\n- `T₁` = tension on one side\n- `T₂` = tension on other side (amplified by wrap)\n- `μ` = friction coefficient (0.3-0.8 for rope on rope)\n- `θ` = wrap angle in radians\n\n**Practical implication**: Even 90° of wrap (π/2) with μ=0.5 gives T₂ = 2.2 × T₁. A full 360° wrap gives T₂ = 23 × T₁. This is why knots tighten!\n\n```cpp\nfloat capstan_friction(float tension_in, float wrap_angle, float mu = 0.5f) {\n    return tension_in * exp(mu * wrap_angle);\n}\n```\n\n#### Tangle Formation Detection\n\n```cpp\nstruct TangleCandidate {\n    int rope_a_segment;\n    int rope_b_segment;\n    vec3 crossing_point;\n    float wrap_angle;\n    bool forms_physical_tangle;\n};\n\nTangleCandidate check_tangle_formation(\n    Particle& a1, Particle& a2,  // Segment A\n    Particle& b1, Particle& b2,  // Segment B\n    float rope_diameter\n) {\n    // 1. Check segment-segment distance\n    auto [closest_a, closest_b, dist] = segment_closest_points(a1, a2, b1, b2);\n\n    if (dist > rope_diameter) return {.forms_physical_tangle = false};\n\n    // 2. Check if tension would tighten (not just touch and separate)\n    vec3 tension_a = (a2.predicted - a1.predicted).normalized();\n    vec3 tension_b = (b2.predicted - b1.predicted).normalized();\n    vec3 separation = (closest_b - closest_a).normalized();\n\n    // Dot products indicate if pulling would tighten\n    float pull_a = dot(tension_a, separation);\n    float pull_b = dot(tension_b, -separation);\n\n    bool would_tighten = (pull_a > 0.3f) || (pull_b > 0.3f);\n\n    // 3. Compute wrap angle (how much rope curves around crossing)\n    float wrap_angle = acos(clamp(dot(tension_a, tension_b), -1.0f, 1.0f));\n\n    return {\n        .crossing_point = (closest_a + closest_b) * 0.5f,\n        .wrap_angle = wrap_angle,\n        .forms_physical_tangle = would_tighten && wrap_angle > 0.5f // ~30°\n    };\n}\n```\n\n#### Tangle Lifecycle\n\n1. **Detection**: Segment distance < threshold\n2. **Formation**: Tension + geometry = physical constraint created\n3. **Tightening**: Under continued tension, rest_distance decreases (knot tightens)\n4. **Locking**: Past threshold, tangle becomes \"locked\" (much harder to undo)\n5. **Breaking**: Extreme force OR deliberate untangling action\n\n```cpp\nvoid update_tangle(TangleConstraint& tangle, float dt) {\n    // Measure local tension\n    float tension = measure_rope_tension_at(tangle.p1) +\n                   measure_rope_tension_at(tangle.p2);\n\n    // Tighten under tension\n    if (tension > TIGHTEN_THRESHOLD && !tangle.is_locked) {\n        tangle.rest_distance *= (1.0f - 0.1f * dt); // Gradual tightening\n        tangle.rest_distance = max(tangle.rest_distance, MIN_TANGLE_DISTANCE);\n    }\n\n    // Lock if tightened enough\n    if (tangle.rest_distance < LOCK_THRESHOLD) {\n        tangle.is_locked = true;\n    }\n\n    // Update wrap angle based on local geometry\n    tangle.wrap_angle = compute_local_wrap_angle(tangle);\n}\n```\n\n### Anti-Patterns: Tangle Simulation\n\n#### Anti-Pattern: Detection Without Physics\n**What it looks like**: Recording braid words but ropes pass through each other\n**Why it's wrong**: Braid tracking ≠ physical simulation; user sees ropes ghost through\n**What to do instead**: Create TangleConstraints when crossings form; resolve as constraints in PBD loop\n\n#### Anti-Pattern: Treating All Crossings as Tangles\n**What it looks like**: Every segment intersection creates a constraint\n**Why it's wrong**: Brief touches aren't tangles; creates explosion of unnecessary constraints\n**What to do instead**: Check tension direction and wrap angle; only form tangle if would tighten\n\n#### Anti-Pattern: Capsule Collision for Tangle Physics\n**What it looks like**: Using thick capsule collision volumes around rope segments\n**Why it's wrong**: Causes instability (\"violent explosions\" per Starframe devs); tunneling issues\n**What to do instead**: Point-based collision with adaptive particle placement; or overlapping circular colliders\n\n#### Anti-Pattern: Ignoring Directional Friction\n**What it looks like**: Symmetric friction in all directions at crossing points\n**Why it's wrong**: Real rope friction is directional (Capstan effect); symmetric friction feels wrong\n**What to do instead**: Apply Capstan equation with wrap angle; or disable static friction entirely for simplicity\n\n#### Anti-Pattern: Immediate Lock on Contact\n**What it looks like**: `if (crossed) tangle.is_locked = true`\n**Why it's wrong**: Real tangles form gradually under tension; instant lock feels jarring\n**What to do instead**: Gradual tightening over time; lock only after rest_distance < threshold\n\n### Tangle Decision Tree\n\n**Should this crossing become a TangleConstraint?**\n1. Distance < rope_diameter? → Continue\n2. Already have a TangleConstraint for this pair? → Skip (update existing)\n3. Would tension tighten (not separate) the ropes? → Continue\n4. Wrap angle > 30°? → **Create TangleConstraint**\n5. Otherwise → Ignore (transient contact)\n\n**When to break a TangleConstraint?**\n1. Distance > 2× rest_distance for sustained period → Break\n2. External \"untangle\" action triggered → Break\n3. is_locked == true → Much harder to break (require specific manipulation)\n\n### Tangle Expert vs Novice Shibboleths\n\n| Topic | Novice | Expert |\n|-------|--------|--------|\n| **Crossing = tangle** | \"Detected crossing, add constraint\" | \"Check tension direction + wrap angle first\" |\n| **Friction model** | Symmetric Coulomb friction | Capstan equation (exponential with wrap) |\n| **Collision volumes** | Capsules around segments | Point-based or circular with overlap |\n| **Tightening** | Instant or none | Gradual under tension, lock at threshold |\n| **Constraint creation** | At detection time | At PBD loop step 7 (after position prediction) |\n\n## Performance Targets\n\n| System | Budget | Notes |\n|--------|--------|-------|\n| Single rope (100 particles) | <0.5ms | 5 iterations sufficient |\n| Three-dog leash (60 particles) | <0.7ms | Include tangle detection |\n| Cloth (1000 particles) | <2ms | Use Jacobi on GPU |\n| Hair (10k strands) | <5ms | LOD + GPU required |\n\n## Integrates With\n\n- **metal-shader-expert** - GPU compute shaders for Jacobi solver\n- **vr-avatar-engineer** - Real-time character physics in VR\n- **native-app-designer** - Visualization and debugging UI\n\n## Quick Decision Tree\n\n**Choosing constraint solver:**\n- Sequential structure (rope/chain)? → Gauss-Seidel\n- Large parallel system (cloth/hair)? → Jacobi (GPU)\n- Need soft constraints? → XPBD with compliance\n\n**Choosing integration:**\n- Position-only needed? → Basic Verlet\n- Need velocity for forces? → Velocity Verlet\n- High accuracy required? → RK4 (but PBD usually sufficient)\n\n**Rotation representation:**\n- 3D rotation? → Quaternion (never Euler)\n- Rotation + translation? → Dual quaternion\n- Skinning/blending? → Dual quaternion (no candy-wrapper)\n\n---\n\n**For complete implementations**: See `/references/implementations.md`\n\n**Remember**: Real-time physics is about stability and visual plausibility, not physical accuracy. PBD with 5-10 iterations at 60fps looks great and runs fast. Don't over-engineer.\n"
    }
  ]
}