{
  "name": "form-validation-architect",
  "type": "folder",
  "path": "form-validation-architect",
  "children": [
    {
      "name": "assets",
      "type": "folder",
      "path": "form-validation-architect/assets",
      "children": [
        {
          "name": "form-templates",
          "type": "folder",
          "path": "form-validation-architect/assets/form-templates",
          "children": [
            {
              "name": "LoginForm.tsx",
              "type": "file",
              "path": "form-validation-architect/assets/form-templates/LoginForm.tsx",
              "size": 3951,
              "content": "import { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\n/**\n * Login Form Template\n *\n * Features:\n * - Email + password validation\n * - Remember me checkbox\n * - Loading state\n * - Error handling\n *\n * Usage:\n *   import { LoginForm } from './LoginForm';\n *   <LoginForm onSubmit={handleLogin} />\n */\n\nconst loginSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  rememberMe: z.boolean().optional()\n});\n\ntype LoginFormData = z.infer<typeof loginSchema>;\n\ninterface LoginFormProps {\n  onSubmit: (data: LoginFormData) => Promise<void>;\n  onForgotPassword?: () => void;\n}\n\nexport function LoginForm({ onSubmit, onForgotPassword }: LoginFormProps) {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting }\n  } = useForm<LoginFormData>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: {\n      rememberMe: false\n    }\n  });\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)} className=\"login-form\">\n      <div className=\"form-field\">\n        <label htmlFor=\"email\">Email Address</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          placeholder=\"you@example.com\"\n          {...register('email')}\n          aria-invalid={errors.email ? 'true' : 'false'}\n          aria-describedby={errors.email ? 'email-error' : undefined}\n        />\n        {errors.email && (\n          <span id=\"email-error\" className=\"error\" role=\"alert\">\n            {errors.email.message}\n          </span>\n        )}\n      </div>\n\n      <div className=\"form-field\">\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          placeholder=\"Enter password\"\n          {...register('password')}\n          aria-invalid={errors.password ? 'true' : 'false'}\n          aria-describedby={errors.password ? 'password-error' : undefined}\n        />\n        {errors.password && (\n          <span id=\"password-error\" className=\"error\" role=\"alert\">\n            {errors.password.message}\n          </span>\n        )}\n      </div>\n\n      <div className=\"form-field checkbox-field\">\n        <label>\n          <input type=\"checkbox\" {...register('rememberMe')} />\n          Remember me\n        </label>\n\n        {onForgotPassword && (\n          <button\n            type=\"button\"\n            onClick={onForgotPassword}\n            className=\"link-button\"\n          >\n            Forgot password?\n          </button>\n        )}\n      </div>\n\n      <button type=\"submit\" disabled={isSubmitting} className=\"submit-button\">\n        {isSubmitting ? 'Logging in...' : 'Log In'}\n      </button>\n    </form>\n  );\n}\n\n/**\n * Example Styles (CSS Module or styled-components)\n */\nconst styles = `\n.login-form {\n  max-width: 400px;\n  margin: 0 auto;\n}\n\n.form-field {\n  margin-bottom: 1rem;\n}\n\n.form-field label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n\n.form-field input[type=\"email\"],\n.form-field input[type=\"password\"] {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 1rem;\n}\n\n.form-field input[aria-invalid=\"true\"] {\n  border-color: #d32f2f;\n}\n\n.error {\n  display: block;\n  margin-top: 0.25rem;\n  color: #d32f2f;\n  font-size: 0.875rem;\n}\n\n.checkbox-field {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.checkbox-field label {\n  margin-bottom: 0;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.link-button {\n  background: none;\n  border: none;\n  color: #2196F3;\n  text-decoration: underline;\n  cursor: pointer;\n  font-size: 0.875rem;\n}\n\n.submit-button {\n  width: 100%;\n  padding: 0.75rem;\n  background: #2196F3;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  font-size: 1rem;\n  font-weight: 500;\n  cursor: pointer;\n}\n\n.submit-button:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n`;\n"
            },
            {
              "name": "MultiStepWizard.tsx",
              "type": "file",
              "path": "form-validation-architect/assets/form-templates/MultiStepWizard.tsx",
              "size": 9983,
              "content": "import { useState } from 'react';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\n/**\n * Multi-Step Wizard Template\n *\n * Features:\n * - 3-step onboarding flow\n * - Progress indicator\n * - Per-step validation\n * - Back/Next navigation\n * - Form state persistence across steps\n *\n * Usage:\n *   import { MultiStepWizard } from './MultiStepWizard';\n *   <MultiStepWizard onComplete={handleComplete} />\n */\n\n// Step schemas\nconst personalInfoSchema = z.object({\n  firstName: z.string().min(1, 'First name is required'),\n  lastName: z.string().min(1, 'Last name is required'),\n  email: z.string().email('Invalid email address')\n});\n\nconst addressSchema = z.object({\n  street: z.string().min(1, 'Street address is required'),\n  city: z.string().min(1, 'City is required'),\n  state: z.string().min(2, 'State is required').max(2, 'Use 2-letter state code'),\n  zipCode: z.string().regex(/^\\d{5}$/, 'ZIP code must be 5 digits')\n});\n\nconst preferencesSchema = z.object({\n  notifications: z.boolean(),\n  newsletter: z.boolean(),\n  theme: z.enum(['light', 'dark', 'auto'])\n});\n\nconst stepSchemas = [personalInfoSchema, addressSchema, preferencesSchema];\n\ntype PersonalInfo = z.infer<typeof personalInfoSchema>;\ntype Address = z.infer<typeof addressSchema>;\ntype Preferences = z.infer<typeof preferencesSchema>;\ntype CompleteFormData = PersonalInfo & Address & Preferences;\n\ninterface MultiStepWizardProps {\n  onComplete: (data: CompleteFormData) => Promise<void>;\n}\n\nexport function MultiStepWizard({ onComplete }: MultiStepWizardProps) {\n  const [step, setStep] = useState(0);\n  const [formData, setFormData] = useState<Partial<CompleteFormData>>({});\n\n  const form = useForm({\n    resolver: zodResolver(stepSchemas[step]),\n    defaultValues: formData\n  });\n\n  const stepTitles = [\n    'Personal Information',\n    'Address',\n    'Preferences'\n  ];\n\n  const nextStep = async () => {\n    const isValid = await form.trigger();\n\n    if (isValid) {\n      setFormData({ ...formData, ...form.getValues() });\n\n      if (step < stepSchemas.length - 1) {\n        setStep(step + 1);\n        form.reset(formData); // Load saved data for next step\n      }\n    }\n  };\n\n  const prevStep = () => {\n    setFormData({ ...formData, ...form.getValues() });\n    setStep(step - 1);\n    form.reset(formData);\n  };\n\n  const handleSubmit = async (data: any) => {\n    const finalData = { ...formData, ...data } as CompleteFormData;\n    await onComplete(finalData);\n  };\n\n  return (\n    <div className=\"wizard-container\">\n      {/* Progress indicator */}\n      <div className=\"wizard-progress\" role=\"group\" aria-labelledby=\"wizard-title\">\n        <h2 id=\"wizard-title\" className=\"sr-only\">Account Setup</h2>\n\n        <nav aria-label=\"Form progress\">\n          <ol className=\"progress-steps\">\n            {stepTitles.map((title, index) => (\n              <li\n                key={title}\n                className={index <= step ? 'active' : ''}\n                aria-current={index === step ? 'step' : undefined}\n              >\n                <span className=\"step-number\">{index + 1}</span>\n                <span className=\"step-title\">{title}</span>\n              </li>\n            ))}\n          </ol>\n        </nav>\n      </div>\n\n      {/* Announce step changes to screen readers */}\n      <div role=\"status\" aria-live=\"polite\" className=\"sr-only\">\n        Step {step + 1} of {stepSchemas.length}: {stepTitles[step]}\n      </div>\n\n      {/* Form */}\n      <form\n        onSubmit={form.handleSubmit(step === stepSchemas.length - 1 ? handleSubmit : nextStep)}\n        className=\"wizard-form\"\n      >\n        <div role=\"region\" aria-labelledby={`step-${step}-title`}>\n          <h3 id={`step-${step}-title`}>{stepTitles[step]}</h3>\n\n          {/* Step 1: Personal Info */}\n          {step === 0 && (\n            <>\n              <div className=\"form-field\">\n                <label htmlFor=\"firstName\">First Name</label>\n                <input id=\"firstName\" {...form.register('firstName')} />\n                {form.formState.errors.firstName && (\n                  <span className=\"error\">{form.formState.errors.firstName.message}</span>\n                )}\n              </div>\n\n              <div className=\"form-field\">\n                <label htmlFor=\"lastName\">Last Name</label>\n                <input id=\"lastName\" {...form.register('lastName')} />\n                {form.formState.errors.lastName && (\n                  <span className=\"error\">{form.formState.errors.lastName.message}</span>\n                )}\n              </div>\n\n              <div className=\"form-field\">\n                <label htmlFor=\"email\">Email</label>\n                <input id=\"email\" type=\"email\" {...form.register('email')} />\n                {form.formState.errors.email && (\n                  <span className=\"error\">{form.formState.errors.email.message}</span>\n                )}\n              </div>\n            </>\n          )}\n\n          {/* Step 2: Address */}\n          {step === 1 && (\n            <>\n              <div className=\"form-field\">\n                <label htmlFor=\"street\">Street Address</label>\n                <input id=\"street\" {...form.register('street')} />\n                {form.formState.errors.street && (\n                  <span className=\"error\">{form.formState.errors.street.message}</span>\n                )}\n              </div>\n\n              <div className=\"form-row\">\n                <div className=\"form-field\">\n                  <label htmlFor=\"city\">City</label>\n                  <input id=\"city\" {...form.register('city')} />\n                  {form.formState.errors.city && (\n                    <span className=\"error\">{form.formState.errors.city.message}</span>\n                  )}\n                </div>\n\n                <div className=\"form-field\">\n                  <label htmlFor=\"state\">State</label>\n                  <input id=\"state\" maxLength={2} {...form.register('state')} />\n                  {form.formState.errors.state && (\n                    <span className=\"error\">{form.formState.errors.state.message}</span>\n                  )}\n                </div>\n\n                <div className=\"form-field\">\n                  <label htmlFor=\"zipCode\">ZIP Code</label>\n                  <input id=\"zipCode\" {...form.register('zipCode')} />\n                  {form.formState.errors.zipCode && (\n                    <span className=\"error\">{form.formState.errors.zipCode.message}</span>\n                  )}\n                </div>\n              </div>\n            </>\n          )}\n\n          {/* Step 3: Preferences */}\n          {step === 2 && (\n            <>\n              <div className=\"form-field\">\n                <label>\n                  <input type=\"checkbox\" {...form.register('notifications')} />\n                  Enable email notifications\n                </label>\n              </div>\n\n              <div className=\"form-field\">\n                <label>\n                  <input type=\"checkbox\" {...form.register('newsletter')} />\n                  Subscribe to newsletter\n                </label>\n              </div>\n\n              <div className=\"form-field\">\n                <label htmlFor=\"theme\">Theme</label>\n                <select id=\"theme\" {...form.register('theme')}>\n                  <option value=\"light\">Light</option>\n                  <option value=\"dark\">Dark</option>\n                  <option value=\"auto\">Auto</option>\n                </select>\n              </div>\n            </>\n          )}\n        </div>\n\n        {/* Navigation */}\n        <div className=\"wizard-actions\">\n          {step > 0 && (\n            <button type=\"button\" onClick={prevStep} className=\"btn-secondary\">\n              Back\n            </button>\n          )}\n\n          <button\n            type=\"submit\"\n            disabled={form.formState.isSubmitting}\n            className=\"btn-primary\"\n          >\n            {step === stepSchemas.length - 1\n              ? form.formState.isSubmitting\n                ? 'Submitting...'\n                : 'Complete'\n              : 'Next'}\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n}\n\n/**\n * Example Styles (CSS Module or styled-components)\n */\nconst styles = `\n.wizard-container {\n  max-width: 600px;\n  margin: 0 auto;\n}\n\n.wizard-progress {\n  margin-bottom: 2rem;\n}\n\n.progress-steps {\n  display: flex;\n  justify-content: space-between;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.progress-steps li {\n  flex: 1;\n  text-align: center;\n  position: relative;\n  padding-bottom: 2rem;\n}\n\n.progress-steps li:not(:last-child)::after {\n  content: '';\n  position: absolute;\n  top: 1rem;\n  left: 50%;\n  width: 100%;\n  height: 2px;\n  background: #ddd;\n}\n\n.progress-steps li.active:not(:last-child)::after {\n  background: #2196F3;\n}\n\n.step-number {\n  display: inline-block;\n  width: 2rem;\n  height: 2rem;\n  line-height: 2rem;\n  border-radius: 50%;\n  background: #ddd;\n  color: #666;\n  font-weight: bold;\n}\n\n.progress-steps li.active .step-number {\n  background: #2196F3;\n  color: white;\n}\n\n.step-title {\n  display: block;\n  margin-top: 0.5rem;\n  font-size: 0.875rem;\n  color: #666;\n}\n\n.progress-steps li.active .step-title {\n  color: #2196F3;\n  font-weight: 500;\n}\n\n.form-row {\n  display: grid;\n  grid-template-columns: 2fr 1fr 1fr;\n  gap: 1rem;\n}\n\n.wizard-actions {\n  display: flex;\n  justify-content: space-between;\n  margin-top: 2rem;\n  padding-top: 2rem;\n  border-top: 1px solid #ddd;\n}\n\n.btn-secondary {\n  padding: 0.75rem 1.5rem;\n  background: white;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.btn-primary {\n  padding: 0.75rem 2rem;\n  background: #2196F3;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: 500;\n}\n\n.btn-primary:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n`;\n"
            },
            {
              "name": "RegistrationForm.tsx",
              "type": "file",
              "path": "form-validation-architect/assets/form-templates/RegistrationForm.tsx",
              "size": 5999,
              "content": "import { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\n/**\n * Registration Form Template\n *\n * Features:\n * - Email, password, confirm password validation\n * - Password strength indicator\n * - Terms of service checkbox\n * - Cross-field validation (passwords match)\n *\n * Usage:\n *   import { RegistrationForm } from './RegistrationForm';\n *   <RegistrationForm onSubmit={handleRegister} />\n */\n\nconst registrationSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string()\n    .min(8, 'Password must be at least 8 characters')\n    .regex(/[A-Z]/, 'Password must contain an uppercase letter')\n    .regex(/[0-9]/, 'Password must contain a number'),\n  confirmPassword: z.string(),\n  acceptTerms: z.boolean().refine((val) => val === true, {\n    message: 'You must accept the terms and conditions'\n  })\n}).refine((data) => data.password === data.confirmPassword, {\n  message: 'Passwords do not match',\n  path: ['confirmPassword']\n});\n\ntype RegistrationFormData = z.infer<typeof registrationSchema>;\n\ninterface RegistrationFormProps {\n  onSubmit: (data: Omit<RegistrationFormData, 'confirmPassword'>) => Promise<void>;\n  onTermsClick?: () => void;\n}\n\nexport function RegistrationForm({ onSubmit, onTermsClick }: RegistrationFormProps) {\n  const {\n    register,\n    handleSubmit,\n    watch,\n    formState: { errors, isSubmitting }\n  } = useForm<RegistrationFormData>({\n    resolver: zodResolver(registrationSchema),\n    mode: 'onBlur'\n  });\n\n  const password = watch('password', '');\n\n  // Calculate password strength\n  const getPasswordStrength = (pwd: string): { score: number; label: string } => {\n    if (!pwd) return { score: 0, label: '' };\n\n    let score = 0;\n    if (pwd.length >= 8) score++;\n    if (pwd.length >= 12) score++;\n    if (/[a-z]/.test(pwd) && /[A-Z]/.test(pwd)) score++;\n    if (/[0-9]/.test(pwd)) score++;\n    if (/[^A-Za-z0-9]/.test(pwd)) score++;\n\n    const labels = ['Weak', 'Fair', 'Good', 'Strong', 'Very Strong'];\n    return { score, label: labels[Math.min(score - 1, 4)] };\n  };\n\n  const strength = getPasswordStrength(password);\n\n  const handleFormSubmit = async (data: RegistrationFormData) => {\n    const { confirmPassword, ...submitData } = data;\n    await onSubmit(submitData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(handleFormSubmit)} className=\"registration-form\">\n      <div className=\"form-field\">\n        <label htmlFor=\"email\">Email Address</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          placeholder=\"you@example.com\"\n          {...register('email')}\n          aria-invalid={errors.email ? 'true' : 'false'}\n          aria-describedby={errors.email ? 'email-error' : undefined}\n        />\n        {errors.email && (\n          <span id=\"email-error\" className=\"error\" role=\"alert\">\n            {errors.email.message}\n          </span>\n        )}\n      </div>\n\n      <div className=\"form-field\">\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          placeholder=\"Enter password\"\n          {...register('password')}\n          aria-invalid={errors.password ? 'true' : 'false'}\n          aria-describedby=\"password-requirements\"\n        />\n\n        <span id=\"password-requirements\" className=\"help-text\">\n          Must be at least 8 characters with one uppercase letter and one number\n        </span>\n\n        {password && (\n          <div className=\"password-strength\">\n            <div\n              className={`strength-bar strength-${strength.score}`}\n              style={{ width: `${(strength.score / 5) * 100}%` }}\n            />\n            <span className=\"strength-label\">{strength.label}</span>\n          </div>\n        )}\n\n        {errors.password && (\n          <span className=\"error\" role=\"alert\">\n            {errors.password.message}\n          </span>\n        )}\n      </div>\n\n      <div className=\"form-field\">\n        <label htmlFor=\"confirmPassword\">Confirm Password</label>\n        <input\n          id=\"confirmPassword\"\n          type=\"password\"\n          placeholder=\"Re-enter password\"\n          {...register('confirmPassword')}\n          aria-invalid={errors.confirmPassword ? 'true' : 'false'}\n        />\n        {errors.confirmPassword && (\n          <span className=\"error\" role=\"alert\">\n            {errors.confirmPassword.message}\n          </span>\n        )}\n      </div>\n\n      <div className=\"form-field\">\n        <label className=\"checkbox-label\">\n          <input type=\"checkbox\" {...register('acceptTerms')} />\n          I accept the{' '}\n          {onTermsClick ? (\n            <button type=\"button\" onClick={onTermsClick} className=\"link-button\">\n              terms and conditions\n            </button>\n          ) : (\n            <span>terms and conditions</span>\n          )}\n        </label>\n        {errors.acceptTerms && (\n          <span className=\"error\" role=\"alert\">\n            {errors.acceptTerms.message}\n          </span>\n        )}\n      </div>\n\n      <button type=\"submit\" disabled={isSubmitting} className=\"submit-button\">\n        {isSubmitting ? 'Creating account...' : 'Create Account'}\n      </button>\n    </form>\n  );\n}\n\n/**\n * Example Styles (CSS Module or styled-components)\n */\nconst styles = `\n.password-strength {\n  margin-top: 0.5rem;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.strength-bar {\n  height: 4px;\n  border-radius: 2px;\n  transition: all 0.3s ease;\n}\n\n.strength-bar.strength-1 { background: #d32f2f; }\n.strength-bar.strength-2 { background: #ff9800; }\n.strength-bar.strength-3 { background: #ffc107; }\n.strength-bar.strength-4 { background: #8bc34a; }\n.strength-bar.strength-5 { background: #4caf50; }\n\n.strength-label {\n  font-size: 0.75rem;\n  font-weight: 500;\n}\n\n.help-text {\n  display: block;\n  margin-top: 0.25rem;\n  font-size: 0.875rem;\n  color: #666;\n}\n\n.checkbox-label {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  font-size: 0.875rem;\n}\n`;\n"
            }
          ]
        }
      ]
    },
    {
      "name": "references",
      "type": "folder",
      "path": "form-validation-architect/references",
      "children": [
        {
          "name": "accessibility.md",
          "type": "file",
          "path": "form-validation-architect/references/accessibility.md",
          "size": 10279,
          "content": "# Form Accessibility Guidelines\n\nMaking forms usable for everyone, including screen reader users and keyboard-only navigation.\n\n## WCAG 2.1 AA Compliance Checklist\n\n```\n□ All inputs have associated labels\n□ Error messages are announced to screen readers\n□ Focus order follows logical tab sequence\n□ Required fields are indicated (not just color)\n□ Color contrast ≥ 4.5:1 for normal text\n□ Form can be completed with keyboard alone\n□ Error recovery is possible without mouse\n□ Time limits are adjustable or disabled\n□ Instructions provided before form start\n□ Success/failure clearly communicated\n```\n\n---\n\n## Pattern 1: Proper Label Association\n\n**❌ Wrong**: Label not associated with input\n```tsx\n<label>Email</label>\n<input name=\"email\" />\n```\n\n**✅ Correct**: Explicit association\n```tsx\n<label htmlFor=\"email\">Email Address</label>\n<input id=\"email\" name=\"email\" type=\"email\" />\n\n// Or: Implicit association\n<label>\n  Email Address\n  <input name=\"email\" type=\"email\" />\n</label>\n```\n\n**Why**: Screen readers announce the label when input is focused.\n\n---\n\n## Pattern 2: Required Field Indication\n\n**❌ Wrong**: Only using asterisk\n```tsx\n<label>Email *</label>\n<input required />\n```\n\n**✅ Correct**: Explicit aria-required + visual indicator\n```tsx\n<label htmlFor=\"email\">\n  Email Address\n  <span aria-label=\"required\" className=\"required\">*</span>\n</label>\n<input\n  id=\"email\"\n  name=\"email\"\n  required\n  aria-required=\"true\"\n/>\n```\n\n**Better**: Text indicator\n```tsx\n<label htmlFor=\"email\">\n  Email Address <span className=\"required\">(required)</span>\n</label>\n```\n\n---\n\n## Pattern 3: Error Announcement\n\n**❌ Wrong**: Error not announced\n```tsx\n{errors.email && <span className=\"error\">{errors.email.message}</span>}\n```\n\n**✅ Correct**: aria-describedby + aria-invalid\n```tsx\n<input\n  id=\"email\"\n  name=\"email\"\n  aria-invalid={errors.email ? 'true' : 'false'}\n  aria-describedby={errors.email ? 'email-error' : undefined}\n/>\n{errors.email && (\n  <span id=\"email-error\" className=\"error\" role=\"alert\">\n    {errors.email.message}\n  </span>\n)}\n```\n\n**Why**: `role=\"alert\"` causes screen readers to announce the error immediately.\n\n---\n\n## Pattern 4: Live Region for Form Status\n\nAnnounce submission status without page reload.\n\n```tsx\nfunction ContactForm() {\n  const [status, setStatus] = useState<'idle' | 'submitting' | 'success' | 'error'>('idle');\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Form fields */}\n\n      {/* Live region announces status changes */}\n      <div\n        role=\"status\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n        className=\"sr-only\"\n      >\n        {status === 'submitting' && 'Submitting form...'}\n        {status === 'success' && 'Form submitted successfully'}\n        {status === 'error' && 'Form submission failed. Please check errors.'}\n      </div>\n\n      {/* Visual status (also shown) */}\n      {status === 'success' && (\n        <div className=\"success-message\">Thank you! Form submitted.</div>\n      )}\n    </form>\n  );\n}\n```\n\n---\n\n## Pattern 5: Focus Management\n\nFocus first error on submit failure.\n\n```tsx\nconst { setFocus, formState: { errors } } = useForm();\n\nconst onSubmit = async (data) => {\n  try {\n    await api.submit(data);\n  } catch (error) {\n    // Focus first error field\n    const firstErrorField = Object.keys(errors)[0];\n    if (firstErrorField) {\n      setFocus(firstErrorField);\n    }\n  }\n};\n```\n\n**Auto-focus first field on page load** (only if form is primary content):\n```tsx\nuseEffect(() => {\n  const firstInput = document.querySelector('input');\n  firstInput?.focus();\n}, []);\n```\n\n---\n\n## Pattern 6: Keyboard Navigation\n\nAll interactive elements must be keyboard-accessible.\n\n```tsx\n// ✅ Custom checkbox with keyboard support\n<label>\n  <input\n    type=\"checkbox\"\n    className=\"sr-only\"\n    {...register('terms')}\n  />\n  <span\n    role=\"checkbox\"\n    aria-checked={watch('terms')}\n    tabIndex={0}\n    onKeyDown={(e) => {\n      if (e.key === ' ' || e.key === 'Enter') {\n        e.preventDefault();\n        setValue('terms', !watch('terms'));\n      }\n    }}\n    className=\"custom-checkbox\"\n  />\n  I agree to the terms\n</label>\n```\n\n**Tab order**: Ensure `tabindex` follows logical flow (top-to-bottom, left-to-right).\n\n---\n\n## Pattern 7: Fieldset and Legend\n\nGroup related fields semantically.\n\n```tsx\n<fieldset>\n  <legend>Shipping Address</legend>\n\n  <label htmlFor=\"street\">Street Address</label>\n  <input id=\"street\" name=\"street\" />\n\n  <label htmlFor=\"city\">City</label>\n  <input id=\"city\" name=\"city\" />\n\n  <label htmlFor=\"zipCode\">ZIP Code</label>\n  <input id=\"zipCode\" name=\"zipCode\" />\n</fieldset>\n\n<fieldset>\n  <legend>Payment Method</legend>\n\n  <label>\n    <input type=\"radio\" name=\"paymentMethod\" value=\"card\" />\n    Credit Card\n  </label>\n\n  <label>\n    <input type=\"radio\" name=\"paymentMethod\" value=\"paypal\" />\n    PayPal\n  </label>\n</fieldset>\n```\n\n**Why**: Screen readers announce the legend when entering the fieldset.\n\n---\n\n## Pattern 8: Instructions and Help Text\n\nProvide context before users start typing.\n\n```tsx\n<label htmlFor=\"password\">\n  Password\n  <span id=\"password-requirements\" className=\"help-text\">\n    Must be at least 8 characters with one uppercase letter and one number\n  </span>\n</label>\n<input\n  id=\"password\"\n  type=\"password\"\n  aria-describedby=\"password-requirements\"\n/>\n```\n\n**Progressive disclosure for complex instructions**:\n```tsx\n<label htmlFor=\"taxId\">Tax ID</label>\n<button\n  type=\"button\"\n  aria-expanded={showHelp}\n  aria-controls=\"taxid-help\"\n  onClick={() => setShowHelp(!showHelp)}\n>\n  What's this?\n</button>\n{showHelp && (\n  <div id=\"taxid-help\" role=\"region\">\n    Your Tax ID is a 9-digit number assigned by the IRS...\n  </div>\n)}\n<input id=\"taxId\" aria-describedby=\"taxid-help\" />\n```\n\n---\n\n## Pattern 9: Color Contrast\n\nWCAG AA requires minimum contrast ratios.\n\n**Text Contrast**:\n- Normal text: 4.5:1\n- Large text (18pt+): 3:1\n- UI components: 3:1\n\n```css\n/* ✅ Good contrast */\n.error {\n  color: #d32f2f; /* Red text */\n  background: #ffffff; /* White bg */\n  /* Contrast ratio: 5.0:1 */\n}\n\n/* ❌ Poor contrast */\n.error {\n  color: #ff9999; /* Light red */\n  background: #ffffff;\n  /* Contrast ratio: 2.1:1 - FAILS */\n}\n```\n\n**Don't rely on color alone**:\n```tsx\n// ❌ Only color indicates error\n<input className={errors.email ? 'input-error' : ''} />\n\n// ✅ Icon + color + text\n<input className={errors.email ? 'input-error' : ''} />\n{errors.email && (\n  <span className=\"error\">\n    <IconError aria-hidden=\"true\" />\n    {errors.email.message}\n  </span>\n)}\n```\n\n---\n\n## Pattern 10: Screen Reader Only Content\n\nHide visual clutter, provide context for assistive tech.\n\n```css\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n```\n\n**Usage**:\n```tsx\n<button type=\"submit\">\n  <IconPaperPlane aria-hidden=\"true\" />\n  <span className=\"sr-only\">Submit form</span>\n</button>\n```\n\n---\n\n## Pattern 11: Time Limits\n\nAllow users to extend or disable timeouts.\n\n```tsx\nfunction TimedForm() {\n  const [timeLeft, setTimeLeft] = useState(300); // 5 minutes\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setTimeLeft((t) => Math.max(0, t - 1));\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n\n  // Warn at 1 minute remaining\n  const showWarning = timeLeft <= 60 && timeLeft > 0;\n\n  return (\n    <form>\n      {showWarning && (\n        <div role=\"alert\" className=\"warning\">\n          ⏰ {timeLeft} seconds remaining.\n          <button\n            type=\"button\"\n            onClick={() => setTimeLeft(300)}\n          >\n            Extend time\n          </button>\n        </div>\n      )}\n\n      {/* Form fields */}\n    </form>\n  );\n}\n```\n\n---\n\n## Pattern 12: Multi-Step Forms (Wizard)\n\nIndicate progress and allow navigation.\n\n```tsx\n<div role=\"group\" aria-labelledby=\"wizard-title\">\n  <h2 id=\"wizard-title\">Account Setup</h2>\n\n  {/* Progress indicator */}\n  <nav aria-label=\"Form progress\">\n    <ol className=\"wizard-steps\">\n      <li aria-current={step === 1 ? 'step' : undefined}>\n        Personal Info\n      </li>\n      <li aria-current={step === 2 ? 'step' : undefined}>\n        Address\n      </li>\n      <li aria-current={step === 3 ? 'step' : undefined}>\n        Payment\n      </li>\n    </ol>\n  </nav>\n\n  {/* Announce step changes */}\n  <div role=\"status\" aria-live=\"polite\" className=\"sr-only\">\n    Step {step} of 3: {stepTitles[step]}\n  </div>\n\n  {/* Step content */}\n  <div role=\"region\" aria-labelledby={`step-${step}-title`}>\n    <h3 id={`step-${step}-title`}>{stepTitles[step]}</h3>\n    {/* Fields */}\n  </div>\n</div>\n```\n\n---\n\n## Testing Tools\n\n### Automated Testing\n- **axe DevTools**: Browser extension for WCAG violations\n- **pa11y**: CLI tool for automated accessibility testing\n- **WAVE**: Web Accessibility Evaluation Tool\n\n```bash\n# Run pa11y on form page\nnpx pa11y http://localhost:3000/signup\n```\n\n### Manual Testing\n1. **Keyboard only**: Tab through form, submit with Enter\n2. **Screen reader**: Test with NVDA (Windows), JAWS, or VoiceOver (Mac)\n3. **Zoom**: Test at 200% zoom (WCAG requirement)\n4. **High contrast**: Enable high contrast mode (Windows)\n\n**VoiceOver (Mac)**:\n- Enable: Cmd + F5\n- Navigate: VO + Right Arrow\n- Interact: VO + Space\n\n---\n\n## Production Checklist\n\n```\n□ All inputs have visible labels\n□ Required fields indicated with text (not just *)\n□ Errors announced with role=\"alert\"\n□ aria-invalid on fields with errors\n□ Focus moves to first error on submit failure\n□ Color contrast ≥ 4.5:1\n□ Form completable with keyboard only\n□ Tab order is logical\n□ Fieldsets group related fields\n□ Help text associated with aria-describedby\n□ Success/error messages use live regions\n□ Time limits can be extended\n□ Multi-step progress is announced\n□ Tested with screen reader\n□ No reliance on color alone for meaning\n```\n\n---\n\n## Resources\n\n- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)\n- [MDN: Accessible Forms](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#accessible_error_messages)\n- [WebAIM: Form Accessibility](https://webaim.org/techniques/forms/)\n- [A11y Project: Checklist](https://www.a11yproject.com/checklist/)\n"
        },
        {
          "name": "file-upload.md",
          "type": "file",
          "path": "form-validation-architect/references/file-upload.md",
          "size": 14711,
          "content": "# File Upload with Progress Tracking\n\nProduction patterns for handling file uploads in forms with validation, progress indicators, and error handling.\n\n## Pattern 1: Basic File Upload with Validation\n\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\nconst ACCEPTED_TYPES = ['image/jpeg', 'image/png', 'image/webp'];\n\nconst schema = z.object({\n  avatar: z\n    .instanceof(File)\n    .refine((file) => file.size <= MAX_FILE_SIZE, {\n      message: 'File must be less than 5MB'\n    })\n    .refine((file) => ACCEPTED_TYPES.includes(file.type), {\n      message: 'Only JPEG, PNG, and WebP images allowed'\n    })\n});\n\nfunction FileUploadForm() {\n  const { register, handleSubmit, formState: { errors } } = useForm({\n    resolver: zodResolver(schema)\n  });\n\n  const onSubmit = async (data: { avatar: File }) => {\n    const formData = new FormData();\n    formData.append('avatar', data.avatar);\n\n    await fetch('/api/upload', {\n      method: 'POST',\n      body: formData\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <label htmlFor=\"avatar\">Profile Picture</label>\n      <input\n        id=\"avatar\"\n        type=\"file\"\n        accept=\"image/jpeg,image/png,image/webp\"\n        {...register('avatar', {\n          // Convert FileList to File\n          setValueAs: (files: FileList) => files[0]\n        })}\n      />\n      {errors.avatar && (\n        <span className=\"error\">{errors.avatar.message}</span>\n      )}\n\n      <button type=\"submit\">Upload</button>\n    </form>\n  );\n}\n```\n\n---\n\n## Pattern 2: Preview Before Upload\n\nShow image preview before submitting.\n\n```typescript\nfunction ImageUploadWithPreview() {\n  const [preview, setPreview] = useState<string | null>(null);\n  const { register, watch } = useForm();\n\n  const file = watch('image')?.[0];\n\n  useEffect(() => {\n    if (!file) {\n      setPreview(null);\n      return;\n    }\n\n    const objectUrl = URL.createObjectURL(file);\n    setPreview(objectUrl);\n\n    // Cleanup\n    return () => URL.revokeObjectURL(objectUrl);\n  }, [file]);\n\n  return (\n    <div>\n      <input\n        type=\"file\"\n        accept=\"image/*\"\n        {...register('image')}\n      />\n\n      {preview && (\n        <div className=\"preview\">\n          <img src={preview} alt=\"Preview\" style={{ maxWidth: 300 }} />\n          <button\n            type=\"button\"\n            onClick={() => {\n              setPreview(null);\n              setValue('image', null);\n            }}\n          >\n            Remove\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 3: Upload Progress with XMLHttpRequest\n\nTrack upload progress for large files.\n\n```typescript\nfunction UploadWithProgress() {\n  const [progress, setProgress] = useState(0);\n  const [uploading, setUploading] = useState(false);\n\n  const uploadFile = async (file: File) => {\n    setUploading(true);\n    setProgress(0);\n\n    const formData = new FormData();\n    formData.append('file', file);\n\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n\n      // Track upload progress\n      xhr.upload.addEventListener('progress', (e) => {\n        if (e.lengthComputable) {\n          const percentComplete = (e.loaded / e.total) * 100;\n          setProgress(percentComplete);\n        }\n      });\n\n      xhr.addEventListener('load', () => {\n        setUploading(false);\n        if (xhr.status === 200) {\n          resolve(JSON.parse(xhr.responseText));\n        } else {\n          reject(new Error('Upload failed'));\n        }\n      });\n\n      xhr.addEventListener('error', () => {\n        setUploading(false);\n        reject(new Error('Network error'));\n      });\n\n      xhr.open('POST', '/api/upload');\n      xhr.send(formData);\n    });\n  };\n\n  return (\n    <div>\n      <input\n        type=\"file\"\n        onChange={(e) => {\n          const file = e.target.files?.[0];\n          if (file) uploadFile(file);\n        }}\n        disabled={uploading}\n      />\n\n      {uploading && (\n        <div className=\"progress-container\">\n          <div\n            className=\"progress-bar\"\n            style={{ width: `${progress}%` }}\n          />\n          <span>{Math.round(progress)}%</span>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 4: Multiple File Upload\n\nHandle multiple files with individual progress tracking.\n\n```typescript\ninterface FileUpload {\n  id: string;\n  file: File;\n  progress: number;\n  status: 'pending' | 'uploading' | 'complete' | 'error';\n  error?: string;\n}\n\nfunction MultiFileUpload() {\n  const [uploads, setUploads] = useState<FileUpload[]>([]);\n\n  const handleFileSelect = (files: FileList) => {\n    const newUploads = Array.from(files).map((file) => ({\n      id: Math.random().toString(36),\n      file,\n      progress: 0,\n      status: 'pending' as const\n    }));\n\n    setUploads((prev) => [...prev, ...newUploads]);\n\n    // Start uploading\n    newUploads.forEach((upload) => uploadFile(upload));\n  };\n\n  const uploadFile = async (upload: FileUpload) => {\n    setUploads((prev) =>\n      prev.map((u) =>\n        u.id === upload.id ? { ...u, status: 'uploading' } : u\n      )\n    );\n\n    const formData = new FormData();\n    formData.append('file', upload.file);\n\n    try {\n      const xhr = new XMLHttpRequest();\n\n      xhr.upload.addEventListener('progress', (e) => {\n        if (e.lengthComputable) {\n          const progress = (e.loaded / e.total) * 100;\n          setUploads((prev) =>\n            prev.map((u) =>\n              u.id === upload.id ? { ...u, progress } : u\n            )\n          );\n        }\n      });\n\n      await new Promise((resolve, reject) => {\n        xhr.addEventListener('load', () => {\n          if (xhr.status === 200) resolve(xhr.response);\n          else reject(new Error('Upload failed'));\n        });\n        xhr.addEventListener('error', reject);\n        xhr.open('POST', '/api/upload');\n        xhr.send(formData);\n      });\n\n      setUploads((prev) =>\n        prev.map((u) =>\n          u.id === upload.id ? { ...u, status: 'complete', progress: 100 } : u\n        )\n      );\n    } catch (error) {\n      setUploads((prev) =>\n        prev.map((u) =>\n          u.id === upload.id\n            ? { ...u, status: 'error', error: error.message }\n            : u\n        )\n      );\n    }\n  };\n\n  const removeUpload = (id: string) => {\n    setUploads((prev) => prev.filter((u) => u.id !== id));\n  };\n\n  return (\n    <div>\n      <input\n        type=\"file\"\n        multiple\n        onChange={(e) => {\n          if (e.target.files) handleFileSelect(e.target.files);\n        }}\n      />\n\n      <div className=\"upload-list\">\n        {uploads.map((upload) => (\n          <div key={upload.id} className=\"upload-item\">\n            <span>{upload.file.name}</span>\n\n            {upload.status === 'uploading' && (\n              <div className=\"progress\">\n                <div style={{ width: `${upload.progress}%` }} />\n              </div>\n            )}\n\n            {upload.status === 'complete' && (\n              <span className=\"success\">✓ Uploaded</span>\n            )}\n\n            {upload.status === 'error' && (\n              <span className=\"error\">{upload.error}</span>\n            )}\n\n            <button onClick={() => removeUpload(upload.id)}>\n              Remove\n            </button>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 5: Drag and Drop\n\nEnhance UX with drag-and-drop support.\n\n```typescript\nfunction DragDropUpload() {\n  const [isDragging, setIsDragging] = useState(false);\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragging(true);\n  };\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragging(false);\n  };\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragging(false);\n\n    const files = Array.from(e.dataTransfer.files);\n    handleFiles(files);\n  };\n\n  const handleFiles = (files: File[]) => {\n    files.forEach((file) => {\n      // Validate and upload\n      if (file.size > MAX_FILE_SIZE) {\n        alert(`${file.name} is too large`);\n        return;\n      }\n      uploadFile(file);\n    });\n  };\n\n  return (\n    <div\n      className={`dropzone ${isDragging ? 'dragging' : ''}`}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n    >\n      <input\n        type=\"file\"\n        multiple\n        onChange={(e) => {\n          if (e.target.files) handleFiles(Array.from(e.target.files));\n        }}\n        style={{ display: 'none' }}\n        id=\"file-input\"\n      />\n\n      <label htmlFor=\"file-input\" className=\"drop-label\">\n        {isDragging ? (\n          <>Drop files here</>\n        ) : (\n          <>\n            Drag & drop files here, or <span className=\"link\">browse</span>\n          </>\n        )}\n      </label>\n    </div>\n  );\n}\n```\n\n**Styles**:\n```css\n.dropzone {\n  border: 2px dashed #ccc;\n  border-radius: 8px;\n  padding: 40px;\n  text-align: center;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.dropzone.dragging {\n  border-color: #4CAF50;\n  background: #f0f9f0;\n}\n\n.dropzone .link {\n  color: #2196F3;\n  text-decoration: underline;\n}\n```\n\n---\n\n## Pattern 6: Chunked Upload (Large Files)\n\nSplit large files into chunks for reliable uploads.\n\n```typescript\nconst CHUNK_SIZE = 1024 * 1024; // 1MB chunks\n\nasync function uploadFileInChunks(file: File) {\n  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n  const uploadId = Math.random().toString(36);\n\n  for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n    const start = chunkIndex * CHUNK_SIZE;\n    const end = Math.min(start + CHUNK_SIZE, file.size);\n    const chunk = file.slice(start, end);\n\n    const formData = new FormData();\n    formData.append('chunk', chunk);\n    formData.append('uploadId', uploadId);\n    formData.append('chunkIndex', chunkIndex.toString());\n    formData.append('totalChunks', totalChunks.toString());\n    formData.append('fileName', file.name);\n\n    await fetch('/api/upload-chunk', {\n      method: 'POST',\n      body: formData\n    });\n\n    // Update progress\n    const progress = ((chunkIndex + 1) / totalChunks) * 100;\n    console.log(`Upload progress: ${progress}%`);\n  }\n\n  // Finalize upload (merge chunks on server)\n  await fetch('/api/finalize-upload', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ uploadId, fileName: file.name })\n  });\n}\n```\n\n**Server-side (Node.js example)**:\n```typescript\n// Receive chunk\napp.post('/api/upload-chunk', async (req, res) => {\n  const { uploadId, chunkIndex, totalChunks, fileName } = req.body;\n  const chunk = req.files.chunk;\n\n  const chunkDir = path.join('/tmp/uploads', uploadId);\n  await fs.mkdir(chunkDir, { recursive: true });\n\n  const chunkPath = path.join(chunkDir, `chunk-${chunkIndex}`);\n  await chunk.mv(chunkPath);\n\n  res.json({ success: true });\n});\n\n// Merge chunks\napp.post('/api/finalize-upload', async (req, res) => {\n  const { uploadId, fileName } = req.body;\n  const chunkDir = path.join('/tmp/uploads', uploadId);\n\n  const finalPath = path.join('/uploads', fileName);\n  const writeStream = fs.createWriteStream(finalPath);\n\n  const chunkFiles = await fs.readdir(chunkDir);\n  chunkFiles.sort((a, b) => {\n    const aIndex = parseInt(a.split('-')[1]);\n    const bIndex = parseInt(b.split('-')[1]);\n    return aIndex - bIndex;\n  });\n\n  for (const chunkFile of chunkFiles) {\n    const chunkPath = path.join(chunkDir, chunkFile);\n    const data = await fs.readFile(chunkPath);\n    writeStream.write(data);\n  }\n\n  writeStream.end();\n  await fs.rm(chunkDir, { recursive: true });\n\n  res.json({ success: true, url: `/uploads/${fileName}` });\n});\n```\n\n---\n\n## Pattern 7: Image Compression Before Upload\n\nReduce file size client-side before uploading.\n\n```typescript\nasync function compressImage(file: File, maxWidth = 1920): Promise<Blob> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d')!;\n\n    img.onload = () => {\n      const scaleFactor = Math.min(1, maxWidth / img.width);\n      canvas.width = img.width * scaleFactor;\n      canvas.height = img.height * scaleFactor;\n\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n      canvas.toBlob(\n        (blob) => {\n          if (blob) resolve(blob);\n          else reject(new Error('Compression failed'));\n        },\n        'image/jpeg',\n        0.9 // Quality (0-1)\n      );\n    };\n\n    img.onerror = reject;\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n// Usage\nasync function handleImageUpload(file: File) {\n  if (file.size > 2 * 1024 * 1024) {\n    // Compress if > 2MB\n    const compressed = await compressImage(file);\n    uploadFile(compressed);\n  } else {\n    uploadFile(file);\n  }\n}\n```\n\n---\n\n## Production Checklist\n\n```\n□ File size validation (client + server)\n□ File type validation (MIME type check)\n□ Progress indicator for uploads &gt;1MB\n□ Error handling with retry capability\n□ Cancel upload functionality\n□ Image compression for large files\n□ Chunked upload for files &gt;10MB\n□ Drag-and-drop support\n□ Preview for image uploads\n□ Accessible file input labels\n□ Security: virus scanning on server\n□ Security: filename sanitization\n□ Security: storage quota enforcement\n□ HTTPS required for uploads\n```\n\n---\n\n## Security Considerations\n\n1. **Validate MIME type on server**: Don't trust client-side checks\n2. **Rename files**: Avoid executing uploaded scripts\n3. **Store outside web root**: Prevent direct access\n4. **Virus scanning**: Use ClamAV or similar\n5. **Rate limiting**: Prevent abuse\n6. **Authentication**: Require login for uploads\n\n```typescript\n// Server-side validation (Node.js)\nimport fileType from 'file-type';\n\napp.post('/upload', async (req, res) => {\n  const file = req.files.upload;\n\n  // Validate actual file type\n  const type = await fileType.fromBuffer(file.data);\n  if (!['image/jpeg', 'image/png'].includes(type.mime)) {\n    return res.status(400).json({ error: 'Invalid file type' });\n  }\n\n  // Generate safe filename\n  const ext = type.ext;\n  const safeName = `${Date.now()}-${Math.random().toString(36)}.${ext}`;\n\n  // Store outside public directory\n  await file.mv(`/var/uploads/${safeName}`);\n\n  res.json({ url: `/files/${safeName}` });\n});\n```\n\n---\n\n## Resources\n\n- [MDN: File API](https://developer.mozilla.org/en-US/docs/Web/API/File_API)\n- [MDN: FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n- [react-dropzone](https://react-dropzone.js.org/) - Popular drag-and-drop library\n- [Uppy](https://uppy.io/) - Full-featured upload library\n"
        },
        {
          "name": "zod-patterns.md",
          "type": "file",
          "path": "form-validation-architect/references/zod-patterns.md",
          "size": 9094,
          "content": "# Advanced Zod Schema Patterns\n\nProduction patterns for complex validation with Zod.\n\n## Pattern 1: Conditional Validation (Dependent Fields)\n\nValidate field B based on field A's value.\n\n```typescript\nconst schema = z.object({\n  accountType: z.enum(['personal', 'business']),\n  businessName: z.string().optional(),\n  taxId: z.string().optional()\n}).refine(\n  (data) => {\n    if (data.accountType === 'business') {\n      return !!data.businessName && !!data.taxId;\n    }\n    return true;\n  },\n  {\n    message: 'Business name and tax ID required for business accounts',\n    path: ['businessName'] // Error appears on this field\n  }\n);\n```\n\n## Pattern 2: Cross-Field Validation\n\nValidate relationships between multiple fields.\n\n```typescript\nconst dateRangeSchema = z.object({\n  startDate: z.date(),\n  endDate: z.date()\n}).refine(\n  (data) => data.endDate > data.startDate,\n  {\n    message: 'End date must be after start date',\n    path: ['endDate']\n  }\n);\n\n// Password confirmation\nconst passwordSchema = z.object({\n  password: z.string().min(8),\n  confirmPassword: z.string()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  {\n    message: 'Passwords do not match',\n    path: ['confirmPassword']\n  }\n);\n```\n\n## Pattern 3: Transform and Sanitize\n\nClean user input before validation.\n\n```typescript\nconst phoneSchema = z.string()\n  .transform((val) => val.replace(/\\D/g, '')) // Remove non-digits\n  .pipe(\n    z.string()\n      .length(10, 'Phone must be 10 digits')\n      .regex(/^[2-9]/, 'Invalid area code')\n  );\n\n// Email normalization\nconst emailSchema = z.string()\n  .email()\n  .transform((val) => val.toLowerCase().trim());\n\n// Currency parsing\nconst priceSchema = z.string()\n  .transform((val) => parseFloat(val.replace(/[$,]/g, '')))\n  .pipe(\n    z.number()\n      .positive('Price must be positive')\n      .max(1000000, 'Price too high')\n  );\n```\n\n## Pattern 4: Union Types with Discriminators\n\nType-safe unions for polymorphic data.\n\n```typescript\nconst paymentSchema = z.discriminatedUnion('method', [\n  z.object({\n    method: z.literal('card'),\n    cardNumber: z.string().regex(/^\\d{16}$/),\n    cvv: z.string().regex(/^\\d{3}$/)\n  }),\n  z.object({\n    method: z.literal('paypal'),\n    email: z.string().email()\n  }),\n  z.object({\n    method: z.literal('bank'),\n    accountNumber: z.string(),\n    routingNumber: z.string()\n  })\n]);\n\ntype Payment = z.infer<typeof paymentSchema>;\n// TypeScript knows which fields exist based on 'method'\n```\n\n## Pattern 5: Recursive Schemas\n\nSelf-referential data structures (comments, file trees).\n\n```typescript\ninterface Comment {\n  id: string;\n  text: string;\n  replies: Comment[];\n}\n\nconst commentSchema: z.ZodType<Comment> = z.lazy(() =>\n  z.object({\n    id: z.string(),\n    text: z.string().min(1).max(500),\n    replies: z.array(commentSchema)\n  })\n);\n\n// File system tree\nconst fileNodeSchema: z.ZodType<any> = z.lazy(() =>\n  z.object({\n    name: z.string(),\n    type: z.enum(['file', 'folder']),\n    children: z.array(fileNodeSchema).optional()\n  })\n);\n```\n\n## Pattern 6: Custom Validators (refine)\n\nComplex business logic validation.\n\n```typescript\n// Check username availability (async)\nconst usernameSchema = z.string()\n  .min(3)\n  .max(20)\n  .regex(/^[a-z0-9_]+$/, 'Lowercase, numbers, underscores only')\n  .refine(\n    async (username) => {\n      const response = await fetch(`/api/check-username?q=${username}`);\n      return response.ok;\n    },\n    { message: 'Username already taken' }\n  );\n\n// Validate file size\nconst fileSchema = z.instanceof(File)\n  .refine(\n    (file) => file.size <= 5 * 1024 * 1024,\n    { message: 'File must be less than 5MB' }\n  )\n  .refine(\n    (file) => ['image/jpeg', 'image/png'].includes(file.type),\n    { message: 'Only JPEG and PNG allowed' }\n  );\n\n// Business hours validation\nconst appointmentSchema = z.object({\n  date: z.date()\n}).refine(\n  (data) => {\n    const day = data.date.getDay();\n    const hour = data.date.getHours();\n    return day >= 1 && day <= 5 && hour >= 9 && hour < 17;\n  },\n  { message: 'Appointments only available Mon-Fri, 9 AM - 5 PM' }\n);\n```\n\n## Pattern 7: Schema Composition (Reuse)\n\nBuild complex schemas from primitives.\n\n```typescript\n// Base schemas\nconst emailField = z.string().email('Invalid email');\nconst passwordField = z.string()\n  .min(8, 'At least 8 characters')\n  .regex(/[A-Z]/, 'Needs uppercase')\n  .regex(/[0-9]/, 'Needs number');\n\n// Compose into registration\nconst registrationSchema = z.object({\n  email: emailField,\n  password: passwordField,\n  confirmPassword: z.string()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  { path: ['confirmPassword'], message: 'Passwords must match' }\n);\n\n// Extend for profile update\nconst profileUpdateSchema = registrationSchema\n  .omit({ password: true, confirmPassword: true })\n  .extend({\n    firstName: z.string().min(1),\n    lastName: z.string().min(1),\n    bio: z.string().max(500).optional()\n  });\n```\n\n## Pattern 8: Partial and Pick\n\nCreate variations of schemas.\n\n```typescript\nconst userSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  firstName: z.string(),\n  lastName: z.string(),\n  role: z.enum(['admin', 'user'])\n});\n\n// For updates: all fields optional\nconst userUpdateSchema = userSchema.partial();\n\n// For creation: omit auto-generated fields\nconst userCreateSchema = userSchema.omit({ id: true });\n\n// For public API: only safe fields\nconst userPublicSchema = userSchema.pick({\n  id: true,\n  firstName: true,\n  lastName: true\n});\n```\n\n## Pattern 9: Default Values and Preprocessing\n\nSet defaults before validation.\n\n```typescript\nconst configSchema = z.object({\n  theme: z.enum(['light', 'dark']).default('light'),\n  notifications: z.boolean().default(true),\n  itemsPerPage: z.number().min(10).max(100).default(25),\n  tags: z.array(z.string()).default([])\n});\n\n// Preprocessing: Normalize before validate\nconst searchSchema = z.object({\n  query: z.string().trim().min(1),\n  filters: z.record(z.string()).default({})\n}).transform((data) => ({\n  ...data,\n  query: data.query.toLowerCase()\n}));\n```\n\n## Pattern 10: Error Customization\n\nProvide context-aware error messages.\n\n```typescript\nconst schema = z.object({\n  age: z.number({\n    required_error: 'Age is required',\n    invalid_type_error: 'Age must be a number'\n  })\n    .min(18, 'Must be at least 18 years old')\n    .max(120, 'Age seems invalid'),\n\n  email: z.string({\n    required_error: 'Email address is required'\n  }).email({\n    message: 'Please enter a valid email address'\n  })\n});\n\n// Custom error map for entire form\nconst customErrorMap: z.ZodErrorMap = (issue, ctx) => {\n  if (issue.code === z.ZodIssueCode.invalid_type) {\n    if (issue.expected === 'string') {\n      return { message: 'This field must be text' };\n    }\n  }\n  return { message: ctx.defaultError };\n};\n\nz.setErrorMap(customErrorMap);\n```\n\n## Pattern 11: Branded Types\n\nCreate distinct types for primitives.\n\n```typescript\n// Prevent mixing userId with productId\nconst UserIdSchema = z.string().uuid().brand('UserId');\ntype UserId = z.infer<typeof UserIdSchema>;\n\nconst ProductIdSchema = z.string().uuid().brand('ProductId');\ntype ProductId = z.infer<typeof ProductIdSchema>;\n\nfunction getUser(id: UserId) { /* ... */ }\nfunction getProduct(id: ProductId) { /* ... */ }\n\n// TypeScript error: userId is not assignable to ProductId\nconst userId = UserIdSchema.parse('...');\ngetProduct(userId); // ❌ Type error!\n```\n\n## Pattern 12: SuperRefine (Multiple Errors)\n\nReturn multiple validation errors at once.\n\n```typescript\nconst schema = z.object({\n  password: z.string(),\n  confirmPassword: z.string()\n}).superRefine((data, ctx) => {\n  if (data.password.length < 8) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_small,\n      minimum: 8,\n      type: 'string',\n      inclusive: true,\n      path: ['password'],\n      message: 'Password must be at least 8 characters'\n    });\n  }\n\n  if (!/[A-Z]/.test(data.password)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['password'],\n      message: 'Password must contain an uppercase letter'\n    });\n  }\n\n  if (data.password !== data.confirmPassword) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['confirmPassword'],\n      message: 'Passwords do not match'\n    });\n  }\n});\n```\n\n## Production Checklist\n\n```\n□ All user inputs validated with Zod\n□ Error messages are user-friendly (not technical)\n□ Async validation debounced (500ms+)\n□ File uploads have size/type constraints\n□ Dates validated for business logic (hours, holidays)\n□ Dependent fields use refine() properly\n□ Schemas reused via composition (DRY)\n□ Custom error maps for i18n\n□ Branded types for IDs prevent mixing\n□ SuperRefine for complex multi-field validation\n```\n\n## Common Pitfalls\n\n1. **Async refine without debounce**: Spams API on every keystroke\n2. **Missing path in refine**: Error appears on wrong field\n3. **Transform before validation**: Use .pipe() to validate after transform\n4. **Not using discriminatedUnion**: Poor TypeScript inference on unions\n5. **Overly strict regex**: Rejects valid input (international phone numbers, etc.)\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "form-validation-architect/scripts",
      "children": [
        {
          "name": "generate_form.ts",
          "type": "file",
          "path": "form-validation-architect/scripts/generate_form.ts",
          "size": 4851,
          "content": "#!/usr/bin/env node\n/**\n * Generate React Hook Form components from Zod schemas\n *\n * Usage: npx tsx generate_form.ts <schema-file> <output-file>\n *\n * Example:\n *   npx tsx generate_form.ts ./schemas/login.ts ./components/LoginForm.tsx\n *\n * Dependencies: npm install zod react-hook-form @hookform/resolvers\n */\n\nimport { z } from 'zod';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface FieldConfig {\n  name: string;\n  type: 'text' | 'email' | 'password' | 'number' | 'checkbox' | 'textarea' | 'select';\n  label: string;\n  placeholder?: string;\n  options?: string[];\n}\n\nfunction inferFieldType(zodSchema: z.ZodTypeAny): FieldConfig['type'] {\n  if (zodSchema instanceof z.ZodString) {\n    const checks = (zodSchema as any)._def.checks || [];\n    if (checks.some((c: any) => c.kind === 'email')) return 'email';\n    return 'text';\n  }\n  if (zodSchema instanceof z.ZodNumber) return 'number';\n  if (zodSchema instanceof z.ZodBoolean) return 'checkbox';\n  if (zodSchema instanceof z.ZodEnum) return 'select';\n  return 'text';\n}\n\nfunction generateFormComponent(\n  schemaName: string,\n  fields: FieldConfig[],\n  componentName: string\n): string {\n  const imports = `import { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { ${schemaName} } from './schemas';\nimport type { z } from 'zod';\n\ntype FormData = z.infer<typeof ${schemaName}>;\n`;\n\n  const formFields = fields.map(field => {\n    if (field.type === 'checkbox') {\n      return `      <div className=\"form-field\">\n        <label>\n          <input\n            {...register('${field.name}')}\n            type=\"checkbox\"\n          />\n          ${field.label}\n        </label>\n        {errors.${field.name} && (\n          <span className=\"error\">{errors.${field.name}.message}</span>\n        )}\n      </div>`;\n    }\n\n    if (field.type === 'select' && field.options) {\n      return `      <div className=\"form-field\">\n        <label htmlFor=\"${field.name}\">${field.label}</label>\n        <select {...register('${field.name}')} id=\"${field.name}\">\n          <option value=\"\">Select...</option>\n          ${field.options.map(opt => `<option value=\"${opt}\">${opt}</option>`).join('\\n          ')}\n        </select>\n        {errors.${field.name} && (\n          <span className=\"error\">{errors.${field.name}.message}</span>\n        )}\n      </div>`;\n    }\n\n    if (field.type === 'textarea') {\n      return `      <div className=\"form-field\">\n        <label htmlFor=\"${field.name}\">${field.label}</label>\n        <textarea\n          {...register('${field.name}')}\n          id=\"${field.name}\"\n          placeholder=\"${field.placeholder || ''}\"\n          rows={4}\n        />\n        {errors.${field.name} && (\n          <span className=\"error\">{errors.${field.name}.message}</span>\n        )}\n      </div>`;\n    }\n\n    return `      <div className=\"form-field\">\n        <label htmlFor=\"${field.name}\">${field.label}</label>\n        <input\n          {...register('${field.name}'${field.type === 'number' ? ', { valueAsNumber: true }' : ''})}\n          type=\"${field.type}\"\n          id=\"${field.name}\"\n          placeholder=\"${field.placeholder || ''}\"\n        />\n        {errors.${field.name} && (\n          <span className=\"error\">{errors.${field.name}.message}</span>\n        )}\n      </div>`;\n  }).join('\\n\\n');\n\n  return `${imports}\nexport function ${componentName}() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting }\n  } = useForm<FormData>({\n    resolver: zodResolver(${schemaName})\n  });\n\n  const onSubmit = async (data: FormData) => {\n    console.log('Form submitted:', data);\n    // TODO: Add your submission logic here\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)} className=\"form-container\">\n${formFields}\n\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Submitting...' : 'Submit'}\n      </button>\n    </form>\n  );\n}\n`;\n}\n\n// Example usage\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length < 2) {\n    console.log('Usage: npx tsx generate_form.ts <schema-file> <output-file>');\n    console.log('Example: npx tsx generate_form.ts ./schemas/login.ts ./components/LoginForm.tsx');\n    process.exit(1);\n  }\n\n  // Example: Generate a login form\n  const exampleFields: FieldConfig[] = [\n    { name: 'email', type: 'email', label: 'Email Address', placeholder: 'you@example.com' },\n    { name: 'password', type: 'password', label: 'Password', placeholder: 'Enter password' },\n    { name: 'rememberMe', type: 'checkbox', label: 'Remember me' }\n  ];\n\n  const code = generateFormComponent('loginSchema', exampleFields, 'LoginForm');\n\n  console.log('Generated form component:');\n  console.log(code);\n  console.log('\\nTo customize, edit the field configurations and re-run.');\n}\n\nexport { generateFormComponent, inferFieldType };\n"
        },
        {
          "name": "validate_schemas.ts",
          "type": "file",
          "path": "form-validation-architect/scripts/validate_schemas.ts",
          "size": 6953,
          "content": "#!/usr/bin/env node\n/**\n * Zod Schema Linter - Detects common issues in Zod schemas\n *\n * Usage: npx tsx validate_schemas.ts <schema-dir>\n *\n * Checks for:\n * - Missing error messages\n * - Inconsistent error message styles\n * - Overly permissive validations\n * - Missing optional() on nullable fields\n * - Regex without examples/comments\n * - No min/max constraints on strings\n *\n * Dependencies: npm install zod typescript\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { z } from 'zod';\n\ninterface LintIssue {\n  file: string;\n  line?: number;\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  suggestion?: string;\n}\n\nclass SchemaLinter {\n  private issues: LintIssue[] = [];\n\n  /**\n   * Lint a Zod schema definition (source code analysis)\n   */\n  lintSchemaFile(filePath: string): void {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      const lineNumber = index + 1;\n\n      // Check 1: String validation without error message\n      if (line.match(/z\\.string\\(\\)\\.email\\(\\)(?!\\()/)) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'warning',\n          message: 'email() validation missing custom error message',\n          suggestion: \".email('Invalid email address')\"\n        });\n      }\n\n      if (line.match(/z\\.string\\(\\)\\.min\\(\\d+\\)(?!\\()/)) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'warning',\n          message: 'min() validation missing custom error message',\n          suggestion: \".min(8, 'Must be at least 8 characters')\"\n        });\n      }\n\n      // Check 2: Regex without comment\n      if (line.match(/\\.regex\\(\\/.*\\//) && !lines[index - 1]?.includes('//')) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'info',\n          message: 'Complex regex should have explanatory comment',\n          suggestion: 'Add comment above explaining what the regex validates'\n        });\n      }\n\n      // Check 3: String without constraints\n      if (line.match(/:\\s*z\\.string\\(\\),?\\s*$/) && !line.includes('optional')) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'info',\n          message: 'String field without min/max constraints',\n          suggestion: 'Consider adding .min() or .max() for data integrity'\n        });\n      }\n\n      // Check 4: Number without constraints\n      if (line.match(/:\\s*z\\.number\\(\\),?\\s*$/) && !line.includes('optional')) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'info',\n          message: 'Number field without min/max constraints',\n          suggestion: 'Consider adding .min() or .max() for validation'\n        });\n      }\n\n      // Check 5: Nullable without optional\n      if (line.includes('.nullable()') && !line.includes('.optional()')) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'warning',\n          message: 'nullable() without optional() - may cause confusion',\n          suggestion: 'Use .optional() for optional fields, .nullable() for null values'\n        });\n      }\n\n      // Check 6: Array without min constraint\n      if (line.match(/z\\.array\\(/) && !content.slice(content.indexOf(line)).match(/\\.min\\(\\d+\\)/)) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'info',\n          message: 'Array without minimum length validation',\n          suggestion: \"Consider .min(1, 'At least one item required')\"\n        });\n      }\n\n      // Check 7: Password field without length requirement\n      if (line.includes('password') && line.match(/z\\.string\\(\\)/) && !line.includes('.min(')) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'error',\n          message: 'Password field without minimum length requirement',\n          suggestion: \".min(8, 'Password must be at least 8 characters')\"\n        });\n      }\n\n      // Check 8: Email field not using .email()\n      if (line.includes('email') && line.match(/z\\.string\\(\\)/) && !line.includes('.email()')) {\n        this.issues.push({\n          file: filePath,\n          line: lineNumber,\n          severity: 'error',\n          message: 'Email field not using .email() validation',\n          suggestion: '.email() for built-in email validation'\n        });\n      }\n    });\n  }\n\n  /**\n   * Scan directory for schema files\n   */\n  lintDirectory(dirPath: string): void {\n    const files = fs.readdirSync(dirPath);\n\n    files.forEach(file => {\n      const fullPath = path.join(dirPath, file);\n      const stat = fs.statSync(fullPath);\n\n      if (stat.isDirectory()) {\n        this.lintDirectory(fullPath);\n      } else if (file.endsWith('.ts') && (file.includes('schema') || file.includes('validation'))) {\n        this.lintSchemaFile(fullPath);\n      }\n    });\n  }\n\n  /**\n   * Print results\n   */\n  report(): void {\n    if (this.issues.length === 0) {\n      console.log('✅ No issues found! Schemas look good.');\n      return;\n    }\n\n    const errors = this.issues.filter(i => i.severity === 'error');\n    const warnings = this.issues.filter(i => i.severity === 'warning');\n    const info = this.issues.filter(i => i.severity === 'info');\n\n    console.log(`\\n📋 Schema Validation Report\\n`);\n    console.log(`Found ${errors.length} errors, ${warnings.length} warnings, ${info.length} suggestions\\n`);\n\n    const printIssues = (issues: LintIssue[], icon: string, color: string) => {\n      if (issues.length === 0) return;\n\n      issues.forEach(issue => {\n        console.log(`${icon} ${issue.file}:${issue.line || '?'}`);\n        console.log(`  ${issue.message}`);\n        if (issue.suggestion) {\n          console.log(`  💡 ${issue.suggestion}`);\n        }\n        console.log('');\n      });\n    };\n\n    if (errors.length > 0) {\n      console.log('🚨 Errors:\\n');\n      printIssues(errors, '❌', 'red');\n    }\n\n    if (warnings.length > 0) {\n      console.log('⚠️  Warnings:\\n');\n      printIssues(warnings, '⚠️ ', 'yellow');\n    }\n\n    if (info.length > 0) {\n      console.log('💡 Suggestions:\\n');\n      printIssues(info, 'ℹ️ ', 'blue');\n    }\n\n    if (errors.length > 0) {\n      process.exit(1);\n    }\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0) {\n    console.log('Usage: npx tsx validate_schemas.ts <schema-directory>');\n    console.log('Example: npx tsx validate_schemas.ts ./src/schemas');\n    process.exit(1);\n  }\n\n  const dirPath = args[0];\n\n  if (!fs.existsSync(dirPath)) {\n    console.error(`❌ Directory not found: ${dirPath}`);\n    process.exit(1);\n  }\n\n  const linter = new SchemaLinter();\n  linter.lintDirectory(dirPath);\n  linter.report();\n}\n\nexport { SchemaLinter };\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "form-validation-architect/SKILL.md",
      "size": 14646,
      "content": "---\nname: form-validation-architect\ndescription: End-to-end form handling with react-hook-form, Zod schemas, validation patterns, error messaging, field arrays, and multi-step wizards. Use for complex forms, validation architecture, autosave, field dependencies. Activate on \"form validation\", \"react-hook-form\", \"Zod\", \"form error\", \"multi-step form\", \"wizard\". NOT for simple HTML forms, backend validation only, or non-React frameworks.\nallowed-tools: Read,Write,Edit,Bash(npm:*)\n---\n\n# Form Validation Architect\n\nExpert in building production-grade form systems with client-side validation, type safety, and excellent UX.\n\n## When to Use\n\n✅ **Use for**:\n- Complex forms with multiple fields and validation rules\n- Multi-step wizards with progress tracking\n- Dynamic field arrays (add/remove items)\n- Form state persistence across sessions\n- Async validation (check username availability, validate address)\n- Dependent fields (enable B when A is checked)\n- File uploads with progress and validation\n- Autosave and optimistic updates\n\n❌ **NOT for**:\n- Simple contact forms (HTML + basic JS is fine)\n- Backend-only validation (use Joi, Yup on server)\n- Non-React frameworks (use Formik alternatives)\n- Read-only displays (no form needed)\n\n## Quick Decision Tree\n\n```\nDoes your form:\n├── Have &gt;5 fields? → Use react-hook-form\n├── Need type safety? → Add Zod schemas\n├── Have dynamic fields? → Use field arrays\n├── Span multiple steps? → Use wizard pattern\n├── Need async validation? → Use resolver + async rules\n└── Just email/message? → Use native HTML validation\n```\n\n---\n\n## Technology Selection (2024+)\n\n### React Hook Form (Recommended)\n\n**Why RHF over Formik**:\n- **Performance**: Uncontrolled inputs → fewer re-renders\n- **Bundle size**: 8KB vs 30KB (Formik)\n- **DevEx**: Better TypeScript support\n- **Adoption**: 40k+ stars, industry standard 2023+\n\n**Timeline**:\n- 2015-2019: Formik dominated\n- 2019: React Hook Form released\n- 2022+: RHF became standard\n- 2024: Formik in maintenance mode\n\n### Zod for Schema Validation\n\n**Why Zod over Yup**:\n- **TypeScript-first**: Infer types from schemas\n- **Composability**: Better schema reuse\n- **Error messages**: More customizable\n- **Modern**: Active development, latest features\n\n**Timeline**:\n- 2017-2020: Yup standard\n- 2020: Zod released\n- 2023+: Zod preferred for new projects\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: Controlled Inputs Everywhere\n\n**Novice thinking**: \"All form inputs should be controlled with useState\"\n\n**Problem**: Causes re-render on every keystroke\n\n**Wrong approach**:\n```typescript\n// ❌ Re-renders entire component on every keystroke\nconst [email, setEmail] = useState('');\nconst [password, setPassword] = useState('');\nconst [name, setName] = useState('');\n// ... 20 more useState calls\n\n<input value={email} onChange={(e) => setEmail(e.target.value)} />\n```\n\n**Correct approach**:\n```typescript\n// ✅ Uncontrolled with react-hook-form (minimal re-renders)\nconst { register, handleSubmit } = useForm();\n\n<input {...register('email')} />\n<input {...register('password')} />\n<input {...register('name')} />\n```\n\n**Why it matters**: Forms with 10+ fields become sluggish with controlled inputs.\n\n---\n\n### Anti-Pattern 2: String-Based Validation\n\n**Problem**: No type safety, easy to make mistakes\n\n**Wrong approach**:\n```typescript\n// ❌ String validation, no types\nconst validate = (values) => {\n  if (!values.email.includes('@')) return 'Invalid email';\n  if (values.age < 18) return 'Must be 18+';\n  // Typo in field name? Runtime error!\n};\n```\n\n**Correct approach**:\n```typescript\n// ✅ Zod schema with type inference\nconst schema = z.object({\n  email: z.string().email('Invalid email'),\n  age: z.number().min(18, 'Must be 18+'),\n  username: z.string()\n    .min(3, 'Too short')\n    .regex(/^[a-z0-9_]+$/, 'Lowercase, numbers, underscores only')\n});\n\ntype FormData = z.infer<typeof schema>; // Automatic TypeScript type!\n```\n\n**Timeline**:\n- Pre-2020: String-based validation common\n- 2020+: Schema-first validation standard\n- 2024: Type inference from schemas expected\n\n---\n\n### Anti-Pattern 3: No Error State Management\n\n**Problem**: Errors shown before user interacts\n\n**Wrong approach**:\n```typescript\n// ❌ Shows errors immediately on page load\n{errors.email && <span>{errors.email}</span>}\n```\n\n**Correct approach**:\n```typescript\n// ✅ Show errors only after field is touched\nconst { formState: { errors, touchedFields } } = useForm();\n\n{touchedFields.email && errors.email && (\n  <span className=\"error\">{errors.email.message}</span>\n)}\n\n// Or: Use mode=\"onBlur\" to validate on blur\nconst form = useForm({\n  mode: 'onBlur' // Validate when user leaves field\n});\n```\n\n**Why it matters**: Better UX → user isn't yelled at before typing\n\n---\n\n### Anti-Pattern 4: No Async Validation\n\n**Problem**: Can't check username availability, validate addresses, etc.\n\n**Correct approach**:\n```typescript\n// ✅ Async validation with debounce\nconst schema = z.object({\n  username: z.string().refine(\n    async (username) => {\n      // Debounced API call\n      const available = await checkUsernameAvailability(username);\n      return available;\n    },\n    { message: 'Username already taken' }\n  )\n});\n\n// Or: Custom async validation in RHF\nregister('username', {\n  validate: {\n    checkAvailable: async (value) => {\n      const response = await fetch(`/api/check-username?q=${value}`);\n      return response.ok || 'Username taken';\n    }\n  }\n});\n```\n\n**Best practice**: Debounce async validation to avoid API spam\n\n---\n\n### Anti-Pattern 5: No Loading States\n\n**Problem**: User doesn't know validation is happening\n\n**Correct approach**:\n```typescript\n// ✅ Show loading state during async validation\nconst { formState: { isValidating, isSubmitting } } = useForm();\n\n<button disabled={isValidating || isSubmitting}>\n  {isSubmitting ? 'Submitting...' :\n   isValidating ? 'Checking...' :\n   'Submit'}\n</button>\n```\n\n---\n\n## Implementation Patterns\n\n### Pattern 1: Basic Form with Zod\n\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\n// Define schema\nconst loginSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  rememberMe: z.boolean().optional()\n});\n\ntype LoginForm = z.infer<typeof loginSchema>;\n\nfunction LoginForm() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting }\n  } = useForm<LoginForm>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: {\n      rememberMe: false\n    }\n  });\n\n  const onSubmit = async (data: LoginForm) => {\n    await api.login(data);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <input\n          {...register('email')}\n          type=\"email\"\n          placeholder=\"Email\"\n        />\n        {errors.email && <span className=\"error\">{errors.email.message}</span>}\n      </div>\n\n      <div>\n        <input\n          {...register('password')}\n          type=\"password\"\n          placeholder=\"Password\"\n        />\n        {errors.password && <span className=\"error\">{errors.password.message}</span>}\n      </div>\n\n      <div>\n        <label>\n          <input {...register('rememberMe')} type=\"checkbox\" />\n          Remember me\n        </label>\n      </div>\n\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Logging in...' : 'Login'}\n      </button>\n    </form>\n  );\n}\n```\n\n### Pattern 2: Multi-Step Wizard\n\n```typescript\nconst stepSchemas = [\n  // Step 1: Personal Info\n  z.object({\n    firstName: z.string().min(1, 'Required'),\n    lastName: z.string().min(1, 'Required'),\n    email: z.string().email()\n  }),\n  // Step 2: Address\n  z.object({\n    street: z.string().min(1, 'Required'),\n    city: z.string().min(1, 'Required'),\n    zipCode: z.string().regex(/^\\d{5}$/, 'Invalid ZIP')\n  }),\n  // Step 3: Payment\n  z.object({\n    cardNumber: z.string().regex(/^\\d{16}$/, 'Invalid card'),\n    expiry: z.string().regex(/^\\d{2}\\/\\d{2}$/, 'MM/YY format'),\n    cvv: z.string().regex(/^\\d{3}$/, '3 digits')\n  })\n];\n\nfunction MultiStepForm() {\n  const [step, setStep] = useState(0);\n  const [formData, setFormData] = useState({});\n\n  const form = useForm({\n    resolver: zodResolver(stepSchemas[step])\n  });\n\n  const nextStep = async () => {\n    const isValid = await form.trigger(); // Validate current step\n\n    if (isValid) {\n      setFormData({ ...formData, ...form.getValues() });\n      setStep(step + 1);\n    }\n  };\n\n  const prevStep = () => {\n    setFormData({ ...formData, ...form.getValues() });\n    setStep(step - 1);\n  };\n\n  const onSubmit = async (data) => {\n    const finalData = { ...formData, ...data };\n    await api.submitApplication(finalData);\n  };\n\n  return (\n    <div>\n      <progress value={step + 1} max={stepSchemas.length} />\n\n      <form onSubmit={form.handleSubmit(step === 2 ? onSubmit : nextStep)}>\n        {step === 0 && <PersonalInfoStep register={form.register} errors={form.formState.errors} />}\n        {step === 1 && <AddressStep register={form.register} errors={form.formState.errors} />}\n        {step === 2 && <PaymentStep register={form.register} errors={form.formState.errors} />}\n\n        <div>\n          {step > 0 && <button type=\"button\" onClick={prevStep}>Back</button>}\n          <button type=\"submit\">\n            {step === 2 ? 'Submit' : 'Next'}\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n}\n```\n\n### Pattern 3: Dynamic Field Arrays\n\n```typescript\nconst schema = z.object({\n  items: z.array(z.object({\n    name: z.string().min(1, 'Required'),\n    quantity: z.number().min(1, 'At least 1'),\n    price: z.number().min(0, 'Must be positive')\n  })).min(1, 'Add at least one item')\n});\n\nfunction OrderForm() {\n  const { register, control, handleSubmit, formState: { errors } } = useForm({\n    resolver: zodResolver(schema),\n    defaultValues: {\n      items: [{ name: '', quantity: 1, price: 0 }]\n    }\n  });\n\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name: 'items'\n  });\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {fields.map((field, index) => (\n        <div key={field.id}>\n          <input\n            {...register(`items.${index}.name`)}\n            placeholder=\"Item name\"\n          />\n          <input\n            {...register(`items.${index}.quantity`, { valueAsNumber: true })}\n            type=\"number\"\n          />\n          <input\n            {...register(`items.${index}.price`, { valueAsNumber: true })}\n            type=\"number\"\n            step=\"0.01\"\n          />\n          <button type=\"button\" onClick={() => remove(index)}>\n            Remove\n          </button>\n        </div>\n      ))}\n\n      <button type=\"button\" onClick={() => append({ name: '', quantity: 1, price: 0 })}>\n        Add Item\n      </button>\n\n      <button type=\"submit\">Submit Order</button>\n    </form>\n  );\n}\n```\n\n### Pattern 4: Autosave (Debounced)\n\n```typescript\nimport { useDebounce } from 'use-debounce';\nimport { useEffect } from 'react';\n\nfunction AutosaveForm() {\n  const { watch, register } = useForm();\n  const formValues = watch(); // Watch all fields\n\n  // Debounce to avoid saving on every keystroke\n  const [debouncedValues] = useDebounce(formValues, 1000);\n\n  useEffect(() => {\n    // Save to localStorage or API\n    localStorage.setItem('draft', JSON.stringify(debouncedValues));\n    // Or: await api.saveDraft(debouncedValues);\n  }, [debouncedValues]);\n\n  return (\n    <form>\n      <input {...register('title')} placeholder=\"Title\" />\n      <textarea {...register('content')} placeholder=\"Content\" />\n      <small>Autosaved</small>\n    </form>\n  );\n}\n```\n\n---\n\n## Form UX Best Practices\n\n### 1. Validate on Blur (Not on Change)\n\n```typescript\nconst form = useForm({\n  mode: 'onBlur' // Validate when user leaves field\n  // NOT 'onChange' - too aggressive\n});\n```\n\n### 2. Disable Submit While Invalid\n\n```typescript\n<button\n  type=\"submit\"\n  disabled={!form.formState.isValid || form.formState.isSubmitting}\n>\n  Submit\n</button>\n```\n\n### 3. Focus First Error on Submit\n\n```typescript\nconst onSubmit = async (data) => {\n  try {\n    await api.submit(data);\n  } catch (error) {\n    // Focus first error field\n    const firstError = Object.keys(errors)[0];\n    form.setFocus(firstError);\n  }\n};\n```\n\n### 4. Optimistic UI Updates\n\n```typescript\nconst onSubmit = async (data) => {\n  // Optimistically update UI\n  setItems([...items, data]);\n\n  try {\n    await api.createItem(data);\n  } catch (error) {\n    // Rollback on error\n    setItems(items);\n    toast.error('Failed to save');\n  }\n};\n```\n\n---\n\n## Production Checklist\n\n```\n□ Zod schemas for all forms\n□ Type inference used (z.infer<typeof schema>)\n□ Validation mode set appropriately (onBlur/onSubmit)\n□ Error messages clear and actionable\n□ Loading states for async operations\n□ Focus management on errors\n□ Autosave for long forms\n□ Form state persisted (localStorage/session)\n□ File upload progress indicators\n□ Keyboard navigation tested\n□ Accessibility (ARIA labels, error announcements)\n□ Mobile-friendly (large touch targets)\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Use This Skill? |\n|----------|-----------------|\n| User registration with validation | ✅ Yes |\n| Multi-step checkout flow | ✅ Yes |\n| Dynamic form builder | ✅ Yes |\n| Simple newsletter signup | ❌ No - use native HTML |\n| Backend-only validation | ❌ No - use Joi/Yup on server |\n| Non-React framework | ❌ No - use framework-specific solution |\n\n---\n\n## Technology Comparison\n\n| Feature | RHF + Zod | Formik + Yup | Native HTML5 |\n|---------|-----------|--------------|--------------|\n| Performance | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |\n| Type Safety | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ❌ |\n| Bundle Size | 8KB | 30KB | 0KB |\n| DevEx | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |\n| Field Arrays | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ |\n| Async Validation | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ |\n\n---\n\n## References\n\n- `/references/zod-patterns.md` - Advanced Zod schema patterns\n- `/references/accessibility.md` - Form accessibility guidelines\n- `/references/file-upload.md` - File upload with progress tracking\n\n## Scripts\n\n- `scripts/generate_form.ts` - Generate form from Zod schema\n- `scripts/validate_schemas.ts` - Lint Zod schemas for common issues\n\n## Assets\n\n- `assets/form-templates/` - Ready-to-use form components\n\n---\n\n**This skill guides**: Form validation architecture | react-hook-form patterns | Zod schema design | Multi-step wizards | Field arrays | Autosave | Async validation\n"
    }
  ]
}