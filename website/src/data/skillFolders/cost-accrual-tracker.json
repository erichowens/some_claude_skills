{
  "name": "cost-accrual-tracker",
  "type": "folder",
  "path": "cost-accrual-tracker",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "cost-accrual-tracker/references",
      "children": [
        {
          "name": "claude-api-pricing.md",
          "type": "file",
          "path": "cost-accrual-tracker/references/claude-api-pricing.md",
          "size": 5123,
          "content": "# Claude API Pricing Reference\n\n## Current Pricing (January 2026)\n\n### Claude 3.5 Sonnet (claude-3-5-sonnet-20241022)\n\n| Token Type | Price per Million Tokens |\n|------------|--------------------------|\n| Input | $3.00 |\n| Output | $15.00 |\n| Prompt Cache Write | $3.75 |\n| Prompt Cache Read | $0.30 |\n\n### Claude 3.5 Haiku (claude-3-5-haiku-20241022)\n\n| Token Type | Price per Million Tokens |\n|------------|--------------------------|\n| Input | $1.00 |\n| Output | $5.00 |\n| Prompt Cache Write | $1.25 |\n| Prompt Cache Read | $0.10 |\n\n### Claude 3 Opus (claude-3-opus-20240229)\n\n| Token Type | Price per Million Tokens |\n|------------|--------------------------|\n| Input | $15.00 |\n| Output | $75.00 |\n| Prompt Cache Write | $18.75 |\n| Prompt Cache Read | $1.50 |\n\n### Claude Opus 4.5 (claude-opus-4-5-20251101)\n\n| Token Type | Price per Million Tokens |\n|------------|--------------------------|\n| Input | $15.00 |\n| Output | $75.00 |\n| Prompt Cache Write | $18.75 |\n| Prompt Cache Read | $1.50 |\n\n## TypeScript Pricing Constants\n\n```typescript\nexport const MODEL_PRICING: Record<string, {\n  inputPerMTok: number;\n  outputPerMTok: number;\n  cacheWritePerMTok?: number;\n  cacheReadPerMTok?: number;\n}> = {\n  'claude-3-5-sonnet-20241022': {\n    inputPerMTok: 3.00,\n    outputPerMTok: 15.00,\n    cacheWritePerMTok: 3.75,\n    cacheReadPerMTok: 0.30,\n  },\n  'claude-3-5-haiku-20241022': {\n    inputPerMTok: 1.00,\n    outputPerMTok: 5.00,\n    cacheWritePerMTok: 1.25,\n    cacheReadPerMTok: 0.10,\n  },\n  'claude-3-opus-20240229': {\n    inputPerMTok: 15.00,\n    outputPerMTok: 75.00,\n    cacheWritePerMTok: 18.75,\n    cacheReadPerMTok: 1.50,\n  },\n  'claude-opus-4-5-20251101': {\n    inputPerMTok: 15.00,\n    outputPerMTok: 75.00,\n    cacheWritePerMTok: 18.75,\n    cacheReadPerMTok: 1.50,\n  },\n  // Aliases\n  'sonnet': {\n    inputPerMTok: 3.00,\n    outputPerMTok: 15.00,\n  },\n  'haiku': {\n    inputPerMTok: 1.00,\n    outputPerMTok: 5.00,\n  },\n  'opus': {\n    inputPerMTok: 15.00,\n    outputPerMTok: 75.00,\n  },\n};\n```\n\n## Cost Calculation Example\n\n```typescript\nfunction calculateCostUsd(\n  inputTokens: number,\n  outputTokens: number,\n  model: string = 'sonnet'\n): number {\n  const pricing = MODEL_PRICING[model];\n  if (!pricing) {\n    throw new Error(`Unknown model: ${model}`);\n  }\n\n  const inputCost = (inputTokens / 1_000_000) * pricing.inputPerMTok;\n  const outputCost = (outputTokens / 1_000_000) * pricing.outputPerMTok;\n\n  return inputCost + outputCost;\n}\n\n// Example usage\nconst cost = calculateCostUsd(50000, 2000, 'sonnet');\n// Input: 50k tokens × $3.00/MTok = $0.15\n// Output: 2k tokens × $15.00/MTok = $0.03\n// Total: $0.18\n```\n\n## Prompt Caching Impact\n\nPrompt caching can reduce costs by up to 90% for repeated prompts:\n\n```typescript\nfunction calculateCostWithCaching(\n  inputTokens: number,\n  outputTokens: number,\n  cacheReadTokens: number,\n  cacheWriteTokens: number,\n  model: string\n): { totalCost: number; savings: number } {\n  const pricing = MODEL_PRICING[model];\n\n  // Regular input (non-cached portion)\n  const regularInputCost = (inputTokens / 1_000_000) * pricing.inputPerMTok;\n\n  // Cache read (90% discount)\n  const cacheReadCost = (cacheReadTokens / 1_000_000) * (pricing.cacheReadPerMTok || pricing.inputPerMTok * 0.1);\n\n  // Cache write (25% premium)\n  const cacheWriteCost = (cacheWriteTokens / 1_000_000) * (pricing.cacheWritePerMTok || pricing.inputPerMTok * 1.25);\n\n  // Output\n  const outputCost = (outputTokens / 1_000_000) * pricing.outputPerMTok;\n\n  const totalCost = regularInputCost + cacheReadCost + cacheWriteCost + outputCost;\n\n  // Calculate savings vs. no caching\n  const noCacheCost = ((inputTokens + cacheReadTokens + cacheWriteTokens) / 1_000_000) * pricing.inputPerMTok + outputCost;\n  const savings = noCacheCost - totalCost;\n\n  return { totalCost, savings };\n}\n```\n\n## API Response Format\n\nThe Claude API returns token usage in the response:\n\n```json\n{\n  \"id\": \"msg_01XFDUDYJgAACzvnptvVoYEL\",\n  \"type\": \"message\",\n  \"role\": \"assistant\",\n  \"content\": [...],\n  \"model\": \"claude-3-5-sonnet-20241022\",\n  \"stop_reason\": \"end_turn\",\n  \"usage\": {\n    \"input_tokens\": 2095,\n    \"output_tokens\": 503,\n    \"cache_creation_input_tokens\": 0,\n    \"cache_read_input_tokens\": 1500\n  }\n}\n```\n\n## Batch API Pricing\n\nThe Batch API offers 50% discount on all models:\n\n| Model | Batch Input (per MTok) | Batch Output (per MTok) |\n|-------|------------------------|-------------------------|\n| Sonnet | $1.50 | $7.50 |\n| Haiku | $0.50 | $2.50 |\n| Opus | $7.50 | $37.50 |\n\nUse the Batch API for non-time-sensitive workloads to significantly reduce costs.\n\n## Rate Limits\n\n| Tier | Requests/min | Input tokens/min | Output tokens/min |\n|------|--------------|------------------|-------------------|\n| Free | 5 | 20,000 | 4,000 |\n| Tier 1 | 50 | 40,000 | 8,000 |\n| Tier 2 | 1,000 | 80,000 | 16,000 |\n| Tier 3 | 2,000 | 160,000 | 32,000 |\n| Tier 4 | 4,000 | 400,000 | 80,000 |\n\n## Notes\n\n- Prices are in USD\n- Minimum charge is 1 token\n- Token counts include special tokens added by the API\n- Check https://www.anthropic.com/pricing for the latest prices\n- This reference current as of January 2026\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "cost-accrual-tracker/SKILL.md",
      "size": 9493,
      "content": "---\nname: cost-accrual-tracker\ndescription: Track real-time API cost accrual during LLM execution. Activate on 'cost tracking', 'token usage', 'API costs', 'budget monitoring', 'usage metrics'. NOT for cost estimation, pricing tiers, or billing systems.\nallowed-tools: Read,Write,Edit\n---\n\n# Cost Accrual Tracker\n\nReal-time tracking of API costs during LLM execution with support for partial costs on abort.\n\n## When to Use\n\n✅ **Use for**:\n- Implementing real-time cost tracking during execution\n- Capturing partial costs when executions are aborted\n- Building cost display widgets for execution UIs\n- Integrating token counting into execution pipelines\n- Adding budget thresholds with auto-stop\n\n❌ **NOT for**:\n- Cost estimation before execution (use pricing calculators)\n- Billing system design (use billing-system skill)\n- Price tier management or discounts\n- Historical cost analytics dashboards\n\n## Core Patterns\n\n### 1. Token-Based Cost Calculation\n\n```typescript\ninterface TokenUsage {\n  inputTokens: number;\n  outputTokens: number;\n  cacheReadTokens?: number;   // Prompt caching hits\n  cacheWriteTokens?: number;  // Prompt caching misses\n}\n\ninterface CostCalculation {\n  inputCostUsd: number;\n  outputCostUsd: number;\n  cacheSavingsUsd?: number;\n  totalCostUsd: number;\n}\n\nfunction calculateCost(usage: TokenUsage, model: string): CostCalculation {\n  const pricing = MODEL_PRICING[model];\n\n  const inputCostUsd = (usage.inputTokens / 1_000_000) * pricing.inputPerMTok;\n  const outputCostUsd = (usage.outputTokens / 1_000_000) * pricing.outputPerMTok;\n\n  return {\n    inputCostUsd,\n    outputCostUsd,\n    totalCostUsd: inputCostUsd + outputCostUsd,\n  };\n}\n```\n\n### 2. Incremental Accrual Pattern\n\nTrack costs as they accrue, not just at completion:\n\n```typescript\nclass CostAccrualTracker {\n  private totalInputTokens = 0;\n  private totalOutputTokens = 0;\n  private accruedCostUsd = 0;\n  private readonly model: string;\n\n  constructor(model: string) {\n    this.model = model;\n  }\n\n  /**\n   * Called after each API response (streaming or complete)\n   */\n  recordUsage(usage: TokenUsage): void {\n    this.totalInputTokens += usage.inputTokens;\n    this.totalOutputTokens += usage.outputTokens;\n\n    const cost = calculateCost(usage, this.model);\n    this.accruedCostUsd += cost.totalCostUsd;\n  }\n\n  /**\n   * Get current accrued cost (for real-time display)\n   */\n  getCurrentCost(): number {\n    return this.accruedCostUsd;\n  }\n\n  /**\n   * Finalize on completion or abort\n   */\n  finalize(reason: 'completed' | 'aborted' | 'failed'): CostReport {\n    return {\n      totalInputTokens: this.totalInputTokens,\n      totalOutputTokens: this.totalOutputTokens,\n      totalCostUsd: this.accruedCostUsd,\n      completionReason: reason,\n      finalizedAt: Date.now(),\n    };\n  }\n}\n```\n\n### 3. Abort-Aware Cost Capture\n\n**Critical**: Always capture partial costs on abort:\n\n```typescript\n// In execution handler\nconst tracker = new CostAccrualTracker(model);\n\ntry {\n  for await (const chunk of executeStream(request)) {\n    if (abortSignal.aborted) {\n      // CRITICAL: Capture cost BEFORE throwing\n      const partialCost = tracker.finalize('aborted');\n      onCostUpdate(partialCost);\n      throw new AbortError('Execution aborted');\n    }\n\n    tracker.recordUsage(chunk.usage);\n    onCostUpdate(tracker.getCurrentCost());\n  }\n\n  return tracker.finalize('completed');\n} catch (error) {\n  if (error instanceof AbortError) {\n    throw error; // Already handled\n  }\n  return tracker.finalize('failed');\n}\n```\n\n### 4. Budget Threshold Pattern\n\nAuto-stop execution when budget is exceeded:\n\n```typescript\ninterface BudgetConfig {\n  maxCostUsd: number;\n  warnAtPercentage: number;  // e.g., 0.8 for 80%\n  onWarn?: (current: number, max: number) => void;\n  onExceed?: (current: number, max: number) => void;\n}\n\nfunction createBudgetGuard(config: BudgetConfig) {\n  return {\n    check(currentCostUsd: number): 'ok' | 'warn' | 'exceed' {\n      const percentage = currentCostUsd / config.maxCostUsd;\n\n      if (percentage >= 1.0) {\n        config.onExceed?.(currentCostUsd, config.maxCostUsd);\n        return 'exceed';\n      }\n\n      if (percentage >= config.warnAtPercentage) {\n        config.onWarn?.(currentCostUsd, config.maxCostUsd);\n        return 'warn';\n      }\n\n      return 'ok';\n    }\n  };\n}\n```\n\n## Anti-Patterns\n\n### Lost Costs on Abort\n\n**Novice thinking**: \"Just throw an error when aborted\"\n\n**Reality**: If you don't capture costs before aborting, you lose:\n- Token usage data for partial execution\n- Accurate cost reporting for billing\n- Audit trail for debugging\n\n**Timeline**: Always been an issue, but became critical with expensive models (GPT-4, Claude Opus)\n\n**Correct approach**: Always call `finalize()` with partial data BEFORE throwing abort errors.\n\n### Polling Without Debounce\n\n**Novice thinking**: \"Poll cost endpoint every 100ms for real-time updates\"\n\n**Reality**:\n- Wastes bandwidth and CPU\n- Cost updates only happen after API responses\n- Polling faster than response rate is pointless\n\n**Correct approach**: Poll at 1-2 second intervals, or use event-driven updates from the execution stream.\n\n### Ignoring Prompt Caching\n\n**Novice thinking**: \"Just multiply tokens by price per token\"\n\n**Reality**: Claude's prompt caching changes the cost model:\n- Cache reads are 90% cheaper\n- Cache writes cost extra on first use\n- Ignoring caching leads to inaccurate costs\n\n**Timeline**:\n- Pre-2024: No caching, simple calculation\n- 2024+: Claude prompt caching requires separate tracking\n\n**Correct approach**: Track `cache_read_input_tokens` and `cache_creation_input_tokens` separately.\n\n### Per-Request Cost Objects\n\n**Novice thinking**: \"Create new tracker for each request\"\n\n**Reality**: For DAG execution with multiple nodes:\n- Need aggregate cost across all nodes\n- Need to attribute costs to specific nodes\n- Need rollup for parent execution\n\n**Correct approach**: Hierarchical tracking - per-node trackers that roll up to execution-level.\n\n## State Flow\n\n```\n                    ┌─────────────────────────────────────────┐\n                    │           CostAccrualTracker            │\n                    └─────────────────────────────────────────┘\n                                        │\n              ┌─────────────────────────┼─────────────────────────┐\n              │                         │                         │\n              ▼                         ▼                         ▼\n    ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n    │  recordUsage()  │     │ getCurrentCost()│     │   finalize()    │\n    │                 │     │                 │     │                 │\n    │ After each API  │     │ For real-time   │     │ On completion,  │\n    │ response        │     │ display         │     │ abort, or fail  │\n    └─────────────────┘     └─────────────────┘     └─────────────────┘\n              │                         │                         │\n              │                         │                         │\n              ▼                         ▼                         ▼\n    ┌─────────────────────────────────────────────────────────────────┐\n    │                        CostReport                               │\n    │  { inputTokens, outputTokens, totalCostUsd, completionReason }  │\n    └─────────────────────────────────────────────────────────────────┘\n```\n\n## UI Display Pattern\n\nFor real-time cost display in execution UIs:\n\n```typescript\n// Poll every 2 seconds while executing\nuseEffect(() => {\n  if (status !== 'running') return;\n\n  const interval = setInterval(async () => {\n    const response = await fetch(`/api/execute/${executionId}`);\n    const data = await response.json();\n    setAccruedCost(data.cost.accruedUsd);\n    setTokens({\n      input: data.cost.inputTokens,\n      output: data.cost.outputTokens,\n    });\n  }, 2000);\n\n  return () => clearInterval(interval);\n}, [executionId, status]);\n\n// Display format\n<div className=\"cost-display\">\n  <span className=\"cost-amount\">${accruedCost.toFixed(4)}</span>\n  <span className=\"token-count\">\n    {tokens.input.toLocaleString()} in / {tokens.output.toLocaleString()} out\n  </span>\n</div>\n```\n\n## Integration Points\n\n| Component | Responsibility |\n|-----------|----------------|\n| `CostAccrualTracker` | Per-execution token counting and cost calculation |\n| `ExecutionManager` | Aggregates costs across DAG executions |\n| `BudgetGuard` | Threshold monitoring and auto-stop |\n| `/api/execute/:id` | Exposes current cost via polling |\n| Cost Display Widget | Real-time UI rendering |\n\n## References\n\nSee `/references/claude-api-pricing.md` for current Claude API pricing.\n"
    }
  ]
}