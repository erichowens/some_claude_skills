{
  "name": "real-time-collaboration-engine",
  "type": "folder",
  "path": "real-time-collaboration-engine",
  "children": [
    {
      "name": "assets",
      "type": "folder",
      "path": "real-time-collaboration-engine/assets",
      "children": []
    },
    {
      "name": "references",
      "type": "folder",
      "path": "real-time-collaboration-engine/references",
      "children": [
        {
          "name": "ot-vs-crdt.md",
          "type": "file",
          "path": "real-time-collaboration-engine/references/ot-vs-crdt.md",
          "size": 11264,
          "content": "# Operational Transform vs CRDTs\n\nDeep comparison of the two main conflict resolution strategies for real-time collaboration.\n\n## Executive Summary\n\n| Factor | Operational Transform (OT) | CRDTs |\n|--------|---------------------------|-------|\n| **Best for** | Text editing, sequential data | JSON objects, sets, maps |\n| **Complexity** | High | Medium |\n| **Offline support** | Limited | Excellent |\n| **Latency tolerance** | Low (requires frequent sync) | High (can sync infrequently) |\n| **Memory overhead** | Low | Higher (stores metadata) |\n| **Network topology** | Requires central server | Peer-to-peer or server |\n| **Convergence** | Guaranteed with proper transforms | Mathematically proven |\n\n**Rule of thumb**:\n- Google Docs-style text editing ‚Üí OT\n- Figma-style object editing ‚Üí CRDTs\n\n---\n\n## Operational Transform (OT)\n\n### How It Works\n\nOT transforms concurrent operations so they can be applied in any order and produce the same result.\n\n**Example**:\n\n```\nInitial: \"Hello\"\n\nUser A: Insert \"!\" at position 5 ‚Üí \"Hello!\"\nUser B: Insert \"World\" at position 5 ‚Üí \"HelloWorld\"\n```\n\nWithout OT:\n```\nA applies locally: \"Hello!\"\nB applies locally: \"HelloWorld\"\nA receives B's op: Insert \"World\" at 5 ‚Üí \"HelloWorld!\" ‚ùå Wrong!\n```\n\nWith OT:\n```\nA applies locally: \"Hello!\"\nB applies locally: \"HelloWorld\"\nA receives B's op, transforms it:\n  - Original: Insert \"World\" at 5\n  - Transformed: Insert \"World\" at 5 (before \"!\")\n  - Result: \"HelloWorld!\" ‚úÖ Correct!\n```\n\n### Transformation Rules\n\nFor text operations:\n\n```typescript\nfunction transform(op1: Operation, op2: Operation): [Operation, Operation] {\n  if (op1.type === 'insert' && op2.type === 'insert') {\n    if (op1.position < op2.position) {\n      // op2 position shifts right\n      return [op1, { ...op2, position: op2.position + op1.length }];\n    } else if (op1.position > op2.position) {\n      // op1 position shifts right\n      return [{ ...op1, position: op1.position + op2.length }, op2];\n    } else {\n      // Same position - use tie-breaker (user ID)\n      if (op1.userId < op2.userId) {\n        return [op1, { ...op2, position: op2.position + op1.length }];\n      } else {\n        return [{ ...op1, position: op1.position + op2.length }, op2];\n      }\n    }\n  }\n\n  if (op1.type === 'delete' && op2.type === 'insert') {\n    // ... more rules\n  }\n\n  // ... handle all operation type combinations\n}\n```\n\n### Challenges\n\n**Challenge 1: All operation pairs must be defined**\n\nFor `n` operation types, you need `n¬≤` transformation functions. Text has 3 types (insert, delete, replace) = 9 combinations.\n\n**Challenge 2: Transformation must be commutative**\n\n```\ntransform(transform(op1, op2), op3) === transform(op1, transform(op2, op3))\n```\n\n**Challenge 3: Undo/redo is complex**\n\nUndoing an operation requires transforming it against all subsequent operations.\n\n### When OT Shines\n\n‚úÖ Text editing (Google Docs, Etherpad)\n‚úÖ Code editors (Codeshare, CodeSandbox)\n‚úÖ Low latency environments\n‚úÖ Central server architecture\n\n### When OT Struggles\n\n‚ùå High latency (satellite, mobile)\n‚ùå Offline editing (can't transform without server)\n‚ùå Complex data structures (requires more transformation rules)\n\n---\n\n## CRDTs (Conflict-free Replicated Data Types)\n\n### How They Work\n\nCRDTs use unique identifiers for each element, making order-independent merges possible.\n\n**Example**: Yjs (a CRDT library)\n\n```\nInitial: \"Hello\"\n\nUser A: Insert \"!\" ‚Üí \"Hello!\"\nUser B: Insert \"World\" ‚Üí \"HelloWorld\"\n```\n\nUnder the hood:\n```\n\"Hello\" = [\n  { id: \"1.0\", char: \"H\" },\n  { id: \"1.1\", char: \"e\" },\n  { id: \"1.2\", char: \"l\" },\n  { id: \"1.3\", char: \"l\" },\n  { id: \"1.4\", char: \"o\" }\n]\n\nUser A inserts \"!\":\n  { id: \"1.4.A1\", char: \"!\" }\n\nUser B inserts \"World\":\n  { id: \"1.4.B1\", char: \"W\" },\n  { id: \"1.4.B2\", char: \"o\" },\n  { id: \"1.4.B3\", char: \"r\" },\n  { id: \"1.4.B4\", char: \"l\" },\n  { id: \"1.4.B5\", char: \"d\" }\n\nMerge (sort by ID):\n  \"Hello\" + \"World\" + \"!\" = \"HelloWorld!\"\n```\n\n### CRDT Types\n\n**1. G-Counter (Grow-only Counter)**\n\n```typescript\nclass GCounter {\n  private counters: Map<string, number> = new Map();\n\n  increment(userId: string, amount: number = 1): void {\n    const current = this.counters.get(userId) || 0;\n    this.counters.set(userId, current + amount);\n  }\n\n  get value(): number {\n    return Array.from(this.counters.values()).reduce((sum, v) => sum + v, 0);\n  }\n\n  merge(other: GCounter): void {\n    other.counters.forEach((value, userId) => {\n      const current = this.counters.get(userId) || 0;\n      this.counters.set(userId, Math.max(current, value));\n    });\n  }\n}\n```\n\n**2. LWW-Element-Set (Last-Write-Wins Set)**\n\n```typescript\nclass LWWSet<T> {\n  private addSet: Map<T, number> = new Map();\n  private removeSet: Map<T, number> = new Map();\n\n  add(element: T, timestamp: number = Date.now()): void {\n    this.addSet.set(element, timestamp);\n  }\n\n  remove(element: T, timestamp: number = Date.now()): void {\n    this.removeSet.set(element, timestamp);\n  }\n\n  has(element: T): boolean {\n    const addTime = this.addSet.get(element) || 0;\n    const removeTime = this.removeSet.get(element) || 0;\n    return addTime > removeTime;\n  }\n\n  merge(other: LWWSet<T>): void {\n    other.addSet.forEach((timestamp, element) => {\n      const current = this.addSet.get(element) || 0;\n      this.addSet.set(element, Math.max(current, timestamp));\n    });\n\n    other.removeSet.forEach((timestamp, element) => {\n      const current = this.removeSet.get(element) || 0;\n      this.removeSet.set(element, Math.max(current, timestamp));\n    });\n  }\n}\n```\n\n**3. Y.Text (Yjs Text CRDT)**\n\n```typescript\nimport * as Y from 'yjs';\n\nconst ydoc = new Y.Doc();\nconst ytext = ydoc.getText('document');\n\n// Insert\nytext.insert(0, 'Hello');\nytext.insert(5, ' World');\n\n// Delete\nytext.delete(5, 6);  // Remove \" World\"\n\n// Automatic conflict resolution\n// No transformation needed!\n```\n\n### When CRDTs Shine\n\n‚úÖ Offline-first apps (sync when reconnected)\n‚úÖ Peer-to-peer collaboration (no central server)\n‚úÖ High latency environments\n‚úÖ Complex data structures (JSON, maps, sets)\n\n### When CRDTs Struggle\n\n‚ùå Memory overhead (stores tombstones for deletes)\n‚ùå Garbage collection complexity\n‚ùå Learning curve (new mental model)\n\n---\n\n## Performance Comparison\n\n### Memory Usage\n\n**Text: \"Hello World\"** (11 characters)\n\nOT:\n```\nString: 11 bytes\nOperations buffer: ~100 bytes\nTotal: ~111 bytes\n```\n\nCRDT (Yjs):\n```\nString: 11 bytes\nIDs per char: 11 √ó 16 bytes = 176 bytes\nMetadata: ~50 bytes\nTotal: ~237 bytes (2√ó overhead)\n```\n\n**Verdict**: OT uses 50% less memory for text.\n\n---\n\n### Network Traffic\n\n**Scenario**: User types \"Hello\" (5 keystrokes)\n\nOT with batching (200ms):\n```\nBatch 1: [\"H\", \"e\"]\nBatch 2: [\"l\", \"l\"]\nBatch 3: [\"o\"]\nTotal: 3 messages\n```\n\nCRDT:\n```\nMessage 1: \"H\" with ID\nMessage 2: \"e\" with ID\n... (can batch too)\nTotal: Similar with batching\n```\n\n**Verdict**: Comparable with batching.\n\n---\n\n### Convergence Time\n\n**Scenario**: 100 concurrent edits, 200ms latency\n\nOT:\n```\nServer receives ops sequentially\nTransforms each against prior ops\nTotal time: ~20 seconds\n```\n\nCRDT:\n```\nPeers can merge independently\nParallel processing\nTotal time: ~5 seconds\n```\n\n**Verdict**: CRDTs converge 4√ó faster in high-concurrency scenarios.\n\n---\n\n## Real-World Examples\n\n### Google Docs (OT)\n\n**Why OT**:\n- Text-focused\n- Central server (Google's infrastructure)\n- Low latency (Google's network)\n- Complex transformation logic is worth it for text quality\n\n**Implementation**:\n- Custom OT algorithm\n- Operational transforms for rich text\n- Server authority for conflict resolution\n\n---\n\n### Figma (CRDT)\n\n**Why CRDT**:\n- JSON-based (layers, properties, styles)\n- Needs offline support\n- Complex nested structures\n- Peer-to-peer multiplayer\n\n**Implementation**:\n- Custom CRDT for design objects\n- Yjs for some text fields\n- Operational transforms for specific operations\n\n---\n\n### Linear (Hybrid)\n\n**Why Hybrid**:\n- Issue descriptions use CRDTs (offline editing)\n- Comments use simpler append-only (no conflicts)\n- Timestamps use Last-Write-Wins\n\n**Implementation**:\n- Multiple strategies for different data types\n- CRDTs where needed, simpler approaches elsewhere\n\n---\n\n## Choosing a Strategy\n\n### Decision Tree\n\n```\nDoes your data need offline editing?\n‚îú‚îÄ‚îÄ Yes ‚Üí CRDT\n‚îî‚îÄ‚îÄ No ‚Üí Continue\n\nIs your primary data type text?\n‚îú‚îÄ‚îÄ Yes ‚Üí OT (Google Docs-style)\n‚îî‚îÄ‚îÄ No ‚Üí Continue\n\nDo you have a central server?\n‚îú‚îÄ‚îÄ Yes ‚Üí OT is viable\n‚îî‚îÄ‚îÄ No ‚Üí CRDT (peer-to-peer)\n\nIs latency low (&lt;50ms)?\n‚îú‚îÄ‚îÄ Yes ‚Üí OT works well\n‚îî‚îÄ‚îÄ No ‚Üí CRDT handles better\n\nAre you editing JSON objects?\n‚îú‚îÄ‚îÄ Yes ‚Üí CRDT (easier for objects)\n‚îî‚îÄ‚îÄ No ‚Üí Either works\n```\n\n### Hybrid Approach\n\nMany apps use both:\n\n```typescript\n// Text fields: OT\nconst textEditor = new OTEditor();\n\n// Object properties: CRDT\nconst properties = new Y.Map();\n\n// Simple fields: Last-Write-Wins\nconst title = new LWWRegister();\n```\n\n---\n\n## Libraries\n\n### OT Libraries\n\n| Library | Language | Maturity | Use Case |\n|---------|----------|----------|----------|\n| [ot.js](https://github.com/Operational-Transformation/ot.js) | JavaScript | Stable | Text editing |\n| [ShareDB](https://github.com/share/sharedb) | JavaScript | Mature | Real-time database with OT |\n| [CodeMirror](https://codemirror.net/) | JavaScript | Mature | Code editor with OT support |\n\n### CRDT Libraries\n\n| Library | Language | Maturity | Use Case |\n|---------|----------|----------|----------|\n| [Yjs](https://github.com/yjs/yjs) | JavaScript | Mature | Text, maps, arrays |\n| [Automerge](https://github.com/automerge/automerge) | JavaScript | Mature | JSON documents |\n| [Diamond Types](https://github.com/josephg/diamond-types) | Rust/JS | Experimental | Fast text CRDTs |\n| [LORO](https://github.com/loro-dev/loro) | Rust/JS | New (2023) | Rich text + objects |\n\n---\n\n## Performance Tips\n\n### OT Optimization\n\n```typescript\n// Batch operations\nconst batchedOps: Operation[] = [];\nconst flushInterval = 200; // ms\n\nfunction queueOperation(op: Operation): void {\n  batchedOps.push(op);\n}\n\nsetInterval(() => {\n  if (batchedOps.length > 0) {\n    socket.emit('operations', batchedOps);\n    batchedOps.length = 0;\n  }\n}, flushInterval);\n```\n\n### CRDT Optimization\n\n```typescript\n// Garbage collection (remove tombstones)\nimport * as Y from 'yjs';\n\nconst ydoc = new Y.Doc({ gc: true });\n\n// Compact document periodically\nsetInterval(() => {\n  // Remove deleted content older than 30 days\n  ydoc.gc = true;\n}, 86400000);  // Daily\n```\n\n---\n\n## Conclusion\n\n**Choose OT if**:\n- Primary data is text\n- You have central server infrastructure\n- Latency is low\n- You can invest in proper transformation logic\n\n**Choose CRDT if**:\n- You need offline support\n- Data is JSON/objects/sets\n- Peer-to-peer architecture\n- High latency or unreliable network\n\n**Choose Hybrid if**:\n- Different data types have different needs\n- You want best of both worlds\n- You can manage complexity\n\n---\n\n## Resources\n\n- [OT Visualization](https://operational-transformation.github.io/)\n- [Yjs Demos](https://demos.yjs.dev/)\n- [Automerge Docs](https://automerge.org/docs/)\n- [Figma's Multiplayer Tech](https://www.figma.com/blog/how-figmas-multiplayer-technology-works/)\n- [CRDT Research Papers](https://crdt.tech/)\n"
        },
        {
          "name": "presence-patterns.md",
          "type": "file",
          "path": "real-time-collaboration-engine/references/presence-patterns.md",
          "size": 14542,
          "content": "# Presence Awareness Patterns\n\nComplete guide to implementing cursors, user awareness, and activity indicators in collaborative apps.\n\n## Why Presence Matters\n\n**Without presence**:\n- Users edit same section ‚Üí conflicts\n- No awareness of team activity\n- Feels like working alone\n\n**With presence**:\n- See who's editing what ‚Üí avoid conflicts\n- Feel connected to team\n- Trust the system is working\n\n**Impact**: 40% fewer edit conflicts (Google Docs study)\n\n---\n\n## Pattern 1: User List (Who's Here)\n\n### Basic Implementation\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  avatar: string;\n  color: string;\n  joinedAt: number;\n}\n\n// Server\nconst activeUsers = new Map<string, User>();\n\nio.on('connection', (socket) => {\n  socket.on('join', (user: User) => {\n    activeUsers.set(socket.id, user);\n\n    // Broadcast to others\n    socket.broadcast.emit('user-joined', user);\n\n    // Send current users to new joiner\n    socket.emit('users-list', Array.from(activeUsers.values()));\n  });\n\n  socket.on('disconnect', () => {\n    const user = activeUsers.get(socket.id);\n    activeUsers.delete(socket.id);\n\n    if (user) {\n      io.emit('user-left', { userId: user.id });\n    }\n  });\n});\n```\n\n### React Component\n\n```typescript\nimport { useEffect, useState } from 'react';\n\nfunction UserList() {\n  const [users, setUsers] = useState<User[]>([]);\n\n  useEffect(() => {\n    socket.on('users-list', (userList) => {\n      setUsers(userList);\n    });\n\n    socket.on('user-joined', (user) => {\n      setUsers(prev => [...prev, user]);\n    });\n\n    socket.on('user-left', ({ userId }) => {\n      setUsers(prev => prev.filter(u => u.id !== userId));\n    });\n\n    return () => {\n      socket.off('users-list');\n      socket.off('user-joined');\n      socket.off('user-left');\n    };\n  }, []);\n\n  return (\n    <div className=\"user-list\">\n      <h3>{users.length} online</h3>\n      {users.map(user => (\n        <div key={user.id} className=\"user-avatar\">\n          <img src={user.avatar} alt={user.name} />\n          <span style={{ color: user.color }}>{user.name}</span>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 2: Cursor Tracking\n\n### Server-Side Throttling\n\n```typescript\nconst CURSOR_UPDATE_INTERVAL = 50; // ms\nconst userCursors = new Map<string, { position: Position; timestamp: number }>();\n\nio.on('connection', (socket) => {\n  let lastCursorUpdate = 0;\n\n  socket.on('cursor-move', (position: Position) => {\n    const now = Date.now();\n\n    // Throttle updates\n    if (now - lastCursorUpdate < CURSOR_UPDATE_INTERVAL) {\n      return;\n    }\n\n    lastCursorUpdate = now;\n    userCursors.set(socket.id, { position, timestamp: now });\n\n    // Broadcast to room (excluding sender)\n    socket.to(socket.roomId).emit('cursor-update', {\n      userId: socket.userId,\n      position,\n      user: socket.user\n    });\n  });\n\n  socket.on('disconnect', () => {\n    userCursors.delete(socket.id);\n    socket.to(socket.roomId).emit('cursor-remove', { userId: socket.userId });\n  });\n});\n```\n\n### Client-Side Rendering\n\n```typescript\ninterface Cursor {\n  userId: string;\n  position: { x: number; y: number };\n  user: User;\n}\n\nfunction CursorOverlay() {\n  const [cursors, setCursors] = useState<Map<string, Cursor>>(new Map());\n\n  useEffect(() => {\n    socket.on('cursor-update', ({ userId, position, user }) => {\n      setCursors(prev => new Map(prev).set(userId, { userId, position, user }));\n    });\n\n    socket.on('cursor-remove', ({ userId }) => {\n      setCursors(prev => {\n        const next = new Map(prev);\n        next.delete(userId);\n        return next;\n      });\n    });\n\n    // Fade out stale cursors\n    const interval = setInterval(() => {\n      const now = Date.now();\n      setCursors(prev => {\n        const next = new Map(prev);\n        for (const [userId, cursor] of next) {\n          if (now - cursor.timestamp > 3000) {\n            next.delete(userId);\n          }\n        }\n        return next;\n      });\n    }, 1000);\n\n    return () => {\n      clearInterval(interval);\n      socket.off('cursor-update');\n      socket.off('cursor-remove');\n    };\n  }, []);\n\n  return (\n    <>\n      {Array.from(cursors.values()).map(cursor => (\n        <RemoteCursor\n          key={cursor.userId}\n          position={cursor.position}\n          color={cursor.user.color}\n          name={cursor.user.name}\n        />\n      ))}\n    </>\n  );\n}\n\nfunction RemoteCursor({ position, color, name }: {\n  position: { x: number; y: number };\n  color: string;\n  name: string;\n}) {\n  return (\n    <div\n      className=\"remote-cursor\"\n      style={{\n        position: 'absolute',\n        left: position.x,\n        top: position.y,\n        pointerEvents: 'none',\n        transition: 'all 50ms linear'\n      }}\n    >\n      {/* Cursor SVG */}\n      <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <path\n          d=\"M5 3l14 9-6 1-3 6-5-16z\"\n          fill={color}\n          stroke=\"white\"\n          strokeWidth=\"1\"\n        />\n      </svg>\n\n      {/* Name label */}\n      <div\n        className=\"cursor-label\"\n        style={{\n          backgroundColor: color,\n          color: 'white',\n          padding: '2px 6px',\n          borderRadius: '4px',\n          fontSize: '12px',\n          marginLeft: '24px',\n          whiteSpace: 'nowrap'\n        }}\n      >\n        {name}\n      </div>\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 3: Text Selection Highlighting\n\n### Track Selection Ranges\n\n```typescript\ninterface Selection {\n  start: number;\n  end: number;\n}\n\ninterface UserSelection {\n  userId: string;\n  selection: Selection;\n  user: User;\n}\n\nfunction EditorWithSelections() {\n  const [selections, setSelections] = useState<Map<string, UserSelection>>(new Map());\n  const editorRef = useRef<HTMLTextAreaElement>(null);\n\n  const handleSelectionChange = () => {\n    const editor = editorRef.current;\n    if (!editor) return;\n\n    const selection = {\n      start: editor.selectionStart,\n      end: editor.selectionEnd\n    };\n\n    // Only send if actually selecting (not just cursor)\n    if (selection.start !== selection.end) {\n      socket.emit('selection-change', selection);\n    }\n  };\n\n  useEffect(() => {\n    socket.on('user-selection', ({ userId, selection, user }) => {\n      setSelections(prev => new Map(prev).set(userId, { userId, selection, user }));\n    });\n\n    return () => socket.off('user-selection');\n  }, []);\n\n  return (\n    <div style={{ position: 'relative' }}>\n      {/* Highlight layers (behind text) */}\n      {Array.from(selections.values()).map(({ userId, selection, user }) => (\n        <SelectionHighlight\n          key={userId}\n          start={selection.start}\n          end={selection.end}\n          color={user.color}\n        />\n      ))}\n\n      {/* Actual editor */}\n      <textarea\n        ref={editorRef}\n        onSelect={handleSelectionChange}\n        onBlur={() => socket.emit('selection-clear')}\n      />\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 4: \"User is Typing...\" Indicator\n\n### Debounced Typing Status\n\n```typescript\nfunction TypingIndicator() {\n  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());\n  const typingTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const handleTyping = () => {\n    socket.emit('typing-start');\n\n    // Clear previous timeout\n    if (typingTimeoutRef.current) {\n      clearTimeout(typingTimeoutRef.current);\n    }\n\n    // Stop typing after 2 seconds of inactivity\n    typingTimeoutRef.current = setTimeout(() => {\n      socket.emit('typing-stop');\n    }, 2000);\n  };\n\n  useEffect(() => {\n    socket.on('user-typing-start', ({ userId }) => {\n      setTypingUsers(prev => new Set(prev).add(userId));\n    });\n\n    socket.on('user-typing-stop', ({ userId }) => {\n      setTypingUsers(prev => {\n        const next = new Set(prev);\n        next.delete(userId);\n        return next;\n      });\n    });\n\n    return () => {\n      socket.off('user-typing-start');\n      socket.off('user-typing-stop');\n    };\n  }, []);\n\n  if (typingUsers.size === 0) return null;\n\n  const names = Array.from(typingUsers).map(id => getUserName(id));\n\n  return (\n    <div className=\"typing-indicator\">\n      {names.join(', ')} {names.length === 1 ? 'is' : 'are'} typing...\n      <span className=\"typing-dots\">\n        <span>.</span><span>.</span><span>.</span>\n      </span>\n    </div>\n  );\n}\n```\n\n**CSS Animation**:\n\n```css\n.typing-dots span {\n  animation: blink 1.4s infinite;\n}\n\n.typing-dots span:nth-child(2) {\n  animation-delay: 0.2s;\n}\n\n.typing-dots span:nth-child(3) {\n  animation-delay: 0.4s;\n}\n\n@keyframes blink {\n  0%, 60%, 100% {\n    opacity: 0;\n  }\n  30% {\n    opacity: 1;\n  }\n}\n```\n\n---\n\n## Pattern 5: Focus/Blur (Tab Active)\n\n### Track User Activity\n\n```typescript\n// Server\nconst userActivity = new Map<string, {\n  isActive: boolean;\n  lastSeen: number;\n}>();\n\nio.on('connection', (socket) => {\n  socket.on('user-active', () => {\n    userActivity.set(socket.id, {\n      isActive: true,\n      lastSeen: Date.now()\n    });\n\n    socket.broadcast.emit('user-status-change', {\n      userId: socket.userId,\n      isActive: true\n    });\n  });\n\n  socket.on('user-idle', () => {\n    userActivity.set(socket.id, {\n      isActive: false,\n      lastSeen: Date.now()\n    });\n\n    socket.broadcast.emit('user-status-change', {\n      userId: socket.userId,\n      isActive: false\n    });\n  });\n});\n\n// Client\nuseEffect(() => {\n  const handleVisibilityChange = () => {\n    if (document.hidden) {\n      socket.emit('user-idle');\n    } else {\n      socket.emit('user-active');\n    }\n  };\n\n  document.addEventListener('visibilitychange', handleVisibilityChange);\n\n  return () => {\n    document.removeEventListener('visibilitychange', handleVisibilityChange);\n  };\n}, []);\n```\n\n### Visual Indicator\n\n```typescript\nfunction UserAvatar({ user, isActive }: { user: User; isActive: boolean }) {\n  return (\n    <div className=\"user-avatar\" data-active={isActive}>\n      <img src={user.avatar} alt={user.name} />\n\n      {/* Active indicator (green dot) */}\n      <span\n        className=\"active-indicator\"\n        style={{\n          backgroundColor: isActive ? '#00ff00' : '#999',\n          width: '8px',\n          height: '8px',\n          borderRadius: '50%',\n          position: 'absolute',\n          bottom: 0,\n          right: 0,\n          border: '2px solid white'\n        }}\n      />\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 6: Viewport Tracking\n\n**Problem**: Know what part of document others are viewing\n\n```typescript\ninterface Viewport {\n  top: number;\n  bottom: number;\n}\n\nfunction ViewportTracker() {\n  const throttledUpdateRef = useRef<NodeJS.Timeout>();\n\n  const updateViewport = () => {\n    const viewport = {\n      top: window.scrollY,\n      bottom: window.scrollY + window.innerHeight\n    };\n\n    socket.emit('viewport-change', viewport);\n  };\n\n  const handleScroll = () => {\n    // Throttle to max 2 updates per second\n    if (throttledUpdateRef.current) {\n      clearTimeout(throttledUpdateRef.current);\n    }\n\n    throttledUpdateRef.current = setTimeout(updateViewport, 500);\n  };\n\n  useEffect(() => {\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  return null;\n}\n\n// Visualize where others are\nfunction ViewportIndicators({ users }: { users: UserViewport[] }) {\n  return (\n    <div className=\"viewport-indicators\">\n      {users.map(user => (\n        <div\n          key={user.id}\n          className=\"viewport-bar\"\n          style={{\n            position: 'fixed',\n            right: 0,\n            top: `${(user.viewport.top / documentHeight) * 100}%`,\n            height: `${((user.viewport.bottom - user.viewport.top) / documentHeight) * 100}%`,\n            width: '4px',\n            backgroundColor: user.color,\n            opacity: 0.5\n          }}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n---\n\n## Pattern 7: Awareness State (Yjs)\n\n**Best Practice**: Use Yjs awareness for automatic cleanup\n\n```typescript\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\n\nconst ydoc = new Y.Doc();\nconst provider = new WebsocketProvider('ws://localhost:1234', 'room', ydoc);\nconst awareness = provider.awareness;\n\n// Set local user state\nawareness.setLocalState({\n  user: {\n    name: 'Alice',\n    color: '#ff0000',\n    avatar: '/avatars/alice.jpg'\n  },\n  cursor: null,\n  selection: null\n});\n\n// Update cursor\nconst updateCursor = (position: Position) => {\n  awareness.setLocalStateField('cursor', position);\n};\n\n// Listen to others\nawareness.on('change', ({ added, updated, removed }) => {\n  const states = awareness.getStates();\n\n  states.forEach((state, clientId) => {\n    if (clientId !== awareness.clientID) {\n      // Render remote cursor\n      renderCursor(state.user, state.cursor);\n    }\n  });\n\n  // Clean up removed users\n  removed.forEach(clientId => {\n    removeCursor(clientId);\n  });\n});\n```\n\n**Benefits**:\n- Automatic cleanup on disconnect\n- Built-in timeout mechanism\n- No manual event management\n\n---\n\n## Performance Optimization\n\n### Throttling Cursor Updates\n\n```typescript\nimport { throttle } from 'lodash-es';\n\nconst emitCursor = throttle((position: Position) => {\n  socket.emit('cursor-move', position);\n}, 50);  // Max 20 updates/second\n\ndocument.addEventListener('mousemove', (e) => {\n  emitCursor({ x: e.clientX, y: e.clientY });\n});\n```\n\n### Spatial Partitioning (Only Send to Nearby Users)\n\n```typescript\n// Server-side: Only broadcast to users in same viewport region\nfunction getRegion(position: Position): string {\n  const regionX = Math.floor(position.x / 1000);\n  const regionY = Math.floor(position.y / 1000);\n  return `${regionX},${regionY}`;\n}\n\nsocket.on('cursor-move', (position) => {\n  const region = getRegion(position);\n\n  // Only emit to users in same region\n  socket.to(`region-${region}`).emit('cursor-update', {\n    userId: socket.userId,\n    position\n  });\n});\n```\n\n---\n\n## Production Checklist\n\n```\n‚ñ° User list with join/leave notifications\n‚ñ° Cursor tracking (throttled to 50ms)\n‚ñ° Selection highlighting (for text editors)\n‚ñ° \"User is typing...\" indicator (debounced)\n‚ñ° Focus/blur activity status\n‚ñ° Viewport tracking (for long documents)\n‚ñ° Automatic cleanup on disconnect\n‚ñ° Stale state timeout (fade after 3 seconds)\n‚ñ° Throttling (max 20 updates/second)\n‚ñ° Privacy controls (hide cursor option)\n```\n\n---\n\n## Resources\n\n- [Yjs Awareness Protocol](https://docs.yjs.dev/getting-started/working-with-the-awareness-protocol)\n- [Figma Multiplayer Cursors](https://www.figma.com/blog/how-figmas-multiplayer-technology-works/)\n- [Linear's Real-Time Collaboration](https://linear.app/blog/how-we-built-it-real-time-sync)\n"
        },
        {
          "name": "websocket-scaling.md",
          "type": "file",
          "path": "real-time-collaboration-engine/references/websocket-scaling.md",
          "size": 14584,
          "content": "# WebSocket Scaling Strategies\n\nProduction patterns for scaling WebSocket connections to millions of concurrent users.\n\n## The Challenge\n\n**Single server limits**:\n- Node.js: ~10,000 concurrent WebSocket connections\n- Memory: 1MB per connection\n- CPU: Context switching overhead\n\n**1 million users**:\n- Requires: 100 servers (10k connections each)\n- Memory: 1TB total\n- Challenge: Cross-server communication\n\n---\n\n## Architecture Patterns\n\n### Pattern 1: Horizontal Scaling with Redis Pub/Sub\n\n**Problem**: Users on different servers can't communicate\n\n**Solution**: Redis as message bus\n\n```\nUser A (Server 1) ‚Üí Redis ‚Üí User B (Server 2)\n```\n\n**Implementation**:\n\n```typescript\n// Server setup\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport { createAdapter } from '@socket.io/redis-adapter';\nimport { createClient } from 'redis';\n\nconst httpServer = createServer();\nconst io = new Server(httpServer);\n\n// Redis clients\nconst pubClient = createClient({ url: 'redis://localhost:6379' });\nconst subClient = pubClient.duplicate();\n\nPromise.all([pubClient.connect(), subClient.connect()]).then(() => {\n  // Use Redis adapter\n  io.adapter(createAdapter(pubClient, subClient));\n});\n\n// Now rooms work across servers!\nio.to('room-123').emit('message', { text: 'Hello' });\n```\n\n**Performance**:\n- Redis throughput: ~100k messages/second\n- Latency: &lt;5ms additional overhead\n- Can scale to millions of connections\n\n---\n\n### Pattern 2: Sticky Sessions with Load Balancer\n\n**Problem**: HTTP polling falls back requires same server\n\n**Solution**: Route user to same server\n\n**nginx config**:\n```nginx\nupstream websocket_servers {\n  # Sticky sessions based on IP\n  ip_hash;\n\n  server ws1.example.com:3000;\n  server ws2.example.com:3000;\n  server ws3.example.com:3000;\n}\n\nserver {\n  listen 80;\n\n  location /socket.io/ {\n    proxy_pass http://websocket_servers;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header Host $host;\n\n    # Sticky sessions\n    proxy_set_header X-Real-IP $remote_addr;\n  }\n}\n```\n\n**Alternatives to ip_hash**:\n- Cookie-based (`sticky` module)\n- Session ID-based\n- Consistent hashing\n\n---\n\n### Pattern 3: Namespace/Room-Based Sharding\n\n**Problem**: Not all users need to be connected\n\n**Solution**: Shard by room/namespace\n\n```typescript\n// Shard by document ID\nconst documentId = 'doc-123';\nconst shard = Math.abs(hashCode(documentId)) % serverCount;\n\n// Route to specific server\nconst serverUrl = `ws://shard-${shard}.example.com`;\nconst socket = io(serverUrl);\n```\n\n**Benefits**:\n- Users only connect to servers with their documents\n- Natural load distribution\n- Can scale specific shards\n\n**Implementation**:\n\n```typescript\n// Consistent hashing\nimport crypto from 'crypto';\n\nfunction getShardForDocument(documentId: string, totalShards: number): number {\n  const hash = crypto.createHash('md5').update(documentId).digest('hex');\n  const hashInt = parseInt(hash.substring(0, 8), 16);\n  return hashInt % totalShards;\n}\n\n// Client connects to correct shard\nconst shard = getShardForDocument('doc-123', 10);\nconst socket = io(`wss://shard-${shard}.example.com`);\n```\n\n---\n\n### Pattern 4: Microservice-Based Architecture\n\n**Problem**: Monolithic WebSocket server doing too much\n\n**Solution**: Separate concerns\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Gateway    ‚îÇ  (WebSocket connections)\n‚îÇ   Servers    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n       ‚îÇ\n       ‚îú‚îÄ‚Üí Document Service (CRDT sync)\n       ‚îú‚îÄ‚Üí Presence Service (cursors, users)\n       ‚îú‚îÄ‚Üí Auth Service (authentication)\n       ‚îî‚îÄ‚Üí Notification Service (toasts, alerts)\n```\n\n**Benefits**:\n- Scale services independently\n- Easier to maintain\n- Can use different languages per service\n\n**Example**:\n\n```typescript\n// Gateway server (handles connections)\nio.on('connection', (socket) => {\n  // Forward to appropriate service\n  socket.on('document-change', async (data) => {\n    const result = await documentService.applyChange(data);\n    io.to(data.documentId).emit('document-updated', result);\n  });\n\n  socket.on('cursor-move', async (data) => {\n    await presenceService.updateCursor(socket.id, data);\n  });\n});\n```\n\n---\n\n## Connection Management\n\n### Pattern 5: Connection Pooling\n\n**Problem**: Creating new connections is expensive\n\n**Solution**: Reuse connections\n\n```typescript\nclass ConnectionPool {\n  private connections: Map<string, Socket> = new Map();\n  private maxIdleTime = 60000; // 1 minute\n\n  getConnection(userId: string): Socket {\n    if (this.connections.has(userId)) {\n      return this.connections.get(userId)!;\n    }\n\n    const socket = this.createConnection(userId);\n    this.connections.set(userId, socket);\n\n    // Clean up idle connections\n    setTimeout(() => {\n      if (!this.isActive(socket)) {\n        socket.disconnect();\n        this.connections.delete(userId);\n      }\n    }, this.maxIdleTime);\n\n    return socket;\n  }\n}\n```\n\n---\n\n### Pattern 6: Heartbeat/Ping-Pong\n\n**Problem**: Dead connections consuming resources\n\n**Solution**: Detect and close dead connections\n\n```typescript\nconst HEARTBEAT_INTERVAL = 30000; // 30 seconds\nconst HEARTBEAT_TIMEOUT = 5000;   // 5 seconds\n\nio.on('connection', (socket) => {\n  let lastPong = Date.now();\n\n  // Send ping\n  const interval = setInterval(() => {\n    socket.emit('ping');\n  }, HEARTBEAT_INTERVAL);\n\n  // Receive pong\n  socket.on('pong', () => {\n    lastPong = Date.now();\n  });\n\n  // Check for timeout\n  const timeoutCheck = setInterval(() => {\n    if (Date.now() - lastPong > HEARTBEAT_TIMEOUT) {\n      console.log('Connection timeout, closing');\n      socket.disconnect();\n    }\n  }, HEARTBEAT_INTERVAL);\n\n  socket.on('disconnect', () => {\n    clearInterval(interval);\n    clearInterval(timeoutCheck);\n  });\n});\n```\n\n---\n\n## Message Optimization\n\n### Pattern 7: Message Batching\n\n**Problem**: Too many small messages\n\n**Solution**: Batch messages\n\n```typescript\nclass MessageBatcher {\n  private batch: any[] = [];\n  private batchInterval = 100; // ms\n  private timer: NodeJS.Timeout | null = null;\n\n  add(message: any): void {\n    this.batch.push(message);\n\n    if (!this.timer) {\n      this.timer = setTimeout(() => {\n        this.flush();\n      }, this.batchInterval);\n    }\n  }\n\n  private flush(): void {\n    if (this.batch.length > 0) {\n      socket.emit('batch', this.batch);\n      this.batch = [];\n    }\n    this.timer = null;\n  }\n}\n```\n\n**Impact**: 1000 messages/sec ‚Üí 10 batches/sec (100x reduction)\n\n---\n\n### Pattern 8: Message Compression\n\n**Problem**: Large payloads waste bandwidth\n\n**Solution**: Compress messages\n\n```typescript\nimport pako from 'pako';\n\n// Compression middleware\nio.use((socket, next) => {\n  // Compress outgoing\n  const originalEmit = socket.emit.bind(socket);\n  socket.emit = function (event: string, data: any) {\n    const compressed = pako.deflate(JSON.stringify(data));\n    return originalEmit(event, compressed);\n  };\n\n  // Decompress incoming\n  socket.onAny((event, data) => {\n    if (data instanceof Buffer) {\n      const decompressed = pako.inflate(data, { to: 'string' });\n      socket.emit(event, JSON.parse(decompressed));\n    }\n  });\n\n  next();\n});\n```\n\n**Impact**: 100KB payload ‚Üí 20KB compressed (80% reduction)\n\n---\n\n## Monitoring and Metrics\n\n### Pattern 9: Real-Time Metrics\n\n**Track**:\n- Active connections per server\n- Messages per second\n- Average latency\n- Error rate\n\n```typescript\nimport { register, Counter, Gauge, Histogram } from 'prom-client';\n\n// Metrics\nconst connectionsGauge = new Gauge({\n  name: 'websocket_connections',\n  help: 'Number of active WebSocket connections'\n});\n\nconst messagesCounter = new Counter({\n  name: 'websocket_messages_total',\n  help: 'Total WebSocket messages',\n  labelNames: ['type', 'direction']\n});\n\nconst latencyHistogram = new Histogram({\n  name: 'websocket_message_latency_ms',\n  help: 'Message round-trip latency',\n  buckets: [10, 50, 100, 500, 1000, 5000]\n});\n\n// Update metrics\nio.on('connection', (socket) => {\n  connectionsGauge.inc();\n\n  socket.on('message', (data) => {\n    messagesCounter.inc({ type: 'message', direction: 'inbound' });\n    const latency = Date.now() - data.timestamp;\n    latencyHistogram.observe(latency);\n  });\n\n  socket.on('disconnect', () => {\n    connectionsGauge.dec();\n  });\n});\n\n// Expose metrics endpoint\napp.get('/metrics', (req, res) => {\n  res.set('Content-Type', register.contentType);\n  res.end(register.metrics());\n});\n```\n\n---\n\n## Cloud Scaling\n\n### AWS Architecture\n\n```\n                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                     ‚îÇ  Application     ‚îÇ\n                     ‚îÇ  Load Balancer   ‚îÇ\n                     ‚îÇ  (ALB)           ‚îÇ\n                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                              ‚îÇ\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n              ‚îÇ               ‚îÇ               ‚îÇ\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚îÇ WebSocket ‚îÇ   ‚îÇ WebSocket ‚îÇ  ‚îÇ WebSocket ‚îÇ\n        ‚îÇ Server 1  ‚îÇ   ‚îÇ Server 2  ‚îÇ  ‚îÇ Server 3  ‚îÇ\n        ‚îÇ (EC2)     ‚îÇ   ‚îÇ (EC2)     ‚îÇ  ‚îÇ (EC2)     ‚îÇ\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚îÇ              ‚îÇ              ‚îÇ\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                             ‚îÇ\n                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                    ‚îÇ  ElastiCache    ‚îÇ\n                    ‚îÇ  (Redis)        ‚îÇ\n                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Auto-scaling**:\n\n```yaml\n# EC2 Auto Scaling Group\nScalingPolicy:\n  MetricType: Custom\n  Metric: WebSocketConnections\n  TargetValue: 8000  # Scale at 80% of 10k limit\n  ScaleUp: Add 1 instance\n  ScaleDown: Remove 1 instance (drain connections first)\n```\n\n---\n\n### Kubernetes Architecture\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: websocket-server\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: websocket\n  template:\n    metadata:\n      labels:\n        app: websocket\n    spec:\n      containers:\n      - name: server\n        image: myapp/websocket:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: REDIS_URL\n          value: redis://redis-service:6379\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: websocket-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: websocket\n  ports:\n  - port: 80\n    targetPort: 3000\n  sessionAffinity: ClientIP  # Sticky sessions\n```\n\n**Horizontal Pod Autoscaler**:\n\n```yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: websocket-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: websocket-server\n  minReplicas: 3\n  maxReplicas: 50\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Pods\n    pods:\n      metric:\n        name: websocket_connections\n      target:\n        type: AverageValue\n        averageValue: \"8000\"\n```\n\n---\n\n## Cost Optimization\n\n### Pattern 10: Regional Sharding\n\n**Problem**: Global latency\n\n**Solution**: Deploy regionally\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  US-East   ‚îÇ     ‚îÇ  EU-West   ‚îÇ     ‚îÇ  AP-South  ‚îÇ\n‚îÇ  Cluster   ‚îÇ     ‚îÇ  Cluster   ‚îÇ     ‚îÇ  Cluster   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n      ‚îÇ                  ‚îÇ                  ‚îÇ\n      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                         ‚îÇ\n                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                  ‚îÇ   Global    ‚îÇ\n                  ‚îÇ   Redis     ‚îÇ\n                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Latency reduction**: 200ms ‚Üí 20ms for nearby users\n\n---\n\n## Capacity Planning\n\n### Formulas\n\n**Connections per server**:\n```\nMax Connections = (Available RAM - OS Overhead) / Memory per Connection\n                = (16 GB - 2 GB) / 1 MB\n                = 14,000 connections\n```\n\n**Servers needed**:\n```\nServers = Total Users / Connections per Server\n        = 1,000,000 / 10,000\n        = 100 servers\n```\n\n**Monthly cost** (AWS t3.large, $0.0832/hour):\n```\nCost = Servers √ó Hours per Month √ó Rate\n     = 100 √ó 730 √ó $0.0832\n     = $6,074 per month\n```\n\n---\n\n## Production Checklist\n\n```\n‚ñ° Redis Pub/Sub for cross-server communication\n‚ñ° Sticky sessions configured\n‚ñ° Heartbeat/ping-pong to detect dead connections\n‚ñ° Message batching (100-200ms)\n‚ñ° Message compression for large payloads\n‚ñ° Monitoring (connections, messages/sec, latency)\n‚ñ° Auto-scaling based on connection count\n‚ñ° Regional deployment for low latency\n‚ñ° Load testing (simulate peak load)\n‚ñ° Graceful shutdown (drain connections)\n‚ñ° Circuit breaker for downstream services\n‚ñ° Rate limiting per user\n```\n\n---\n\n## Load Testing\n\n### Using Artillery\n\n```yaml\n# load-test.yml\nconfig:\n  target: \"wss://localhost:3000\"\n  phases:\n    - duration: 60\n      arrivalRate: 100  # 100 connections/sec\n      name: \"Ramp up\"\n    - duration: 300\n      arrivalRate: 1000  # 1000 connections/sec\n      name: \"Sustained load\"\n  engines:\n    socketio: {}\n\nscenarios:\n  - engine: socketio\n    flow:\n      - emit:\n          channel: \"join-room\"\n          data:\n            roomId: \"{{ $randomString() }}\"\n      - think: 5\n      - loop:\n          - emit:\n              channel: \"message\"\n              data:\n                text: \"Hello {{ $randomString() }}\"\n          - think: 2\n        count: 10\n```\n\n**Run**:\n```bash\nartillery run load-test.yml\n```\n\n---\n\n## Resources\n\n- [Socket.IO Scaling](https://socket.io/docs/v4/using-multiple-nodes/)\n- [Redis Adapter](https://github.com/socketio/socket.io-redis-adapter)\n- [AWS ALB WebSocket](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#websockets)\n- [Kubernetes HPA](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "real-time-collaboration-engine/scripts",
      "children": [
        {
          "name": "collaboration_tester.ts",
          "type": "file",
          "path": "real-time-collaboration-engine/scripts/collaboration_tester.ts",
          "size": 9966,
          "content": "#!/usr/bin/env node\n/**\n * Collaboration Testing Tool\n *\n * Simulates concurrent edits to test conflict resolution strategies.\n *\n * Usage: npx tsx collaboration_tester.ts [strategy] [users]\n *\n * Examples:\n *   npx tsx collaboration_tester.ts ot 5\n *   npx tsx collaboration_tester.ts crdt 10\n *   npx tsx collaboration_tester.ts lww 3\n *\n * Strategies:\n *   - ot: Operational Transform (for text)\n *   - crdt: CRDT (for JSON objects)\n *   - lww: Last-Write-Wins (simple strategy)\n */\n\nimport * as fs from 'fs';\n\ntype Strategy = 'ot' | 'crdt' | 'lww';\n\ninterface Operation {\n  userId: string;\n  timestamp: number;\n  type: 'insert' | 'delete' | 'replace';\n  position: number;\n  content?: string;\n  length?: number;\n}\n\ninterface User {\n  id: string;\n  document: string;\n  operations: Operation[];\n}\n\nclass CollaborationTester {\n  private strategy: Strategy;\n  private users: User[];\n  private serverDocument: string;\n  private serverRevision: number = 0;\n\n  constructor(strategy: Strategy, userCount: number) {\n    this.strategy = strategy;\n    this.serverDocument = 'Initial document text.';\n\n    // Create simulated users\n    this.users = Array.from({ length: userCount }, (_, i) => ({\n      id: `user-${i + 1}`,\n      document: this.serverDocument,\n      operations: []\n    }));\n  }\n\n  /**\n   * Simulate concurrent editing session\n   */\n  async run(): Promise<void> {\n    console.log(`\\nüß™ Testing ${this.strategy.toUpperCase()} with ${this.users.length} users\\n`);\n    console.log(`Initial document: \"${this.serverDocument}\"\\n`);\n\n    // Phase 1: Generate random operations for each user\n    this.users.forEach(user => {\n      const opCount = Math.floor(Math.random() * 3) + 1;\n      for (let i = 0; i < opCount; i++) {\n        const operation = this.generateRandomOperation(user.id, user.document);\n        user.operations.push(operation);\n\n        // Apply locally (optimistic)\n        user.document = this.applyOperationLocally(user.document, operation);\n      }\n    });\n\n    console.log('Generated operations:\\n');\n    this.users.forEach(user => {\n      console.log(`${user.id}:`);\n      user.operations.forEach(op => {\n        console.log(`  - ${op.type} at ${op.position}: \"${op.content || ''}\"`);\n      });\n      console.log(`  Local result: \"${user.document}\"\\n`);\n    });\n\n    // Phase 2: Send operations to server and apply conflict resolution\n    await this.processOperations();\n\n    // Phase 3: Show results\n    this.showResults();\n  }\n\n  private generateRandomOperation(userId: string, document: string): Operation {\n    const operations: Operation['type'][] = ['insert', 'delete', 'replace'];\n    const type = operations[Math.floor(Math.random() * operations.length)];\n\n    const position = Math.floor(Math.random() * document.length);\n\n    switch (type) {\n      case 'insert':\n        return {\n          userId,\n          timestamp: Date.now(),\n          type: 'insert',\n          position,\n          content: this.randomText()\n        };\n\n      case 'delete':\n        return {\n          userId,\n          timestamp: Date.now(),\n          type: 'delete',\n          position,\n          length: Math.min(5, document.length - position)\n        };\n\n      case 'replace':\n        return {\n          userId,\n          timestamp: Date.now(),\n          type: 'replace',\n          position,\n          length: Math.min(5, document.length - position),\n          content: this.randomText()\n        };\n    }\n  }\n\n  private randomText(): string {\n    const words = ['hello', 'world', 'test', 'edit', 'change'];\n    return words[Math.floor(Math.random() * words.length)] + ' ';\n  }\n\n  private applyOperationLocally(document: string, op: Operation): string {\n    switch (op.type) {\n      case 'insert':\n        return document.slice(0, op.position) +\n               op.content +\n               document.slice(op.position);\n\n      case 'delete':\n        return document.slice(0, op.position) +\n               document.slice(op.position + (op.length || 0));\n\n      case 'replace':\n        return document.slice(0, op.position) +\n               op.content +\n               document.slice(op.position + (op.length || 0));\n    }\n  }\n\n  private async processOperations(): Promise<void> {\n    console.log('‚îÄ'.repeat(80));\n    console.log('\\nüîÑ Processing operations on server...\\n');\n\n    // Collect all operations\n    const allOperations: Operation[] = [];\n    this.users.forEach(user => {\n      allOperations.push(...user.operations);\n    });\n\n    // Sort by timestamp (simulate network order)\n    allOperations.sort((a, b) => a.timestamp - b.timestamp);\n\n    // Apply each operation using selected strategy\n    allOperations.forEach(op => {\n      console.log(`Processing ${op.userId} ${op.type} at position ${op.position}`);\n\n      switch (this.strategy) {\n        case 'ot':\n          this.applyOT(op);\n          break;\n        case 'crdt':\n          this.applyCRDT(op);\n          break;\n        case 'lww':\n          this.applyLWW(op);\n          break;\n      }\n\n      console.log(`  Server state: \"${this.serverDocument}\"\\n`);\n    });\n  }\n\n  /**\n   * Operational Transform (simplified)\n   */\n  private applyOT(op: Operation): void {\n    // In real OT, we'd transform against concurrent operations\n    // This is a simplified version\n    this.serverDocument = this.applyOperationLocally(this.serverDocument, op);\n    this.serverRevision++;\n  }\n\n  /**\n   * CRDT (simplified - uses unique position IDs)\n   */\n  private applyCRDT(op: Operation): void {\n    // CRDTs use unique identifiers for each character\n    // This is a simplified version showing the concept\n    this.serverDocument = this.applyOperationLocally(this.serverDocument, op);\n    this.serverRevision++;\n  }\n\n  /**\n   * Last-Write-Wins (simplest strategy)\n   */\n  private applyLWW(op: Operation): void {\n    // Just apply operation as-is\n    // Later timestamps overwrite earlier ones\n    this.serverDocument = this.applyOperationLocally(this.serverDocument, op);\n    this.serverRevision++;\n  }\n\n  private showResults(): void {\n    console.log('‚îÄ'.repeat(80));\n    console.log('\\nüìä Results:\\n');\n\n    console.log(`Strategy: ${this.strategy.toUpperCase()}`);\n    console.log(`Total operations: ${this.users.reduce((sum, u) => sum + u.operations.length, 0)}`);\n    console.log(`Server revision: ${this.serverRevision}`);\n    console.log(`\\nFinal server document:\\n  \"${this.serverDocument}\"\\n`);\n\n    console.log('User local documents:\\n');\n    this.users.forEach(user => {\n      const matches = user.document === this.serverDocument;\n      const icon = matches ? '‚úÖ' : '‚ùå';\n      console.log(`${icon} ${user.id}: \"${user.document}\"`);\n    });\n\n    // Check for consistency\n    const allMatch = this.users.every(u => u.document === this.serverDocument);\n\n    console.log('\\n‚îÄ'.repeat(80));\n    if (allMatch) {\n      console.log('\\n‚úÖ All users converged to same state!');\n    } else {\n      console.log('\\n‚ö†Ô∏è  Users have divergent states (need server sync)');\n    }\n\n    // Strategy comparison\n    console.log('\\nüí° Strategy Characteristics:\\n');\n\n    switch (this.strategy) {\n      case 'ot':\n        console.log('  Operational Transform:');\n        console.log('  ‚úÖ Preserves intent of operations');\n        console.log('  ‚úÖ Works well for text');\n        console.log('  ‚ùå Complex to implement correctly');\n        console.log('  ‚ùå Requires central server for coordination');\n        break;\n\n      case 'crdt':\n        console.log('  CRDT (Conflict-free Replicated Data Type):');\n        console.log('  ‚úÖ Automatic conflict resolution');\n        console.log('  ‚úÖ Works offline (peer-to-peer)');\n        console.log('  ‚úÖ Mathematically proven to converge');\n        console.log('  ‚ùå Higher memory overhead');\n        break;\n\n      case 'lww':\n        console.log('  Last-Write-Wins:');\n        console.log('  ‚úÖ Simple to implement');\n        console.log('  ‚úÖ Low overhead');\n        console.log('  ‚ùå Can lose data (overwrites concurrent edits)');\n        console.log('  ‚ùå Not suitable for collaborative editing');\n        break;\n    }\n\n    console.log('');\n  }\n\n  /**\n   * Generate test report\n   */\n  generateReport(outputPath: string): void {\n    const report = {\n      strategy: this.strategy,\n      users: this.users.length,\n      totalOperations: this.users.reduce((sum, u) => sum + u.operations.length, 0),\n      serverRevision: this.serverRevision,\n      finalDocument: this.serverDocument,\n      userDocuments: this.users.map(u => ({\n        id: u.id,\n        document: u.document,\n        operations: u.operations.length,\n        matchesServer: u.document === this.serverDocument\n      })),\n      convergence: this.users.every(u => u.document === this.serverDocument),\n      timestamp: new Date().toISOString()\n    };\n\n    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2));\n    console.log(`\\nüìÑ Report saved to: ${outputPath}`);\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length < 2) {\n    console.log('Usage: npx tsx collaboration_tester.ts [strategy] [users]');\n    console.log('\\nStrategies:');\n    console.log('  ot    - Operational Transform');\n    console.log('  crdt  - Conflict-free Replicated Data Type');\n    console.log('  lww   - Last-Write-Wins');\n    console.log('\\nExample:');\n    console.log('  npx tsx collaboration_tester.ts ot 5');\n    process.exit(1);\n  }\n\n  const strategy = args[0] as Strategy;\n  const userCount = parseInt(args[1], 10);\n\n  if (!['ot', 'crdt', 'lww'].includes(strategy)) {\n    console.error('Invalid strategy. Choose: ot, crdt, or lww');\n    process.exit(1);\n  }\n\n  if (isNaN(userCount) || userCount < 1) {\n    console.error('User count must be a positive number');\n    process.exit(1);\n  }\n\n  const tester = new CollaborationTester(strategy, userCount);\n  tester.run().then(() => {\n    if (args.includes('--report')) {\n      tester.generateReport('collaboration-test-report.json');\n    }\n  });\n}\n\nexport { CollaborationTester };\n"
        },
        {
          "name": "latency_simulator.ts",
          "type": "file",
          "path": "real-time-collaboration-engine/scripts/latency_simulator.ts",
          "size": 8927,
          "content": "#!/usr/bin/env node\n/**\n * Network Latency Simulator\n *\n * Tests real-time collaboration under various network conditions.\n *\n * Usage: npx tsx latency_simulator.ts [scenario]\n *\n * Examples:\n *   npx tsx latency_simulator.ts good\n *   npx tsx latency_simulator.ts bad\n *   npx tsx latency_simulator.ts mobile\n *   npx tsx latency_simulator.ts satellite\n *\n * Scenarios:\n *   - good: Fast fiber connection (10ms, 0% loss)\n *   - bad: Congested network (200ms, 5% loss)\n *   - mobile: 4G connection (100ms, 2% loss)\n *   - satellite: High latency (600ms, 1% loss)\n */\n\ninterface NetworkScenario {\n  name: string;\n  latency: number;        // Average RTT in ms\n  jitter: number;         // Latency variance in ms\n  packetLoss: number;     // Packet loss percentage (0-100)\n  bandwidth: number;      // KB/s\n}\n\nconst SCENARIOS: Record<string, NetworkScenario> = {\n  good: {\n    name: 'Fast Fiber',\n    latency: 10,\n    jitter: 2,\n    packetLoss: 0,\n    bandwidth: 10000  // 10 MB/s\n  },\n  bad: {\n    name: 'Congested Network',\n    latency: 200,\n    jitter: 50,\n    packetLoss: 5,\n    bandwidth: 500    // 500 KB/s\n  },\n  mobile: {\n    name: '4G Mobile',\n    latency: 100,\n    jitter: 30,\n    packetLoss: 2,\n    bandwidth: 1500   // 1.5 MB/s\n  },\n  satellite: {\n    name: 'Satellite',\n    latency: 600,\n    jitter: 100,\n    packetLoss: 1,\n    bandwidth: 2000   // 2 MB/s\n  }\n};\n\ninterface Message {\n  id: string;\n  timestamp: number;\n  payload: any;\n  size: number;  // bytes\n}\n\nclass LatencySimulator {\n  private scenario: NetworkScenario;\n  private messageQueue: Message[] = [];\n  private sentMessages: number = 0;\n  private receivedMessages: number = 0;\n  private droppedMessages: number = 0;\n  private totalLatency: number = 0;\n\n  constructor(scenarioName: string) {\n    const scenario = SCENARIOS[scenarioName];\n    if (!scenario) {\n      throw new Error(`Unknown scenario: ${scenarioName}`);\n    }\n    this.scenario = scenario;\n  }\n\n  /**\n   * Simulate sending a message\n   */\n  async send(payload: any): Promise<void> {\n    const message: Message = {\n      id: `msg-${this.sentMessages++}`,\n      timestamp: Date.now(),\n      payload,\n      size: JSON.stringify(payload).length\n    };\n\n    // Check if message is dropped\n    if (Math.random() * 100 < this.scenario.packetLoss) {\n      this.droppedMessages++;\n      console.log(`üì¶ ‚ùå Message ${message.id} DROPPED (packet loss)`);\n      return;\n    }\n\n    // Calculate latency with jitter\n    const latency = this.calculateLatency();\n\n    // Simulate network delay\n    console.log(`üì¶ ‚è≥ Sending ${message.id} (${message.size} bytes, ${latency}ms delay)`);\n\n    setTimeout(() => {\n      this.receive(message, latency);\n    }, latency);\n  }\n\n  /**\n   * Calculate latency with jitter\n   */\n  private calculateLatency(): number {\n    const baseLatency = this.scenario.latency;\n    const jitter = this.scenario.jitter;\n\n    // Random jitter: ¬±jitter\n    const variance = (Math.random() - 0.5) * 2 * jitter;\n\n    return Math.max(1, baseLatency + variance);\n  }\n\n  /**\n   * Simulate receiving a message\n   */\n  private receive(message: Message, latency: number): void {\n    this.receivedMessages++;\n    this.totalLatency += latency;\n\n    const now = Date.now();\n    const totalTime = now - message.timestamp;\n\n    console.log(`üì¶ ‚úÖ Received ${message.id} (total time: ${totalTime}ms)`);\n  }\n\n  /**\n   * Run simulation with multiple messages\n   */\n  async runSimulation(messageCount: number): Promise<void> {\n    console.log(`\\nüåê Network Simulation: ${this.scenario.name}\\n`);\n    console.log('Configuration:');\n    console.log(`  Latency: ${this.scenario.latency}ms ¬±${this.scenario.jitter}ms`);\n    console.log(`  Packet Loss: ${this.scenario.packetLoss}%`);\n    console.log(`  Bandwidth: ${this.scenario.bandwidth} KB/s\\n`);\n\n    console.log(`Sending ${messageCount} messages...\\n`);\n\n    // Send messages with realistic timing\n    for (let i = 0; i < messageCount; i++) {\n      const payload = {\n        type: 'text-change',\n        userId: 'user-1',\n        change: { position: i, text: 'Hello' }\n      };\n\n      await this.send(payload);\n\n      // Simulate typing delay (200ms between keystrokes)\n      await this.delay(200);\n    }\n\n    // Wait for all messages to arrive\n    await this.delay(this.scenario.latency * 2 + 1000);\n\n    this.showResults();\n  }\n\n  /**\n   * Test reconnection behavior\n   */\n  async testReconnection(): Promise<void> {\n    console.log(`\\nüîå Testing Reconnection Behavior\\n`);\n\n    // Simulate normal operation\n    console.log('Phase 1: Normal operation');\n    await this.send({ type: 'ping' });\n    await this.delay(500);\n\n    // Simulate disconnection\n    console.log('\\nPhase 2: Disconnection (10 messages queued)');\n    const offlineMessages = [];\n    for (let i = 0; i < 10; i++) {\n      offlineMessages.push({\n        type: 'offline-change',\n        change: `Change ${i}`\n      });\n      console.log(`  Queued: Change ${i}`);\n    }\n\n    await this.delay(2000);\n\n    // Simulate reconnection\n    console.log('\\nPhase 3: Reconnection (syncing queued messages)');\n    for (const msg of offlineMessages) {\n      await this.send(msg);\n      await this.delay(100);\n    }\n\n    await this.delay(this.scenario.latency * 2 + 1000);\n\n    console.log('\\n‚úÖ Reconnection complete\\n');\n  }\n\n  /**\n   * Show simulation results\n   */\n  private showResults(): void {\n    console.log('\\n‚îÄ'.repeat(80));\n    console.log('\\nüìä Simulation Results:\\n');\n\n    const avgLatency = this.totalLatency / this.receivedMessages;\n    const successRate = (this.receivedMessages / this.sentMessages) * 100;\n\n    console.log(`Messages sent: ${this.sentMessages}`);\n    console.log(`Messages received: ${this.receivedMessages}`);\n    console.log(`Messages dropped: ${this.droppedMessages}`);\n    console.log(`Success rate: ${successRate.toFixed(1)}%`);\n    console.log(`Average latency: ${avgLatency.toFixed(0)}ms\\n`);\n\n    // Performance assessment\n    this.assessPerformance(avgLatency, successRate);\n  }\n\n  private assessPerformance(avgLatency: number, successRate: number): void {\n    console.log('Performance Assessment:\\n');\n\n    // Latency rating\n    if (avgLatency < 50) {\n      console.log('  ‚úÖ Latency: Excellent - Real-time collaboration feels instant');\n    } else if (avgLatency < 150) {\n      console.log('  ‚ö†Ô∏è  Latency: Good - Minor delays, acceptable for most use cases');\n    } else if (avgLatency < 300) {\n      console.log('  ‚ö†Ô∏è  Latency: Fair - Noticeable delays, use optimistic updates');\n    } else {\n      console.log('  üî¥ Latency: Poor - Significant delays, consider conflict-free strategies');\n    }\n\n    // Packet loss rating\n    if (successRate > 99) {\n      console.log('  ‚úÖ Reliability: Excellent - Minimal packet loss');\n    } else if (successRate > 95) {\n      console.log('  ‚ö†Ô∏è  Reliability: Good - Some packet loss, implement retry logic');\n    } else {\n      console.log('  üî¥ Reliability: Poor - High packet loss, need robust error handling');\n    }\n\n    // Recommendations\n    console.log('\\nüí° Recommendations:\\n');\n\n    if (avgLatency > 200) {\n      console.log('  ‚Ä¢ Implement optimistic updates (apply changes immediately)');\n      console.log('  ‚Ä¢ Batch operations to reduce round-trips');\n      console.log('  ‚Ä¢ Use CRDTs for offline-first capability');\n    }\n\n    if (successRate < 98) {\n      console.log('  ‚Ä¢ Add message acknowledgments');\n      console.log('  ‚Ä¢ Implement exponential backoff retry');\n      console.log('  ‚Ä¢ Queue failed messages for later sync');\n    }\n\n    if (this.scenario.latency > 500) {\n      console.log('  ‚Ä¢ Avoid Operational Transform (requires low latency)');\n      console.log('  ‚Ä¢ Use CRDTs for better offline support');\n      console.log('  ‚Ä¢ Add \"Syncing...\" indicator to UI');\n    }\n\n    console.log('');\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0) {\n    console.log('Usage: npx tsx latency_simulator.ts [scenario]');\n    console.log('\\nAvailable scenarios:');\n    Object.entries(SCENARIOS).forEach(([key, scenario]) => {\n      console.log(`  ${key.padEnd(10)} - ${scenario.name} (${scenario.latency}ms, ${scenario.packetLoss}% loss)`);\n    });\n    console.log('\\nExamples:');\n    console.log('  npx tsx latency_simulator.ts good');\n    console.log('  npx tsx latency_simulator.ts satellite');\n    process.exit(1);\n  }\n\n  const scenario = args[0];\n\n  if (!SCENARIOS[scenario]) {\n    console.error(`Unknown scenario: ${scenario}`);\n    console.error('Available: good, bad, mobile, satellite');\n    process.exit(1);\n  }\n\n  const simulator = new LatencySimulator(scenario);\n\n  // Run both simulations\n  (async () => {\n    await simulator.runSimulation(10);\n    await simulator.testReconnection();\n  })();\n}\n\nexport { LatencySimulator, NetworkScenario };\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "real-time-collaboration-engine/SKILL.md",
      "size": 13767,
      "content": "---\nname: real-time-collaboration-engine\ndescription: Build real-time collaborative editing with WebSockets, OT/CRDT conflict resolution, and presence awareness. Implements cursor tracking, optimistic updates, and offline sync. Use for collaborative editors, whiteboards, video editing. Activate on \"real-time collaboration\", \"WebSocket sync\", \"multiplayer editing\", \"CRDT\", \"presence awareness\". NOT for simple chat, request-response APIs, or single-user apps.\nallowed-tools: Read,Write,Edit,Bash(npm:*,websocket:*)\n---\n\n# Real-Time Collaboration Engine\n\nExpert in building Google Docs-style collaborative editing with WebSockets, conflict resolution, and presence awareness.\n\n## When to Use\n\n‚úÖ **Use for**:\n- Collaborative text/code editors\n- Shared whiteboards and design tools\n- Multi-user video editing timelines\n- Real-time data dashboards\n- Multiplayer game state sync\n\n‚ùå **NOT for**:\n- Simple chat applications (use basic WebSocket)\n- Request-response APIs (use REST/GraphQL)\n- Single-user applications\n- Read-only data streaming (use Server-Sent Events)\n\n## Quick Decision Tree\n\n```\nNeed real-time collaboration?\n‚îú‚îÄ‚îÄ Text editing? ‚Üí Operational Transform (OT)\n‚îú‚îÄ‚îÄ JSON data structures? ‚Üí CRDTs\n‚îú‚îÄ‚îÄ Cursor tracking only? ‚Üí Simple WebSocket + presence\n‚îú‚îÄ‚îÄ Offline-first? ‚Üí CRDTs (better offline merge)\n‚îî‚îÄ‚îÄ No conflicts possible? ‚Üí Basic broadcast\n```\n\n---\n\n## Technology Selection\n\n### Conflict Resolution Strategies (2024)\n\n| Strategy | Best For | Complexity | Offline Support |\n|----------|----------|------------|-----------------|\n| Operational Transform (OT) | Text, ordered sequences | High | Limited |\n| CRDTs | JSON objects, sets | Medium | Excellent |\n| Last-Write-Wins | Simple state | Low | Basic |\n| Three-Way Merge | Git-style editing | High | Good |\n\n**Timeline**:\n- 2010: Google Wave uses OT\n- 2014: Figma adopts CRDTs\n- 2019: Yjs (CRDT library) released\n- 2022: Automerge 2.0 (CRDT library) released\n- 2024: PartyKit simplifies real-time infrastructure\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: Broadcasting Every Keystroke\n\n**Novice thinking**: \"Send every change immediately for real-time feel\"\n\n**Problem**: Network floods with tiny messages, poor performance.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Sends message on every keystroke\nfunction Editor() {\n  const handleChange = (text: string) => {\n    socket.emit('text-change', { text });  // Every keystroke!\n  };\n\n  return <textarea onChange={(e) => handleChange(e.target.value)} />;\n}\n```\n\n**Why wrong**: 100 WPM typing = 500 messages/minute = network congestion.\n\n**Correct approach**:\n```typescript\n// ‚úÖ Batches changes every 200ms\nfunction Editor() {\n  const [pendingChanges, setPendingChanges] = useState<Change[]>([]);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (pendingChanges.length > 0) {\n        socket.emit('text-batch', { changes: pendingChanges });\n        setPendingChanges([]);\n      }\n    }, 200);\n\n    return () => clearInterval(interval);\n  }, [pendingChanges]);\n\n  const handleChange = (change: Change) => {\n    setPendingChanges(prev => [...prev, change]);\n  };\n\n  return <textarea onChange={handleChange} />;\n}\n```\n\n**Impact**: 500 messages/minute ‚Üí 5 messages/second (90% reduction).\n\n---\n\n### Anti-Pattern 2: No Conflict Resolution Strategy\n\n**Problem**: Concurrent edits cause data loss or corruption.\n\n**Symptom**: Users see their changes disappear, documents become inconsistent.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Last write wins, overwrites concurrent changes\nsocket.on('text-change', ({ userId, text }) => {\n  setDocument(text);  // Loses concurrent edits!\n});\n```\n\n**Why wrong**: If User A and B edit simultaneously, one change is lost.\n\n**Correct approach (OT)**:\n```typescript\n// ‚úÖ Operational Transform for text\nimport { TextOperation } from 'ot.js';\n\nsocket.on('operation', ({ userId, operation, revision }) => {\n  const transformed = transformOperation(\n    operation,\n    pendingOperations,\n    revision\n  );\n\n  applyOperation(transformed);\n  incrementRevision();\n});\n\nfunction transformOperation(\n  incoming: Operation,\n  pending: Operation[],\n  baseRevision: number\n): Operation {\n  // Transform incoming against pending operations\n  let transformed = incoming;\n  for (const op of pending) {\n    transformed = TextOperation.transform(transformed, op)[0];\n  }\n  return transformed;\n}\n```\n\n**Correct approach (CRDT)**:\n```typescript\n// ‚úÖ CRDT for JSON objects\nimport * as Y from 'yjs';\n\nconst ydoc = new Y.Doc();\nconst ytext = ydoc.getText('document');\n\n// Automatically handles conflicts\nytext.insert(0, 'Hello');\n\n// Sync with peers\nconst provider = new WebsocketProvider('ws://localhost:1234', 'room', ydoc);\n```\n\n**Impact**: Concurrent edits merge correctly, no data loss.\n\n---\n\n### Anti-Pattern 3: Not Handling Disconnections\n\n**Problem**: User goes offline, loses work or sees stale state.\n\n**Wrong approach**:\n```typescript\n// ‚ùå No offline handling\nsocket.on('disconnect', () => {\n  console.log('Disconnected');  // That's it?!\n});\n```\n\n**Why wrong**: Pending changes lost, no reconnection strategy, bad UX.\n\n**Correct approach**:\n```typescript\n// ‚úÖ Queue changes offline, sync on reconnect\nconst [isOnline, setIsOnline] = useState(true);\nconst [offlineQueue, setOfflineQueue] = useState<Change[]>([]);\n\nsocket.on('disconnect', () => {\n  setIsOnline(false);\n  showToast('Offline - changes will sync when reconnected');\n});\n\nsocket.on('connect', () => {\n  setIsOnline(true);\n\n  // Send queued changes\n  if (offlineQueue.length > 0) {\n    socket.emit('sync-offline-changes', { changes: offlineQueue });\n    setOfflineQueue([]);\n  }\n});\n\nconst handleChange = (change: Change) => {\n  if (isOnline) {\n    socket.emit('change', change);\n  } else {\n    setOfflineQueue(prev => [...prev, change]);\n  }\n};\n```\n\n**Timeline context**:\n- 2015: Offline-first apps rare\n- 2020: PWAs make offline UX standard\n- 2024: Users expect seamless offline editing\n\n---\n\n### Anti-Pattern 4: Client-Only State Sync\n\n**Problem**: No server authority, clients get out of sync.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Clients broadcast to each other directly\nsocket.on('peer-change', ({ userId, change }) => {\n  applyChange(change);  // No validation, no server state\n});\n```\n\n**Why wrong**: Malicious client can send invalid data, no recovery from desync.\n\n**Correct approach**:\n```typescript\n// ‚úÖ Server is source of truth\n// Client\nsocket.emit('operation', { operation, clientRevision });\n\nsocket.on('ack', ({ serverRevision }) => {\n  if (serverRevision !== expectedRevision) {\n    // Desync detected, request full state\n    socket.emit('request-full-state');\n  }\n});\n\n// Server\nio.on('connection', (socket) => {\n  socket.on('operation', ({ operation, clientRevision }) => {\n    // Validate operation\n    if (!isValid(operation)) {\n      socket.emit('error', { message: 'Invalid operation' });\n      return;\n    }\n\n    // Apply to server state\n    const serverRevision = applyOperation(operation);\n\n    // Broadcast to all clients\n    io.emit('operation', { operation, serverRevision });\n  });\n});\n```\n\n**Impact**: Data integrity guaranteed, can recover from client bugs.\n\n---\n\n### Anti-Pattern 5: No Presence Awareness\n\n**Problem**: Users can't see who's editing what, causing edit conflicts.\n\n**Symptom**: Two people editing same section unknowingly.\n\n**Wrong approach**:\n```typescript\n// ‚ùå No awareness of other users\nfunction Editor() {\n  return <textarea />;  // Flying blind!\n}\n```\n\n**Correct approach**:\n```typescript\n// ‚úÖ Show active users and cursors\nimport { usePresence } from './usePresence';\n\nfunction Editor() {\n  const { users, updateCursor } = usePresence();\n\n  const handleCursorMove = (position: number) => {\n    socket.emit('cursor-move', { userId: myId, position });\n  };\n\n  return (\n    <div>\n      {/* Show who's online */}\n      <UserList users={users} />\n\n      {/* Show remote cursors */}\n      <EditorWithCursors\n        content={content}\n        cursors={users.map(u => u.cursor)}\n        onCursorMove={handleCursorMove}\n      />\n    </div>\n  );\n}\n```\n\n**Features**:\n- Active user list with avatars\n- Cursor positions color-coded by user\n- Selection ranges highlighted\n- \"User X is typing...\" indicators\n\n---\n\n## Implementation Patterns\n\n### Pattern 1: WebSocket Setup with Reconnection\n\n```typescript\nimport { io } from 'socket.io-client';\n\nconst socket = io('ws://localhost:3000', {\n  reconnection: true,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  reconnectionAttempts: Infinity,\n  transports: ['websocket', 'polling']  // Fallback\n});\n\nsocket.on('connect', () => {\n  console.log('Connected:', socket.id);\n});\n\nsocket.on('disconnect', (reason) => {\n  if (reason === 'io server disconnect') {\n    // Server disconnected, manually reconnect\n    socket.connect();\n  }\n});\n\nsocket.on('connect_error', (error) => {\n  console.error('Connection error:', error);\n});\n```\n\n### Pattern 2: Operational Transform (Text)\n\n```typescript\nimport { TextOperation } from 'ot.js';\n\nclass OTEditor {\n  private revision = 0;\n  private pendingOperations: TextOperation[] = [];\n\n  applyLocalOperation(op: TextOperation): void {\n    // Apply immediately (optimistic update)\n    this.applyToEditor(op);\n\n    // Send to server\n    this.sendOperation(op);\n\n    // Store as pending\n    this.pendingOperations.push(op);\n  }\n\n  receiveRemoteOperation(op: TextOperation, serverRevision: number): void {\n    // Transform against pending operations\n    let transformed = op;\n    for (const pending of this.pendingOperations) {\n      [transformed, pending] = TextOperation.transform(transformed, pending);\n    }\n\n    // Apply transformed operation\n    this.applyToEditor(transformed);\n    this.revision = serverRevision;\n  }\n\n  acknowledgeOperation(serverRevision: number): void {\n    // Remove acknowledged operation from pending\n    this.pendingOperations.shift();\n    this.revision = serverRevision;\n  }\n}\n```\n\n### Pattern 3: CRDT with Yjs\n\n```typescript\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\n\n// Create shared document\nconst ydoc = new Y.Doc();\n\n// Define shared types\nconst ytext = ydoc.getText('content');\nconst ymap = ydoc.getMap('metadata');\nconst yarray = ydoc.getArray('users');\n\n// Connect to sync server\nconst provider = new WebsocketProvider(\n  'ws://localhost:1234',\n  'room-name',\n  ydoc\n);\n\n// Listen to changes\nytext.observe(event => {\n  console.log('Text changed:', event.changes);\n});\n\n// Make changes (automatically synced)\nytext.insert(0, 'Hello ');\nytext.insert(6, 'World!');\n\n// Undo/redo support\nconst undoManager = new Y.UndoManager(ytext);\nundoManager.undo();\nundoManager.redo();\n```\n\n### Pattern 4: Presence Awareness\n\n```typescript\nimport { Awareness } from 'y-protocols/awareness';\n\nconst awareness = provider.awareness;\n\n// Set local state\nawareness.setLocalState({\n  user: {\n    name: 'Alice',\n    color: '#ff0000',\n    cursor: { line: 10, ch: 5 }\n  }\n});\n\n// Listen to changes\nawareness.on('change', ({ added, updated, removed }) => {\n  // Update UI with user cursors/selections\n  const states = awareness.getStates();\n  states.forEach((state, clientId) => {\n    if (clientId !== awareness.clientID) {\n      renderCursor(state.user.cursor, state.user.color);\n    }\n  });\n});\n```\n\n### Pattern 5: Optimistic Updates with Rollback\n\n```typescript\nclass OptimisticEditor {\n  private optimisticChanges = new Map<string, Change>();\n\n  async applyChange(change: Change): Promise<void> {\n    const changeId = generateId();\n\n    // Apply immediately (optimistic)\n    this.applyToUI(change);\n    this.optimisticChanges.set(changeId, change);\n\n    try {\n      // Send to server\n      const result = await this.sendToServer(change);\n\n      // Success - remove from optimistic\n      this.optimisticChanges.delete(changeId);\n\n    } catch (error) {\n      // Failed - rollback\n      this.rollback(changeId);\n      this.showError('Could not apply change');\n    }\n  }\n\n  private rollback(changeId: string): void {\n    const change = this.optimisticChanges.get(changeId);\n    if (change) {\n      this.revertInUI(change);\n      this.optimisticChanges.delete(changeId);\n    }\n  }\n}\n```\n\n---\n\n## Production Checklist\n\n```\n‚ñ° WebSocket connection with auto-reconnect\n‚ñ° Offline queue for pending changes\n‚ñ° Conflict resolution strategy (OT or CRDT)\n‚ñ° Server authority (clients can't desync)\n‚ñ° Presence awareness (cursors, active users)\n‚ñ° Optimistic updates with rollback\n‚ñ° Change batching (not per-keystroke)\n‚ñ° Message compression for large payloads\n‚ñ° Authentication and authorization\n‚ñ° Rate limiting (prevent spam)\n‚ñ° Heartbeat/ping-pong to detect dead connections\n‚ñ° Graceful degradation (falls back to polling if WebSocket fails)\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Strategy |\n|----------|----------|\n| Text editing (Google Docs) | ‚úÖ Operational Transform |\n| JSON objects (Figma) | ‚úÖ CRDTs (Yjs, Automerge) |\n| Simple cursor sharing | ‚úÖ Basic WebSocket + presence |\n| Chat messages | ‚úÖ Simple append-only (no OT/CRDT) |\n| Video timeline editing | ‚úÖ CRDTs for timeline, OT for text |\n| Read-only dashboards | ‚ùå Use Server-Sent Events instead |\n\n---\n\n## References\n\n- `/references/ot-vs-crdt.md` - Deep comparison of conflict resolution strategies\n- `/references/websocket-scaling.md` - Scaling to millions of concurrent connections\n- `/references/presence-patterns.md` - Cursor tracking, user awareness, activity indicators\n\n## Scripts\n\n- `scripts/collaboration_tester.ts` - Simulate concurrent edits, test conflict resolution\n- `scripts/latency_simulator.ts` - Test behavior under high latency/packet loss\n\n---\n\n**This skill guides**: Real-time collaboration | WebSocket architecture | Operational Transform | CRDTs | Presence awareness | Conflict resolution\n"
    }
  ]
}