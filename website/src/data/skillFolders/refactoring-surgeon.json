{
  "name": "refactoring-surgeon",
  "type": "folder",
  "path": "refactoring-surgeon",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "refactoring-surgeon/references",
      "children": [
        {
          "name": "extract-method.ts",
          "type": "file",
          "path": "refactoring-surgeon/references/extract-method.ts",
          "size": 6773,
          "content": "// Extract Method Refactoring Example\n// Transform long methods into focused, single-responsibility functions\n\n// =============================================================================\n// BEFORE: Long method with multiple responsibilities\n// =============================================================================\n\n// âŒ Long method with multiple responsibilities\nfunction processOrderBefore(order: Order): OrderResult {\n  // Validate order\n  if (!order.items || order.items.length === 0) {\n    throw new Error('Order must have items');\n  }\n  if (!order.customer) {\n    throw new Error('Order must have customer');\n  }\n  if (!order.customer.email) {\n    throw new Error('Customer must have email');\n  }\n\n  // Calculate totals\n  let subtotal = 0;\n  for (const item of order.items) {\n    subtotal += item.price * item.quantity;\n  }\n  const tax = subtotal * 0.08;\n  const shipping = subtotal > 100 ? 0 : 10;\n  const total = subtotal + tax + shipping;\n\n  // Apply discounts\n  let discount = 0;\n  if (order.customer.loyaltyTier === 'gold') {\n    discount = total * 0.1;\n  } else if (order.customer.loyaltyTier === 'silver') {\n    discount = total * 0.05;\n  }\n  const finalTotal = total - discount;\n\n  // Create order record\n  const orderRecord = {\n    id: generateId(),\n    items: order.items,\n    customer: order.customer,\n    subtotal,\n    tax,\n    shipping,\n    discount,\n    total: finalTotal,\n    status: 'pending',\n    createdAt: new Date(),\n  };\n\n  // Send confirmation email\n  const emailContent = `\n    Dear ${order.customer.name},\n\n    Thank you for your order #${orderRecord.id}.\n\n    Items: ${order.items.length}\n    Subtotal: $${subtotal.toFixed(2)}\n    Tax: $${tax.toFixed(2)}\n    Shipping: $${shipping.toFixed(2)}\n    Discount: -$${discount.toFixed(2)}\n    Total: $${finalTotal.toFixed(2)}\n\n    Best regards\n  `;\n  sendEmail(order.customer.email, 'Order Confirmation', emailContent);\n\n  return orderRecord;\n}\n\n// =============================================================================\n// AFTER: Clean, single-responsibility functions\n// =============================================================================\n\n// âœ… Main orchestration function - reads like a story\nfunction processOrder(order: Order): OrderResult {\n  validateOrder(order);\n\n  const pricing = calculatePricing(order);\n  const discount = calculateLoyaltyDiscount(order.customer, pricing.total);\n  const finalTotal = pricing.total - discount;\n\n  const orderRecord = createOrderRecord(order, pricing, discount, finalTotal);\n\n  sendOrderConfirmation(order.customer, orderRecord, pricing, discount);\n\n  return orderRecord;\n}\n\n// âœ… Focused validation with custom error type\nfunction validateOrder(order: Order): void {\n  if (!order.items?.length) {\n    throw new OrderValidationError('Order must have items');\n  }\n  if (!order.customer) {\n    throw new OrderValidationError('Order must have customer');\n  }\n  if (!order.customer.email) {\n    throw new OrderValidationError('Customer must have email');\n  }\n}\n\n// âœ… Clear interface for pricing data\ninterface OrderPricing {\n  subtotal: number;\n  tax: number;\n  shipping: number;\n  total: number;\n}\n\n// âœ… Pricing calculation with extracted sub-functions\nfunction calculatePricing(order: Order): OrderPricing {\n  const subtotal = calculateSubtotal(order.items);\n  const tax = calculateTax(subtotal);\n  const shipping = calculateShipping(subtotal);\n\n  return {\n    subtotal,\n    tax,\n    shipping,\n    total: subtotal + tax + shipping,\n  };\n}\n\n// âœ… Pure function - easy to test\nfunction calculateSubtotal(items: OrderItem[]): number {\n  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n}\n\n// âœ… Constants replace magic numbers\nfunction calculateTax(subtotal: number): number {\n  const TAX_RATE = 0.08;\n  return subtotal * TAX_RATE;\n}\n\n// âœ… Business rules are clear\nfunction calculateShipping(subtotal: number): number {\n  const FREE_SHIPPING_THRESHOLD = 100;\n  const STANDARD_SHIPPING = 10;\n  return subtotal > FREE_SHIPPING_THRESHOLD ? 0 : STANDARD_SHIPPING;\n}\n\n// âœ… Lookup table replaces conditional chain\nconst LOYALTY_DISCOUNTS: Record<LoyaltyTier, number> = {\n  gold: 0.10,\n  silver: 0.05,\n  bronze: 0,\n  none: 0,\n};\n\nfunction calculateLoyaltyDiscount(customer: Customer, total: number): number {\n  const discountRate = LOYALTY_DISCOUNTS[customer.loyaltyTier] ?? 0;\n  return total * discountRate;\n}\n\n// âœ… Factory function with clear parameters\nfunction createOrderRecord(\n  order: Order,\n  pricing: OrderPricing,\n  discount: number,\n  finalTotal: number\n): OrderRecord {\n  return {\n    id: generateId(),\n    items: order.items,\n    customer: order.customer,\n    ...pricing,\n    discount,\n    total: finalTotal,\n    status: 'pending',\n    createdAt: new Date(),\n  };\n}\n\n// âœ… Email building extracted for testability\nfunction sendOrderConfirmation(\n  customer: Customer,\n  orderRecord: OrderRecord,\n  pricing: OrderPricing,\n  discount: number\n): void {\n  const emailContent = buildOrderConfirmationEmail(\n    customer,\n    orderRecord,\n    pricing,\n    discount\n  );\n  sendEmail(customer.email, 'Order Confirmation', emailContent);\n}\n\n// =============================================================================\n// Key Benefits\n// =============================================================================\n// 1. Each function has ONE responsibility\n// 2. Functions are small enough to understand at a glance\n// 3. Business rules (tax rate, shipping threshold) are named constants\n// 4. Easy to test each function in isolation\n// 5. Main function reads like documentation\n// 6. Changes to one concern don't affect others\n\n// =============================================================================\n// Type Definitions (for completeness)\n// =============================================================================\n\ninterface Order {\n  items: OrderItem[];\n  customer: Customer;\n}\n\ninterface OrderItem {\n  price: number;\n  quantity: number;\n}\n\ninterface Customer {\n  name: string;\n  email: string;\n  loyaltyTier: LoyaltyTier;\n}\n\ntype LoyaltyTier = 'gold' | 'silver' | 'bronze' | 'none';\n\ninterface OrderRecord {\n  id: string;\n  items: OrderItem[];\n  customer: Customer;\n  subtotal: number;\n  tax: number;\n  shipping: number;\n  discount: number;\n  total: number;\n  status: string;\n  createdAt: Date;\n}\n\ntype OrderResult = OrderRecord;\n\nclass OrderValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'OrderValidationError';\n  }\n}\n\n// Stubs for external dependencies\ndeclare function generateId(): string;\ndeclare function sendEmail(to: string, subject: string, body: string): void;\ndeclare function buildOrderConfirmationEmail(\n  customer: Customer,\n  order: OrderRecord,\n  pricing: OrderPricing,\n  discount: number\n): string;\n"
        },
        {
          "name": "introduce-parameter-object.ts",
          "type": "file",
          "path": "refactoring-surgeon/references/introduce-parameter-object.ts",
          "size": 7144,
          "content": "// Introduce Parameter Object\n// Replace long parameter lists with structured objects\n\n// =============================================================================\n// BEFORE: Long parameter list\n// =============================================================================\n\n// âŒ Long parameter list - hard to read, easy to make mistakes\nfunction searchProductsBefore(\n  query: string,\n  category: string,\n  minPrice: number,\n  maxPrice: number,\n  inStock: boolean,\n  sortBy: string,\n  sortOrder: 'asc' | 'desc',\n  page: number,\n  pageSize: number\n): Product[] {\n  // Implementation...\n  return [];\n}\n\n// Calling code is hard to read and error-prone\nconst productsBefore = searchProductsBefore(\n  'laptop',      // query\n  'electronics', // category\n  500,           // minPrice? maxPrice? Who knows!\n  2000,          // Is this min or max?\n  true,          // What is this boolean?\n  'price',       // sortBy\n  'asc',         // sortOrder\n  1,             // page\n  20             // pageSize\n);\n\n// Problems:\n// 1. Easy to swap min/max by accident\n// 2. Boolean without context\n// 3. Can't skip optional parameters\n// 4. Hard to add new parameters\n// 5. No IDE autocomplete help\n\n// =============================================================================\n// AFTER: Parameter objects with clear intent\n// =============================================================================\n\n// âœ… Separate \"what to find\" from \"how to return it\"\ninterface ProductSearchCriteria {\n  query: string;\n  category?: string;\n  priceRange?: {\n    min?: number;\n    max?: number;\n  };\n  inStockOnly?: boolean;\n  brand?: string;\n  rating?: {\n    min?: number;\n  };\n}\n\ninterface ProductSearchOptions {\n  sortBy?: 'price' | 'name' | 'rating' | 'date' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n  pagination?: {\n    page: number;\n    pageSize: number;\n  };\n}\n\ninterface ProductSearchResult {\n  products: Product[];\n  total: number;\n  page: number;\n  pageSize: number;\n  hasMore: boolean;\n}\n\n// âœ… Clean function signature\nfunction searchProducts(\n  criteria: ProductSearchCriteria,\n  options: ProductSearchOptions = {}\n): ProductSearchResult {\n  // Destructure with defaults\n  const {\n    sortBy = 'relevance',\n    sortOrder = 'desc',\n    pagination = { page: 1, pageSize: 20 }\n  } = options;\n\n  // Implementation uses clear, named properties\n  let results = findProducts(criteria.query);\n\n  if (criteria.category) {\n    results = results.filter(p => p.category === criteria.category);\n  }\n\n  if (criteria.priceRange) {\n    const { min = 0, max = Infinity } = criteria.priceRange;\n    results = results.filter(p => p.price >= min && p.price <= max);\n  }\n\n  if (criteria.inStockOnly) {\n    results = results.filter(p => p.inStock);\n  }\n\n  // Sort and paginate\n  results = sortProducts(results, sortBy, sortOrder);\n  const paged = paginateResults(results, pagination);\n\n  return paged;\n}\n\n// âœ… Calling code is self-documenting\nconst products = searchProducts(\n  {\n    query: 'laptop',\n    category: 'electronics',\n    priceRange: { min: 500, max: 2000 },\n    inStockOnly: true,\n  },\n  {\n    sortBy: 'price',\n    sortOrder: 'asc',\n    pagination: { page: 1, pageSize: 20 },\n  }\n);\n\n// âœ… Easy to use partial criteria\nconst simpleSearch = searchProducts({ query: 'keyboard' });\n\nconst categoryBrowse = searchProducts(\n  { query: '', category: 'monitors' },\n  { sortBy: 'rating' }\n);\n\n// =============================================================================\n// Builder Pattern for Complex Objects\n// =============================================================================\n\n// For even more complex scenarios, use a builder\nclass ProductSearchBuilder {\n  private criteria: ProductSearchCriteria = { query: '' };\n  private options: ProductSearchOptions = {};\n\n  query(query: string): this {\n    this.criteria.query = query;\n    return this;\n  }\n\n  category(category: string): this {\n    this.criteria.category = category;\n    return this;\n  }\n\n  priceRange(min?: number, max?: number): this {\n    this.criteria.priceRange = { min, max };\n    return this;\n  }\n\n  inStockOnly(): this {\n    this.criteria.inStockOnly = true;\n    return this;\n  }\n\n  sortBy(field: ProductSearchOptions['sortBy'], order: 'asc' | 'desc' = 'desc'): this {\n    this.options.sortBy = field;\n    this.options.sortOrder = order;\n    return this;\n  }\n\n  page(page: number, pageSize: number = 20): this {\n    this.options.pagination = { page, pageSize };\n    return this;\n  }\n\n  execute(): ProductSearchResult {\n    return searchProducts(this.criteria, this.options);\n  }\n}\n\n// âœ… Fluent interface for complex searches\nconst builderSearch = new ProductSearchBuilder()\n  .query('laptop')\n  .category('electronics')\n  .priceRange(500, 2000)\n  .inStockOnly()\n  .sortBy('price', 'asc')\n  .page(1, 20)\n  .execute();\n\n// =============================================================================\n// Validation with Parameter Objects\n// =============================================================================\n\n// Parameter objects make validation cleaner too\nfunction validateSearchCriteria(criteria: ProductSearchCriteria): void {\n  if (!criteria.query && !criteria.category) {\n    throw new Error('Must provide query or category');\n  }\n\n  if (criteria.priceRange) {\n    const { min = 0, max = Infinity } = criteria.priceRange;\n    if (min < 0) throw new Error('Min price cannot be negative');\n    if (max < min) throw new Error('Max price must be >= min price');\n  }\n\n  if (criteria.rating?.min !== undefined) {\n    if (criteria.rating.min < 0 || criteria.rating.min > 5) {\n      throw new Error('Rating must be between 0 and 5');\n    }\n  }\n}\n\n// =============================================================================\n// When to Use Parameter Objects\n// =============================================================================\n\n/*\nâœ… USE WHEN:\n- 3+ parameters (some say 2+)\n- Parameters are logically related\n- Same parameter groups appear in multiple functions\n- Optional parameters create awkward signatures\n- You want to add parameters without breaking callers\n\nâŒ DON'T USE WHEN:\n- Only 1-2 simple parameters\n- Parameters are truly independent\n- Would create one-off objects with no reuse\n- Function is private/internal with few callers\n\nBONUS BENEFITS:\n1. Easier to test - create test fixtures\n2. Easier to document - describe the object shape\n3. Easier to validate - centralized validation\n4. Easier to evolve - add properties without breaking\n5. IDE autocomplete - shows available options\n*/\n\n// =============================================================================\n// Type Definitions\n// =============================================================================\n\ninterface Product {\n  id: string;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n  rating: number;\n  brand: string;\n}\n\n// Stub functions\ndeclare function findProducts(query: string): Product[];\ndeclare function sortProducts(\n  products: Product[],\n  sortBy: string,\n  sortOrder: 'asc' | 'desc'\n): Product[];\ndeclare function paginateResults(\n  products: Product[],\n  pagination: { page: number; pageSize: number }\n): ProductSearchResult;\n"
        },
        {
          "name": "replace-conditional-polymorphism.ts",
          "type": "file",
          "path": "refactoring-surgeon/references/replace-conditional-polymorphism.ts",
          "size": 7345,
          "content": "// Replace Conditional with Polymorphism\n// Transform type-checking switch/if statements into polymorphic classes\n\n// =============================================================================\n// BEFORE: Type checking with switch/if\n// =============================================================================\n\n// âŒ Type checking with switch/if - violates Open/Closed Principle\nclass EmployeeBefore {\n  type: 'engineer' | 'manager' | 'salesperson';\n  baseSalary: number;\n  commission?: number;\n  teamSize?: number;\n\n  calculatePay(): number {\n    switch (this.type) {\n      case 'engineer':\n        return this.baseSalary;\n      case 'manager':\n        return this.baseSalary + (this.teamSize ?? 0) * 100;\n      case 'salesperson':\n        return this.baseSalary + (this.commission ?? 0);\n      default:\n        throw new Error('Unknown employee type');\n    }\n  }\n\n  getTitle(): string {\n    switch (this.type) {\n      case 'engineer':\n        return 'Software Engineer';\n      case 'manager':\n        return 'Engineering Manager';\n      case 'salesperson':\n        return 'Sales Representative';\n      default:\n        return 'Employee';\n    }\n  }\n\n  // Every new employee type requires modifying EVERY switch statement\n  // This violates the Open/Closed Principle\n}\n\n// =============================================================================\n// AFTER: Polymorphic solution\n// =============================================================================\n\n// âœ… Abstract base class defines the contract\nabstract class Employee {\n  constructor(protected baseSalary: number) {}\n\n  abstract calculatePay(): number;\n  abstract getTitle(): string;\n\n  // Shared behavior stays in base class\n  getBaseSalary(): number {\n    return this.baseSalary;\n  }\n}\n\n// âœ… Each type is its own class with specific behavior\nclass Engineer extends Employee {\n  calculatePay(): number {\n    return this.baseSalary;\n  }\n\n  getTitle(): string {\n    return 'Software Engineer';\n  }\n}\n\nclass Manager extends Employee {\n  constructor(baseSalary: number, private teamSize: number) {\n    super(baseSalary);\n  }\n\n  calculatePay(): number {\n    const BONUS_PER_REPORT = 100;\n    return this.baseSalary + this.teamSize * BONUS_PER_REPORT;\n  }\n\n  getTitle(): string {\n    return 'Engineering Manager';\n  }\n\n  // Manager-specific methods\n  getTeamSize(): number {\n    return this.teamSize;\n  }\n}\n\nclass Salesperson extends Employee {\n  constructor(baseSalary: number, private commission: number) {\n    super(baseSalary);\n  }\n\n  calculatePay(): number {\n    return this.baseSalary + this.commission;\n  }\n\n  getTitle(): string {\n    return 'Sales Representative';\n  }\n\n  // Salesperson-specific methods\n  getCommission(): number {\n    return this.commission;\n  }\n}\n\n// âœ… Factory centralizes creation logic - ONE place for type switching\ninterface EmployeeData {\n  baseSalary: number;\n  teamSize?: number;\n  commission?: number;\n}\n\nclass EmployeeFactory {\n  static create(type: string, data: EmployeeData): Employee {\n    switch (type) {\n      case 'engineer':\n        return new Engineer(data.baseSalary);\n      case 'manager':\n        return new Manager(data.baseSalary, data.teamSize ?? 0);\n      case 'salesperson':\n        return new Salesperson(data.baseSalary, data.commission ?? 0);\n      default:\n        throw new Error(`Unknown employee type: ${type}`);\n    }\n  }\n}\n\n// =============================================================================\n// Adding New Types - The Payoff\n// =============================================================================\n\n// âœ… Adding a new type is EASY - just add a new class\nclass Contractor extends Employee {\n  constructor(\n    baseSalary: number,\n    private hourlyRate: number,\n    private hoursWorked: number\n  ) {\n    super(baseSalary);\n  }\n\n  calculatePay(): number {\n    return this.hourlyRate * this.hoursWorked;\n  }\n\n  getTitle(): string {\n    return 'Independent Contractor';\n  }\n}\n\n// Just update the factory\nclass EmployeeFactoryV2 {\n  static create(type: string, data: any): Employee {\n    switch (type) {\n      case 'engineer':\n        return new Engineer(data.baseSalary);\n      case 'manager':\n        return new Manager(data.baseSalary, data.teamSize ?? 0);\n      case 'salesperson':\n        return new Salesperson(data.baseSalary, data.commission ?? 0);\n      case 'contractor':\n        return new Contractor(0, data.hourlyRate, data.hoursWorked);\n      default:\n        throw new Error(`Unknown employee type: ${type}`);\n    }\n  }\n}\n\n// =============================================================================\n// Usage Examples\n// =============================================================================\n\nfunction demonstratePolymorphism() {\n  // Create different employee types\n  const employees: Employee[] = [\n    EmployeeFactory.create('engineer', { baseSalary: 100000 }),\n    EmployeeFactory.create('manager', { baseSalary: 120000, teamSize: 5 }),\n    EmployeeFactory.create('salesperson', { baseSalary: 60000, commission: 25000 }),\n  ];\n\n  // Polymorphic behavior - no type checking needed!\n  for (const employee of employees) {\n    console.log(`${employee.getTitle()}: $${employee.calculatePay()}`);\n  }\n  // Output:\n  // Software Engineer: $100000\n  // Engineering Manager: $120500\n  // Sales Representative: $85000\n\n  // Calculate total payroll - works with ANY employee type\n  const totalPayroll = employees.reduce(\n    (sum, emp) => sum + emp.calculatePay(),\n    0\n  );\n  console.log(`Total Payroll: $${totalPayroll}`);\n}\n\n// =============================================================================\n// When to Use This Pattern\n// =============================================================================\n\n/*\nâœ… USE WHEN:\n- Same switch/if on type appears in multiple places\n- Each type has different behavior for multiple operations\n- New types are added frequently\n- You want to follow Open/Closed Principle\n\nâŒ DON'T USE WHEN:\n- Switch appears in only one place\n- Types rarely change\n- Behavior differences are minimal\n- Would create too many small classes\n\nRULE OF THUMB:\nIf you have switch(type) in 3+ places, or adding new types\nrequires changing multiple files, consider polymorphism.\n*/\n\n// =============================================================================\n// Alternative: Strategy Pattern for Behavior Injection\n// =============================================================================\n\n// When you need to swap behavior at runtime, use Strategy\ninterface PayCalculationStrategy {\n  calculate(baseSalary: number, context: any): number;\n}\n\nclass HourlyPayStrategy implements PayCalculationStrategy {\n  calculate(baseSalary: number, context: { hoursWorked: number }): number {\n    const HOURLY_RATE = baseSalary / 2080; // Annual to hourly\n    return HOURLY_RATE * context.hoursWorked;\n  }\n}\n\nclass SalaryPayStrategy implements PayCalculationStrategy {\n  calculate(baseSalary: number): number {\n    return baseSalary / 12; // Monthly salary\n  }\n}\n\nclass EmployeeWithStrategy {\n  constructor(\n    private baseSalary: number,\n    private payStrategy: PayCalculationStrategy\n  ) {}\n\n  calculateMonthlyPay(context?: any): number {\n    return this.payStrategy.calculate(this.baseSalary, context);\n  }\n\n  // Can change strategy at runtime\n  setPayStrategy(strategy: PayCalculationStrategy): void {\n    this.payStrategy = strategy;\n  }\n}\n"
        },
        {
          "name": "strangler-fig-pattern.ts",
          "type": "file",
          "path": "refactoring-surgeon/references/strangler-fig-pattern.ts",
          "size": 12125,
          "content": "// Strangler Fig Pattern\n// Gradually replace legacy code without big-bang rewrites\n\n// =============================================================================\n// THE PROBLEM: Monolithic Legacy Code\n// =============================================================================\n\n// âŒ Monolithic order processor - 500+ lines of tangled logic\nclass LegacyOrderProcessor {\n  processOrder(orderData: any): any {\n    // Validation mixed with business logic\n    if (!orderData.items) throw new Error('No items');\n    if (!orderData.customer) throw new Error('No customer');\n\n    // Pricing calculation intertwined\n    let total = 0;\n    for (const item of orderData.items) {\n      // Complex pricing rules embedded here\n      let price = item.basePrice;\n      if (orderData.customer.type === 'wholesale') {\n        price *= 0.8;\n      }\n      if (item.quantity > 10) {\n        price *= 0.95;\n      }\n      total += price * item.quantity;\n    }\n\n    // Inventory check with database calls\n    // Payment processing with external API calls\n    // Shipping calculation with carrier integration\n    // Email notification with template rendering\n    // Audit logging\n    // ... 400 more lines of tightly coupled code\n\n    return { orderId: 'generated', total };\n  }\n}\n\n// Problems:\n// 1. Can't test individual components\n// 2. Can't modify one thing without risk to everything\n// 3. Can't understand what it does without reading all 500 lines\n// 4. Can't rewrite all at once (too risky)\n\n// =============================================================================\n// STRANGLER FIG PATTERN: Step-by-Step Migration\n// =============================================================================\n\n// Step 1: Create a facade that delegates to legacy\n// -------------------------------------------------\n\nclass OrderProcessorV1 {\n  private legacy = new LegacyOrderProcessor();\n\n  async processOrder(order: Order): Promise<OrderResult> {\n    // Initially just delegate - establishes the new interface\n    const legacyResult = this.legacy.processOrder(order);\n    return this.adaptLegacyResult(legacyResult);\n  }\n\n  private adaptLegacyResult(legacy: any): OrderResult {\n    return {\n      orderId: legacy.orderId,\n      total: legacy.total,\n      status: 'completed',\n    };\n  }\n}\n\n// Step 2: Extract first component (validation)\n// -------------------------------------------------\n\nclass OrderValidator {\n  validate(order: Order): ValidationResult {\n    const errors: string[] = [];\n\n    if (!order.items?.length) {\n      errors.push('Order must have items');\n    }\n    if (!order.customer) {\n      errors.push('Order must have customer');\n    }\n    if (!order.customer?.email) {\n      errors.push('Customer must have email');\n    }\n\n    // Can add new validations without touching legacy\n    if (order.items?.some(item => item.quantity <= 0)) {\n      errors.push('All items must have positive quantity');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n}\n\nclass OrderProcessorV2 {\n  private legacy = new LegacyOrderProcessor();\n  private validator = new OrderValidator(); // NEW!\n\n  async processOrder(order: Order): Promise<OrderResult> {\n    // Use NEW validation\n    const validation = this.validator.validate(order);\n    if (!validation.valid) {\n      throw new ValidationError(validation.errors);\n    }\n\n    // Still delegate rest to legacy\n    const legacyResult = this.legacy.processOrder(order);\n    return this.adaptLegacyResult(legacyResult);\n  }\n\n  private adaptLegacyResult(legacy: any): OrderResult {\n    return {\n      orderId: legacy.orderId,\n      total: legacy.total,\n      status: 'completed',\n    };\n  }\n}\n\n// Step 3: Extract pricing service\n// -------------------------------------------------\n\ninterface PricingResult {\n  subtotal: number;\n  tax: number;\n  shipping: number;\n  discount: number;\n  total: number;\n}\n\nclass PricingService {\n  calculate(order: Order): PricingResult {\n    const subtotal = this.calculateSubtotal(order);\n    const discount = this.calculateDiscount(order, subtotal);\n    const tax = this.calculateTax(subtotal - discount);\n    const shipping = this.calculateShipping(order);\n\n    return {\n      subtotal,\n      tax,\n      shipping,\n      discount,\n      total: subtotal - discount + tax + shipping,\n    };\n  }\n\n  private calculateSubtotal(order: Order): number {\n    return order.items.reduce(\n      (sum, item) => sum + item.price * item.quantity,\n      0\n    );\n  }\n\n  private calculateDiscount(order: Order, subtotal: number): number {\n    // Wholesale discount\n    if (order.customer.type === 'wholesale') {\n      return subtotal * 0.2;\n    }\n    // Volume discount\n    const totalItems = order.items.reduce((sum, i) => sum + i.quantity, 0);\n    if (totalItems > 10) {\n      return subtotal * 0.05;\n    }\n    return 0;\n  }\n\n  private calculateTax(taxableAmount: number): number {\n    return taxableAmount * 0.08;\n  }\n\n  private calculateShipping(order: Order): number {\n    const weight = order.items.reduce(\n      (sum, i) => sum + (i.weight || 0) * i.quantity,\n      0\n    );\n    if (weight === 0) return 0;\n    if (weight < 5) return 5.99;\n    if (weight < 20) return 12.99;\n    return 24.99;\n  }\n}\n\nclass OrderProcessorV3 {\n  private legacy = new LegacyOrderProcessor();\n  private validator = new OrderValidator();\n  private pricingService = new PricingService(); // NEW!\n\n  async processOrder(order: Order): Promise<OrderResult> {\n    const validation = this.validator.validate(order);\n    if (!validation.valid) {\n      throw new ValidationError(validation.errors);\n    }\n\n    // Use NEW pricing\n    const pricing = this.pricingService.calculate(order);\n\n    // Delegate rest to legacy, but pass in our pricing\n    const legacyResult = this.legacy.processOrderWithPricing(order, pricing);\n    return this.adaptLegacyResult(legacyResult, pricing);\n  }\n\n  private adaptLegacyResult(legacy: any, pricing: PricingResult): OrderResult {\n    return {\n      orderId: legacy.orderId,\n      total: pricing.total,\n      status: 'completed',\n    };\n  }\n}\n\n// Step 4: Continue extracting until legacy is gone\n// -------------------------------------------------\n\n// Fully migrated - no more legacy!\nclass OrderProcessor {\n  constructor(\n    private validator: OrderValidator,\n    private pricingService: PricingService,\n    private inventoryService: InventoryService,\n    private paymentService: PaymentService,\n    private shippingService: ShippingService,\n    private notificationService: NotificationService,\n    private auditService: AuditService\n  ) {}\n\n  async processOrder(order: Order): Promise<OrderResult> {\n    // Validate\n    const validation = this.validator.validate(order);\n    if (!validation.valid) {\n      throw new ValidationError(validation.errors);\n    }\n\n    // Calculate pricing\n    const pricing = this.pricingService.calculate(order);\n\n    // Reserve inventory\n    const inventoryReservation = await this.inventoryService.reserve(order.items);\n\n    try {\n      // Process payment\n      const payment = await this.paymentService.charge(\n        order.customer,\n        pricing.total\n      );\n\n      // Schedule shipping\n      const shipping = await this.shippingService.schedule(order);\n\n      // Create order record\n      const orderResult = await this.createOrder(order, pricing, payment, shipping);\n\n      // Send confirmation\n      await this.notificationService.sendConfirmation(order.customer, orderResult);\n\n      // Audit log\n      await this.auditService.log('order_created', orderResult);\n\n      return orderResult;\n    } catch (error) {\n      // Release inventory on failure\n      await this.inventoryService.release(inventoryReservation);\n      throw error;\n    }\n  }\n\n  private async createOrder(\n    order: Order,\n    pricing: PricingResult,\n    payment: PaymentResult,\n    shipping: ShippingResult\n  ): Promise<OrderResult> {\n    return {\n      orderId: generateOrderId(),\n      total: pricing.total,\n      status: 'confirmed',\n      paymentId: payment.transactionId,\n      trackingNumber: shipping.trackingNumber,\n    };\n  }\n}\n\n// =============================================================================\n// BRANCH BY ABSTRACTION: Feature Flag Approach\n// =============================================================================\n\n// Use feature flags to safely switch between old and new\nclass OrderProcessorWithFeatureFlag {\n  constructor(\n    private legacy: LegacyOrderProcessor,\n    private newProcessor: OrderProcessor,\n    private featureFlags: FeatureFlags\n  ) {}\n\n  async processOrder(order: Order): Promise<OrderResult> {\n    // Gradual rollout by customer segment\n    const useNewProcessor = this.featureFlags.isEnabled(\n      'new_order_processor',\n      { customerId: order.customer.id }\n    );\n\n    if (useNewProcessor) {\n      return this.newProcessor.processOrder(order);\n    } else {\n      const legacyResult = this.legacy.processOrder(order);\n      return this.adaptResult(legacyResult);\n    }\n  }\n\n  private adaptResult(legacy: any): OrderResult {\n    return {\n      orderId: legacy.orderId,\n      total: legacy.total,\n      status: 'completed',\n    };\n  }\n}\n\n// =============================================================================\n// PARALLEL RUN: Verify New System\n// =============================================================================\n\n// Run both systems and compare results (shadow mode)\nclass OrderProcessorParallelRun {\n  constructor(\n    private legacy: LegacyOrderProcessor,\n    private newProcessor: OrderProcessor,\n    private comparisonLogger: ComparisonLogger\n  ) {}\n\n  async processOrder(order: Order): Promise<OrderResult> {\n    // Always use legacy for real result\n    const legacyResult = this.legacy.processOrder(order);\n\n    // Run new processor in shadow mode (don't affect real state)\n    try {\n      const newResult = await this.newProcessor.processOrderDryRun(order);\n\n      // Log comparison for analysis\n      this.comparisonLogger.logComparison({\n        orderId: legacyResult.orderId,\n        legacyTotal: legacyResult.total,\n        newTotal: newResult.total,\n        match: Math.abs(legacyResult.total - newResult.total) < 0.01,\n      });\n    } catch (error) {\n      this.comparisonLogger.logError({\n        orderId: legacyResult.orderId,\n        error: error.message,\n      });\n    }\n\n    return this.adaptResult(legacyResult);\n  }\n\n  private adaptResult(legacy: any): OrderResult {\n    return {\n      orderId: legacy.orderId,\n      total: legacy.total,\n      status: 'completed',\n    };\n  }\n}\n\n// =============================================================================\n// Type Definitions\n// =============================================================================\n\ninterface Order {\n  customer: Customer;\n  items: OrderItem[];\n}\n\ninterface Customer {\n  id: string;\n  email: string;\n  type: 'retail' | 'wholesale';\n}\n\ninterface OrderItem {\n  productId: string;\n  price: number;\n  quantity: number;\n  weight?: number;\n}\n\ninterface OrderResult {\n  orderId: string;\n  total: number;\n  status: string;\n  paymentId?: string;\n  trackingNumber?: string;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\ninterface PaymentResult {\n  transactionId: string;\n}\n\ninterface ShippingResult {\n  trackingNumber: string;\n}\n\nclass ValidationError extends Error {\n  constructor(public errors: string[]) {\n    super(errors.join(', '));\n    this.name = 'ValidationError';\n  }\n}\n\n// Service interfaces\ninterface InventoryService {\n  reserve(items: OrderItem[]): Promise<string>;\n  release(reservationId: string): Promise<void>;\n}\n\ninterface PaymentService {\n  charge(customer: Customer, amount: number): Promise<PaymentResult>;\n}\n\ninterface ShippingService {\n  schedule(order: Order): Promise<ShippingResult>;\n}\n\ninterface NotificationService {\n  sendConfirmation(customer: Customer, order: OrderResult): Promise<void>;\n}\n\ninterface AuditService {\n  log(event: string, data: any): Promise<void>;\n}\n\ninterface FeatureFlags {\n  isEnabled(flag: string, context?: any): boolean;\n}\n\ninterface ComparisonLogger {\n  logComparison(data: any): void;\n  logError(data: any): void;\n}\n\ndeclare function generateOrderId(): string;\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "refactoring-surgeon/scripts",
      "children": [
        {
          "name": "validate-refactoring.sh",
          "type": "file",
          "path": "refactoring-surgeon/scripts/validate-refactoring.sh",
          "size": 8360,
          "content": "#!/bin/bash\n# Refactoring Surgeon Skill Validation Script\n# Validates code for refactoring readiness and quality\n\nset -e\n\nERRORS=0\nWARNINGS=0\n\necho \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\necho \"Refactoring Surgeon Validator\"\necho \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\necho \"\"\n\n# Check for test coverage before refactoring\ncheck_test_coverage() {\n    echo \"ğŸ§ª Checking test coverage...\"\n\n    # Look for test files\n    test_count=0\n    for pattern in \"*.test.ts\" \"*.test.js\" \"*.spec.ts\" \"*.spec.js\" \"__tests__/*.ts\" \"__tests__/*.js\"; do\n        count=$(find . -name \"$pattern\" 2>/dev/null | wc -l)\n        test_count=$((test_count + count))\n    done\n\n    if [ \"$test_count\" -eq 0 ]; then\n        echo \"âŒ ERROR: No test files found - refactoring without tests is risky!\"\n        ((ERRORS++))\n    else\n        echo \"  Found $test_count test files\"\n    fi\n\n    # Check for test runner config\n    if [ -f \"jest.config.js\" ] || [ -f \"jest.config.ts\" ] || [ -f \"vitest.config.ts\" ]; then\n        echo \"  âœ… Test runner configured\"\n    elif grep -q '\"test\"' package.json 2>/dev/null; then\n        echo \"  âœ… Test script found in package.json\"\n    else\n        echo \"âš ï¸  WARN: No test runner configuration found\"\n        ((WARNINGS++))\n    fi\n}\n\n# Check for code smells\ncheck_code_smells() {\n    echo \"\"\n    echo \"ğŸ‘ƒ Checking for code smells...\"\n\n    # Long files (potential god classes)\n    echo \"  Checking for long files...\"\n    long_files=$(find . -name \"*.ts\" -o -name \"*.js\" 2>/dev/null | while read -r file; do\n        lines=$(wc -l < \"$file\" 2>/dev/null || echo 0)\n        if [ \"$lines\" -gt 300 ]; then\n            echo \"$file ($lines lines)\"\n        fi\n    done)\n\n    if [ -n \"$long_files\" ]; then\n        echo \"âš ï¸  WARN: Files over 300 lines (potential god classes):\"\n        echo \"$long_files\" | sed 's/^/    /'\n        ((WARNINGS++))\n    fi\n\n    # Long functions (check for function declarations with many lines)\n    echo \"  Checking for long functions...\"\n    # This is a simple heuristic - real analysis would need AST parsing\n\n    # Check for switch statements (potential polymorphism candidates)\n    switch_count=$(grep -r \"switch\\s*(\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | wc -l)\n    if [ \"$switch_count\" -gt 5 ]; then\n        echo \"âš ï¸  WARN: Found $switch_count switch statements - consider Replace Conditional with Polymorphism\"\n        ((WARNINGS++))\n    fi\n\n    # Check for long parameter lists\n    long_params=$(grep -rE \"function\\s+\\w+\\s*\\([^)]{100,}\\)\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | wc -l)\n    if [ \"$long_params\" -gt 0 ]; then\n        echo \"âš ï¸  WARN: Found $long_params functions with long parameter lists - consider Introduce Parameter Object\"\n        ((WARNINGS++))\n    fi\n}\n\n# Check for duplication\ncheck_duplication() {\n    echo \"\"\n    echo \"ğŸ“‹ Checking for code duplication...\"\n\n    # Simple check for identical consecutive lines (very basic)\n    dup_count=0\n    for file in $(find . -name \"*.ts\" -o -name \"*.js\" 2>/dev/null | head -20); do\n        # Check for blocks that repeat\n        if [ -f \"$file\" ]; then\n            repeats=$(sort \"$file\" | uniq -d | wc -l)\n            if [ \"$repeats\" -gt 10 ]; then\n                ((dup_count++))\n            fi\n        fi\n    done\n\n    if [ \"$dup_count\" -gt 0 ]; then\n        echo \"âš ï¸  WARN: $dup_count files may have duplicated code\"\n        ((WARNINGS++))\n    else\n        echo \"  No obvious duplication detected\"\n    fi\n\n    # Check for copy-paste comments\n    if grep -rE \"(copy|paste|duplicate|TODO.*refactor)\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | grep -v node_modules | head -5 | grep -q .; then\n        echo \"âš ï¸  WARN: Found comments mentioning copy/paste or refactoring TODOs\"\n        ((WARNINGS++))\n    fi\n}\n\n# Check for complexity indicators\ncheck_complexity() {\n    echo \"\"\n    echo \"ğŸ”„ Checking complexity indicators...\"\n\n    # Nested callbacks (callback hell)\n    nested=$(grep -rE \"\\)\\s*=>\\s*\\{\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | wc -l)\n    if [ \"$nested\" -gt 50 ]; then\n        echo \"âš ï¸  WARN: High arrow function usage ($nested) - check for callback nesting\"\n        ((WARNINGS++))\n    fi\n\n    # Deep nesting (multiple levels of indentation)\n    deep_nesting=$(grep -rE \"^\\s{16,}\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | wc -l)\n    if [ \"$deep_nesting\" -gt 20 ]; then\n        echo \"âš ï¸  WARN: Found $deep_nesting deeply nested lines (4+ levels) - consider Extract Method\"\n        ((WARNINGS++))\n    fi\n\n    # Multiple return statements\n    multi_return=$(grep -rE \"return\\s\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | wc -l)\n    echo \"  Found $multi_return return statements across codebase\"\n}\n\n# Check SOLID principles violations\ncheck_solid_violations() {\n    echo \"\"\n    echo \"ğŸ“ Checking for SOLID violations...\"\n\n    # Single Responsibility: files doing too many things\n    # Check for files with many different imports (heuristic)\n\n    # Open/Closed: check for type checking\n    type_checks=$(grep -rE \"typeof|instanceof\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | wc -l)\n    if [ \"$type_checks\" -gt 20 ]; then\n        echo \"âš ï¸  WARN: $type_checks type checks found - may violate Open/Closed Principle\"\n        ((WARNINGS++))\n    fi\n\n    # Dependency Inversion: check for direct instantiation\n    new_calls=$(grep -rE \"new\\s+[A-Z]\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | grep -v \"Error\\|Date\\|Map\\|Set\\|Promise\\|Array\" | wc -l)\n    if [ \"$new_calls\" -gt 30 ]; then\n        echo \"âš ï¸  WARN: $new_calls direct instantiations - consider dependency injection\"\n        ((WARNINGS++))\n    fi\n}\n\n# Check refactoring safety\ncheck_refactoring_safety() {\n    echo \"\"\n    echo \"ğŸ”’ Checking refactoring safety...\"\n\n    # Check for version control\n    if [ -d \".git\" ]; then\n        echo \"  âœ… Git repository found\"\n\n        # Check for uncommitted changes\n        if git diff --quiet 2>/dev/null && git diff --staged --quiet 2>/dev/null; then\n            echo \"  âœ… No uncommitted changes\"\n        else\n            echo \"âš ï¸  WARN: Uncommitted changes - commit before refactoring!\"\n            ((WARNINGS++))\n        fi\n    else\n        echo \"âŒ ERROR: No git repository - can't safely refactor without version control\"\n        ((ERRORS++))\n    fi\n\n    # Check for CI/CD\n    if [ -f \".github/workflows/ci.yml\" ] || [ -f \".github/workflows/test.yml\" ] || [ -f \".gitlab-ci.yml\" ]; then\n        echo \"  âœ… CI/CD configuration found\"\n    else\n        echo \"âš ï¸  WARN: No CI/CD found - tests may not run automatically\"\n        ((WARNINGS++))\n    fi\n}\n\n# Check for magic numbers and strings\ncheck_magic_values() {\n    echo \"\"\n    echo \"ğŸ”¢ Checking for magic numbers and strings...\"\n\n    # Magic numbers (excluding common ones like 0, 1, 2)\n    magic_nums=$(grep -rE \"[^0-9][3-9][0-9]{2,}[^0-9]\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | grep -v \"node_modules\\|\\.d\\.ts\" | wc -l)\n    if [ \"$magic_nums\" -gt 10 ]; then\n        echo \"âš ï¸  WARN: Found $magic_nums potential magic numbers - consider named constants\"\n        ((WARNINGS++))\n    fi\n}\n\n# Run all checks\ncheck_test_coverage\ncheck_code_smells\ncheck_duplication\ncheck_complexity\ncheck_solid_violations\ncheck_refactoring_safety\ncheck_magic_values\n\n# Summary\necho \"\"\necho \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\necho \"Validation Complete\"\necho \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\necho \"Errors:   $ERRORS\"\necho \"Warnings: $WARNINGS\"\necho \"\"\n\nif [ $ERRORS -gt 0 ]; then\n    echo \"âŒ Validation FAILED - address errors before refactoring\"\n    exit 1\nelif [ $WARNINGS -gt 5 ]; then\n    echo \"âš ï¸  Validation PASSED with warnings - many refactoring opportunities!\"\n    exit 0\nelse\n    echo \"âœ… Validation PASSED - code is in good shape\"\n    exit 0\nfi\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "refactoring-surgeon/CHANGELOG.md",
      "size": 1334,
      "content": "# Changelog\n\nAll notable changes to the refactoring-surgeon skill will be documented in this file.\n\n## [2.0.0] - 2024-12-13\n\n### Changed\n- **BREAKING**: Restructured SKILL.md from 655 lines to ~170 lines for progressive disclosure\n- Moved all large code examples to `./references/` directory\n- Expanded anti-patterns section from 5 to 10 patterns\n\n### Added\n- `references/extract-method.ts` - Complete Extract Method example with before/after\n- `references/replace-conditional-polymorphism.ts` - Polymorphism refactoring with Factory pattern\n- `references/introduce-parameter-object.ts` - Parameter Object pattern with Builder variant\n- `references/strangler-fig-pattern.ts` - Legacy code migration strategy with parallel run\n- `scripts/validate-refactoring.sh` - Pre-refactoring validation script\n- Version field in frontmatter for skill tracking\n\n### Improved\n- Anti-patterns section now covers 10 common refactoring mistakes\n- Safety checklist expanded with before/during/after phases\n- Better cross-references to code smell diagrams\n\n## [1.0.0] - 2024-01-01\n\n### Added\n- Initial refactoring-surgeon skill\n- Code smell detection guidance (Bloaters, OO Abusers, Change Preventers)\n- Extract Method, Replace Conditional, Introduce Parameter Object examples\n- Strangler Fig pattern for legacy migration\n- Refactoring safety checklist\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "refactoring-surgeon/SKILL.md",
      "size": 7026,
      "content": "---\nname: refactoring-surgeon\nversion: 2.0.0\ndescription: \"Expert code refactoring specialist for improving code quality without changing behavior. Activate on: refactor, code smell, technical debt, legacy code, cleanup, simplify, extract method, extract class, DRY, SOLID principles. NOT for: new feature development (use feature skills), bug fixing (use debugging skills), performance optimization (use performance skills).\"\nallowed-tools: Read,Write,Edit,Bash(npm test:*,npm run lint:*,git:*)\n---\n\n# Refactoring Surgeon\n\nExpert code refactoring specialist focused on improving code quality without changing behavior.\n\n## Quick Start\n\n1. **Ensure tests exist** - Never refactor without a safety net\n2. **Identify the smell** - Name the specific code smell you're addressing\n3. **Make small changes** - One refactoring at a time, commit frequently\n4. **Run tests after each change** - Behavior must remain identical\n5. **Don't add features** - Refactoring â‰  enhancement\n6. **Document significant changes** - Explain the \"why\" for future maintainers\n\n## Core Capabilities\n\n| Category | Techniques |\n|----------|------------|\n| **Extraction** | Extract Method, Extract Class, Extract Interface |\n| **Movement** | Move Method, Move Field, Inline Method |\n| **Simplification** | Replace Conditional with Polymorphism, Decompose Conditional |\n| **Organization** | Introduce Parameter Object, Replace Magic Numbers |\n| **Legacy Migration** | Strangler Fig, Branch by Abstraction, Parallel Change |\n\n## Code Smells Reference\n\n### Bloaters\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚    Long Method      â”‚    â”‚    Large Class      â”‚    â”‚   Long Parameter    â”‚\nâ”‚  > 20 lines?        â”‚    â”‚  > 200 lines?       â”‚    â”‚       List          â”‚\nâ”‚  â†’ Extract Method   â”‚    â”‚  â†’ Extract Class    â”‚    â”‚  â†’ Parameter Object â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### OO Abusers\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Switch Statements  â”‚    â”‚   Refused Bequest   â”‚    â”‚   Parallel          â”‚\nâ”‚  Type-checking?     â”‚    â”‚  Unused inheritance?â”‚    â”‚   Hierarchies       â”‚\nâ”‚  â†’ Polymorphism     â”‚    â”‚  â†’ Delegation       â”‚    â”‚  â†’ Move Method      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Change Preventers\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Divergent Change   â”‚    â”‚  Shotgun Surgery    â”‚\nâ”‚  One class, many    â”‚    â”‚  One change, many   â”‚\nâ”‚  reasons to change? â”‚    â”‚  classes affected?  â”‚\nâ”‚  â†’ Extract Class    â”‚    â”‚  â†’ Move/Inline      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Reference Examples\n\nComplete refactoring examples in `./references/`:\n\n| File | Pattern | Use Case |\n|------|---------|----------|\n| `extract-method.ts` | Extract Method | Long methods â†’ focused functions |\n| `replace-conditional-polymorphism.ts` | Replace Conditional | switch/if â†’ polymorphic classes |\n| `introduce-parameter-object.ts` | Parameter Object | Long params â†’ structured objects |\n| `strangler-fig-pattern.ts` | Strangler Fig | Legacy code â†’ gradual migration |\n\n## Anti-Patterns (10 Critical Mistakes)\n\n### 1. Big Bang Refactoring\n**Symptom**: Rewriting entire modules in one massive change\n**Fix**: Strangler fig pattern, small incremental changes with tests\n\n### 2. Refactoring Without Tests\n**Symptom**: Changing structure without test coverage\n**Fix**: Write characterization tests first, add coverage for affected areas\n\n### 3. Premature Abstraction\n**Symptom**: Creating generic frameworks \"for future flexibility\"\n**Fix**: Wait for three concrete examples before abstracting (Rule of Three)\n\n### 4. Renaming Without IDE Support\n**Symptom**: Find-and-replace that misses occurrences\n**Fix**: Use IDE refactoring tools, search for usages first\n\n### 5. Mixing Refactoring and Features\n**Symptom**: Adding new functionality while restructuring\n**Fix**: Separate commits - refactor first, then add features\n\n### 6. Ignoring Code Reviews\n**Symptom**: Large refactoring PRs that are hard to review\n**Fix**: Small, focused PRs with clear commit messages\n\n### 7. Over-Abstracting\n**Symptom**: Three layers of abstraction for a simple operation\n**Fix**: YAGNI - start concrete, abstract when patterns emerge\n\n### 8. Incomplete Refactoring\n**Symptom**: Starting Extract Method but leaving partial duplication\n**Fix**: Complete the refactoring or revert - no half-measures\n\n### 9. Refactoring Production During Incidents\n**Symptom**: \"I'll just clean this up while I'm here...\"\n**Fix**: Never refactor during incidents - fix the bug, create a ticket\n\n### 10. Not Measuring Improvement\n**Symptom**: Refactoring without knowing if it helped\n**Fix**: Track metrics: complexity, test coverage, build time\n\n## Safety Checklist\n\n**Before Refactoring:**\n- [ ] Code compiles/runs successfully\n- [ ] All tests pass\n- [ ] Test coverage is adequate for area being refactored\n- [ ] Commit current state (can rollback)\n\n**During Refactoring:**\n- [ ] Make small, incremental changes\n- [ ] Run tests after each change\n- [ ] Keep behavior identical\n- [ ] Don't add features while refactoring\n\n**After Refactoring:**\n- [ ] All tests still pass\n- [ ] No new warnings/errors\n- [ ] Code is more readable\n- [ ] Complexity metrics improved\n- [ ] Document significant changes\n\n## Quality Checklist\n\n- [ ] No behavior changes (tests prove this)\n- [ ] Improved readability\n- [ ] Reduced complexity (cyclomatic, cognitive)\n- [ ] Better adherence to SOLID principles\n- [ ] Removed duplication (DRY)\n- [ ] More testable code\n- [ ] Clear naming\n- [ ] Appropriate abstractions (not over-engineered)\n\n## Validation Script\n\nRun `./scripts/validate-refactoring.sh` to check:\n- Test coverage presence\n- Code smell indicators\n- Duplication patterns\n- Complexity metrics\n- SOLID violations\n- Refactoring safety (git, uncommitted changes)\n\n## External Resources\n\n- [Refactoring.Guru](https://refactoring.guru/)\n- [Martin Fowler's Refactoring Catalog](https://refactoring.com/catalog/)\n- [Working Effectively with Legacy Code](https://www.oreilly.com/library/view/working-effectively-with/0131177052/)\n"
    }
  ]
}