{
  "name": "voice-audio-engineer",
  "type": "folder",
  "path": "voice-audio-engineer",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "voice-audio-engineer/references",
      "children": [
        {
          "name": "implementations.md",
          "type": "file",
          "path": "voice-audio-engineer/references/implementations.md",
          "size": 12810,
          "content": "# Voice Audio Implementation Reference\n\nDetailed code implementations for voice processing, loudness measurement, and speech analysis.\n\n## Biquad Filter (Audio EQ Cookbook)\n\n```python\nimport numpy as np\nfrom scipy import signal\n\nclass AudioFilters:\n    \"\"\"Production-ready filter implementations.\"\"\"\n\n    @staticmethod\n    def biquad_coefficients(filter_type: str, fc: float, fs: float,\n                           Q: float = 0.707, gain_db: float = 0) -> tuple:\n        \"\"\"\n        Calculate biquad filter coefficients.\n        Uses Audio EQ Cookbook formulas (Robert Bristow-Johnson)\n        \"\"\"\n        A = 10 ** (gain_db / 40)\n        w0 = 2 * np.pi * fc / fs\n        cos_w0 = np.cos(w0)\n        sin_w0 = np.sin(w0)\n        alpha = sin_w0 / (2 * Q)\n\n        if filter_type == 'lowpass':\n            b0 = (1 - cos_w0) / 2\n            b1 = 1 - cos_w0\n            b2 = (1 - cos_w0) / 2\n            a0 = 1 + alpha\n            a1 = -2 * cos_w0\n            a2 = 1 - alpha\n\n        elif filter_type == 'highpass':\n            b0 = (1 + cos_w0) / 2\n            b1 = -(1 + cos_w0)\n            b2 = (1 + cos_w0) / 2\n            a0 = 1 + alpha\n            a1 = -2 * cos_w0\n            a2 = 1 - alpha\n\n        elif filter_type == 'peaking':\n            b0 = 1 + alpha * A\n            b1 = -2 * cos_w0\n            b2 = 1 - alpha * A\n            a0 = 1 + alpha / A\n            a1 = -2 * cos_w0\n            a2 = 1 - alpha / A\n\n        elif filter_type == 'highshelf':\n            b0 = A * ((A + 1) + (A - 1) * cos_w0 + 2 * np.sqrt(A) * alpha)\n            b1 = -2 * A * ((A - 1) + (A + 1) * cos_w0)\n            b2 = A * ((A + 1) + (A - 1) * cos_w0 - 2 * np.sqrt(A) * alpha)\n            a0 = (A + 1) - (A - 1) * cos_w0 + 2 * np.sqrt(A) * alpha\n            a1 = 2 * ((A - 1) - (A + 1) * cos_w0)\n            a2 = (A + 1) - (A - 1) * cos_w0 - 2 * np.sqrt(A) * alpha\n\n        # Normalize\n        b = np.array([b0/a0, b1/a0, b2/a0])\n        a = np.array([1, a1/a0, a2/a0])\n        return b, a\n```\n\n## LUFS Loudness Measurement\n\n```python\nimport numpy as np\nfrom scipy import signal\n\ndef measure_lufs(audio: np.ndarray, fs: int) -> float:\n    \"\"\"\n    Measure integrated loudness per ITU-R BS.1770-4.\n    \"\"\"\n    # Stage 1: K-weighting filter\n    b1, a1 = signal.butter(2, 1500 / (fs/2), btype='high')\n    b2, a2 = signal.butter(2, 38 / (fs/2), btype='high')\n\n    filtered = signal.lfilter(b1, a1, audio)\n    filtered = signal.lfilter(b2, a2, filtered)\n\n    # Stage 2: Mean square with gating\n    block_size = int(0.4 * fs)  # 400ms blocks\n    hop_size = int(0.1 * fs)    # 100ms overlap\n\n    block_loudness = []\n    for i in range(0, len(filtered) - block_size, hop_size):\n        block = filtered[i:i+block_size]\n        mean_square = np.mean(block ** 2)\n        block_loudness.append(-0.691 + 10 * np.log10(mean_square + 1e-10))\n\n    # Absolute threshold gate (-70 LUFS)\n    gated = [l for l in block_loudness if l > -70]\n    if not gated:\n        return -70.0\n\n    # Relative threshold gate (-10 LU below ungated mean)\n    ungated_mean = np.mean(gated)\n    relative_threshold = ungated_mean - 10\n    final_gated = [l for l in gated if l > relative_threshold]\n\n    return np.mean(final_gated) if final_gated else ungated_mean\n```\n\n## Compressor Implementation\n\n```python\nimport numpy as np\n\nclass Compressor:\n    \"\"\"Production-quality dynamics compressor.\"\"\"\n\n    def __init__(self, fs: int):\n        self.fs = fs\n        self.envelope = 0.0\n\n    def process(self, audio: np.ndarray,\n                threshold_db: float = -20,\n                ratio: float = 4.0,\n                attack_ms: float = 10,\n                release_ms: float = 100,\n                knee_db: float = 6,\n                makeup_db: float = 0) -> np.ndarray:\n        \"\"\"Apply compression to audio signal.\"\"\"\n        attack_coef = np.exp(-1 / (self.fs * attack_ms / 1000))\n        release_coef = np.exp(-1 / (self.fs * release_ms / 1000))\n\n        output = np.zeros_like(audio)\n\n        for i in range(len(audio)):\n            input_level = 20 * np.log10(abs(audio[i]) + 1e-10)\n\n            # Envelope follower\n            if input_level > self.envelope:\n                self.envelope = attack_coef * self.envelope + (1 - attack_coef) * input_level\n            else:\n                self.envelope = release_coef * self.envelope + (1 - release_coef) * input_level\n\n            # Gain computer with soft knee\n            over_threshold = self.envelope - threshold_db\n\n            if knee_db > 0 and over_threshold > -knee_db/2 and over_threshold < knee_db/2:\n                knee_factor = (over_threshold + knee_db/2) ** 2 / (2 * knee_db)\n                gain_db = -knee_factor * (1 - 1/ratio)\n            elif over_threshold >= knee_db/2:\n                gain_db = -(over_threshold - knee_db/2) * (1 - 1/ratio) - (knee_db/2) * (1 - 1/ratio)\n            else:\n                gain_db = 0\n\n            gain_linear = 10 ** ((gain_db + makeup_db) / 20)\n            output[i] = audio[i] * gain_linear\n\n        return output\n```\n\n## De-esser Implementation\n\n```python\nimport numpy as np\nfrom scipy import signal\n\nclass DeEsser:\n    \"\"\"Frequency-selective de-esser for sibilance control.\"\"\"\n\n    def __init__(self, fs: int):\n        self.fs = fs\n\n    def process(self, audio: np.ndarray,\n                frequency: float = 6000,\n                threshold_db: float = -20,\n                reduction_db: float = 6,\n                q: float = 2.0) -> np.ndarray:\n        \"\"\"\n        Reduce sibilance in voice recordings.\n\n        Args:\n            frequency: Center frequency for sibilance detection (5-8kHz typical)\n            threshold_db: Level above which de-essing activates\n            reduction_db: Maximum gain reduction\n            q: Bandwidth (higher = narrower)\n        \"\"\"\n        # Create bandpass to detect sibilance\n        nyq = self.fs / 2\n        low = (frequency - frequency/q) / nyq\n        high = (frequency + frequency/q) / nyq\n        b, a = signal.butter(2, [low, high], btype='band')\n\n        # Detect sibilance envelope\n        sibilance = signal.lfilter(b, a, audio)\n        envelope = np.abs(sibilance)\n\n        # Smooth envelope\n        smooth_coef = 0.99\n        smoothed = np.zeros_like(envelope)\n        smoothed[0] = envelope[0]\n        for i in range(1, len(envelope)):\n            smoothed[i] = smooth_coef * smoothed[i-1] + (1 - smooth_coef) * envelope[i]\n\n        # Calculate gain reduction\n        threshold_linear = 10 ** (threshold_db / 20)\n        reduction_linear = 10 ** (-reduction_db / 20)\n\n        output = audio.copy()\n        for i in range(len(audio)):\n            if smoothed[i] > threshold_linear:\n                gain = 1.0 - (1.0 - reduction_linear) * (smoothed[i] - threshold_linear) / smoothed[i]\n                output[i] *= gain\n\n        return output\n```\n\n## Voice Activity Detection (VAD)\n\n```python\nimport numpy as np\n\nclass VoiceActivityDetector:\n    \"\"\"Simple energy-based VAD for voice detection.\"\"\"\n\n    def __init__(self, fs: int, frame_ms: float = 20):\n        self.fs = fs\n        self.frame_size = int(fs * frame_ms / 1000)\n\n    def detect(self, audio: np.ndarray,\n               energy_threshold_db: float = -40,\n               min_speech_ms: float = 100) -> list[tuple[int, int]]:\n        \"\"\"\n        Detect speech segments in audio.\n\n        Returns: List of (start_sample, end_sample) tuples\n        \"\"\"\n        num_frames = len(audio) // self.frame_size\n        is_speech = np.zeros(num_frames, dtype=bool)\n\n        for i in range(num_frames):\n            frame = audio[i * self.frame_size:(i + 1) * self.frame_size]\n            energy_db = 20 * np.log10(np.sqrt(np.mean(frame ** 2)) + 1e-10)\n            is_speech[i] = energy_db > energy_threshold_db\n\n        # Merge short gaps, remove short segments\n        min_frames = int(min_speech_ms / (self.frame_size / self.fs * 1000))\n\n        # Simple hangover\n        for i in range(1, len(is_speech) - 1):\n            if is_speech[i-1] and is_speech[i+1]:\n                is_speech[i] = True\n\n        # Extract segments\n        segments = []\n        in_segment = False\n        start = 0\n\n        for i, speech in enumerate(is_speech):\n            if speech and not in_segment:\n                start = i * self.frame_size\n                in_segment = True\n            elif not speech and in_segment:\n                end = i * self.frame_size\n                if (end - start) / self.fs * 1000 >= min_speech_ms:\n                    segments.append((start, end))\n                in_segment = False\n\n        if in_segment:\n            segments.append((start, len(audio)))\n\n        return segments\n```\n\n## Audio Analysis Report Generator\n\n```python\nimport numpy as np\nfrom scipy.fft import rfft, rfftfreq\n\ndef analyze_voice_audio(audio: np.ndarray, fs: int) -> dict:\n    \"\"\"Comprehensive voice audio analysis.\"\"\"\n\n    # Mono for analysis\n    if len(audio.shape) > 1:\n        mono = np.mean(audio, axis=1)\n    else:\n        mono = audio\n\n    # Level measurements\n    peak_db = 20 * np.log10(np.max(np.abs(mono)) + 1e-10)\n    rms_db = 20 * np.log10(np.sqrt(np.mean(mono**2)) + 1e-10)\n    crest_factor = peak_db - rms_db\n    lufs = measure_lufs(mono, fs)\n    dc_offset = np.mean(mono)\n\n    # Spectral analysis\n    spectrum = np.abs(rfft(mono))\n    freqs = rfftfreq(len(mono), 1/fs)\n    spectral_centroid = np.sum(freqs * spectrum) / np.sum(spectrum)\n\n    # Voice-specific metrics\n    # Fundamental frequency estimation (simple autocorrelation)\n    autocorr = np.correlate(mono[:4096], mono[:4096], mode='full')\n    autocorr = autocorr[len(autocorr)//2:]\n    # Find first peak after initial decay\n    min_lag = int(fs / 500)  # 500Hz max\n    max_lag = int(fs / 50)   # 50Hz min\n    peak_lag = np.argmax(autocorr[min_lag:max_lag]) + min_lag\n    f0_estimate = fs / peak_lag if peak_lag > 0 else 0\n\n    return {\n        'peak_db': peak_db,\n        'rms_db': rms_db,\n        'crest_factor': crest_factor,\n        'lufs': lufs,\n        'dc_offset': dc_offset,\n        'spectral_centroid': spectral_centroid,\n        'f0_estimate': f0_estimate,\n        'duration_seconds': len(mono) / fs,\n        'sample_rate': fs\n    }\n\ndef generate_recommendations(analysis: dict) -> list[str]:\n    \"\"\"Generate processing recommendations from analysis.\"\"\"\n    recs = []\n\n    if analysis['peak_db'] > -0.5:\n        recs.append(\"Peaks near 0dBFS - risk of clipping; add limiter\")\n    if analysis['lufs'] > -14:\n        recs.append(\"Too loud for streaming (-14 LUFS target)\")\n    if analysis['lufs'] < -20:\n        recs.append(\"Consider increasing overall level\")\n    if analysis['crest_factor'] < 6:\n        recs.append(\"Low crest factor - may sound over-compressed\")\n    if abs(analysis['dc_offset']) > 0.01:\n        recs.append(\"DC offset detected - apply high-pass filter at 80Hz\")\n    if analysis['spectral_centroid'] < 1500:\n        recs.append(\"Voice sounds muddy - consider high shelf boost at 3kHz\")\n    if analysis['spectral_centroid'] > 4000:\n        recs.append(\"Voice sounds harsh - consider reducing 2-4kHz\")\n\n    return recs if recs else [\"Audio looks good!\"]\n```\n\n## Loudness Standards Reference\n\n```\nLOUDNESS UNITS (ITU-R BS.1770)\n\nLUFS (Loudness Units Full Scale)\n├── Integrated: Average loudness over entire program\n├── Short-term: 3-second sliding window\n├── Momentary: 400ms sliding window\n└── True Peak: Maximum sample value with intersample peaks\n\nDELIVERY STANDARDS\n├── Streaming (Spotify, Apple): -14 LUFS, -1 dBTP\n├── Broadcast (EBU R128): -23 LUFS ±1, -1 dBTP\n├── Broadcast (ATSC A/85): -24 LKFS ±2, -2 dBTP\n├── Podcast: -16 to -19 LUFS (dialogue norm)\n├── YouTube: -14 LUFS (normalized)\n└── Audiobook (ACX): -18 to -23 dBFS RMS, -3 dBFS peak\n\nLOUDNESS RANGE (LRA)\n├── Classical: 15-20 LU\n├── Film: 10-15 LU\n├── Pop music: 5-8 LU\n└── Broadcast speech: 3-6 LU\n```\n\n## Digital Audio Theory Reference\n\n```\nSAMPLE RATES\n├── 44.1kHz: CD standard, captures up to 22.05kHz\n├── 48kHz: Video standard (cleaner for frame sync)\n├── 96kHz: High-resolution, better for processing headroom\n└── Why 44.1kHz? Derived from video: 44100 = 3×3×5×5×7×7×2\n\nBIT DEPTH → DYNAMIC RANGE\n├── Dynamic Range (dB) ≈ 6.02 × bits + 1.76\n├── 16-bit: ~96 dB (CD quality)\n├── 24-bit: ~144 dB (professional)\n└── 32-bit float: ~1528 dB (effectively infinite)\n\nDITHERING\n├── Required when reducing bit depth (24→16)\n├── TPDF (triangular): Standard, mathematically optimal\n└── Shaped: Noise pushed above hearing range\n```\n\n## Key References\n\n- ITU-R BS.1770: \"Algorithms to measure audio programme loudness\"\n- EBU R128: \"Loudness normalisation and permitted maximum level\"\n- AES-6id: \"Personal Sound Exposure\"\n- Bristow-Johnson, R.: \"Audio EQ Cookbook\" (filter formulas)\n- Blauert, J. (1997): *Spatial Hearing* (MIT Press)\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "voice-audio-engineer/SKILL.md",
      "size": 12476,
      "content": "---\nname: voice-audio-engineer\ndescription: \"Expert in voice synthesis, TTS, voice cloning, podcast production, speech processing, and voice UI design via ElevenLabs integration. Specializes in vocal clarity, loudness standards (LUFS), de-essing, dialogue mixing, and voice transformation. Activate on 'TTS', 'text-to-speech', 'voice clone', 'voice synthesis', 'ElevenLabs', 'podcast', 'voice recording', 'speech-to-speech', 'voice UI', 'audiobook', 'dialogue'. NOT for spatial audio (use sound-engineer), music production (use DAW tools), game audio middleware (use sound-engineer), sound effects generation (use sound-engineer with ElevenLabs SFX), or live concert audio.\"\nallowed-tools: Read,Write,Edit,Bash,mcp__firecrawl__firecrawl_search,WebFetch,mcp__ElevenLabs__text_to_speech,mcp__ElevenLabs__speech_to_speech,mcp__ElevenLabs__voice_clone,mcp__ElevenLabs__search_voices,mcp__ElevenLabs__speech_to_text,mcp__ElevenLabs__isolate_audio,mcp__ElevenLabs__create_agent\n---\n\n# Voice & Audio Engineer: Voice Synthesis, TTS & Speech Processing\n\nExpert in voice synthesis, speech processing, and vocal production using ElevenLabs and professional audio techniques. Specializes in TTS, voice cloning, podcast production, and voice UI design.\n\n## When to Use This Skill\n\n✅ **Use for:**\n- Text-to-speech (TTS) generation\n- Voice cloning and voice design\n- Speech-to-speech voice transformation\n- Podcast production and editing\n- Audiobook production\n- Voice UI/conversational AI audio\n- Dialogue mixing and processing\n- Loudness normalization (LUFS)\n- Voice quality enhancement (de-essing, compression)\n- Transcription and speech-to-text\n\n❌ **Do NOT use for:**\n- Spatial audio (HRTF, Ambisonics) → **sound-engineer**\n- Sound effects generation → **sound-engineer** (ElevenLabs SFX)\n- Game audio middleware (Wwise, FMOD) → **sound-engineer**\n- Music composition/production → DAW tools\n- Live concert/event audio → specialized domain\n\n## MCP Integrations\n\n| MCP Tool | Purpose |\n|----------|---------|\n| `text_to_speech` | Generate speech from text with voice selection |\n| `speech_to_speech` | Transform voice recordings to different voices |\n| `voice_clone` | Create instant voice clones from audio samples |\n| `search_voices` | Find voices in ElevenLabs library |\n| `speech_to_text` | Transcribe audio with speaker diarization |\n| `isolate_audio` | Separate voice from background noise |\n| `create_agent` | Build conversational AI agents with voice |\n\n## Expert vs Novice Shibboleths\n\n| Topic | Novice | Expert |\n|-------|--------|--------|\n| **TTS quality** | \"Any voice works\" | Matches voice to brand; considers emotion, pace, style |\n| **Voice cloning** | \"Upload any audio\" | Knows 30s-3min of clean, varied speech needed; single speaker |\n| **Loudness** | \"Make it loud\" | Targets -16 to -19 LUFS for podcasts; -14 for streaming |\n| **De-essing** | \"Doesn't matter\" | Knows sibilance lives at 5-8kHz; frequency-selective compression |\n| **Compression** | \"Squash it\" | Uses 3:1-4:1 for dialogue; slow attack (10-20ms) to preserve transients |\n| **High-pass** | \"Never use it\" | Always HPF at 80-100Hz for voice; removes rumble, plosives |\n| **True peak** | \"Peak is peak\" | Knows intersample peaks exceed 0dBFS; targets -1 dBTP |\n| **ElevenLabs models** | \"Use default\" | `eleven_multilingual_v2` for quality; `eleven_flash_v2_5` for speed |\n\n## Common Anti-Patterns\n\n### Anti-Pattern: Uploading Noisy Audio for Voice Cloning\n**What it looks like**: Voice clone from phone recording with background noise, echo\n**Why it's wrong**: Clone learns the noise; output has artifacts\n**What to do instead**: Use `isolate_audio` first; record in quiet space; provide 1-3 min of varied speech\n\n### Anti-Pattern: Ignoring Loudness Standards\n**What it looks like**: Podcast at -6 LUFS, then normalized by platform → crushed dynamics\n**Why it's wrong**: Each platform normalizes differently; too loud = distortion, too quiet = inaudible\n**What to do instead**: Master to -16 LUFS for podcasts; -14 LUFS for streaming; always check true peak < -1 dBTP\n\n### Anti-Pattern: TTS Without Voice Matching\n**What it looks like**: Using default robotic voice for premium product\n**Why it's wrong**: Voice IS brand; wrong voice = wrong emotional connection\n**What to do instead**: `search_voices` to find matching tone; consider custom clone for brand consistency\n\n### Anti-Pattern: No De-essing on Processed Voice\n**What it looks like**: \"SSSSibilant\" speech after compression and EQ boost\n**Why it's wrong**: Compression brings up sibilance; EQ boost at 3-5kHz makes it worse\n**What to do instead**: De-ess at 5-8kHz before compression; use frequency-selective compression\n\n### Anti-Pattern: Single Take, No Editing\n**What it looks like**: Podcast with 20 \"ums\", breath sounds, long pauses\n**Why it's wrong**: Listeners fatigue; unprofessional; reduces engagement\n**What to do instead**: Edit out filler words; gate or manually cut breaths; tighten pacing\n\n## Evolution Timeline\n\n### Pre-2020: Robotic TTS\n- Concatenative synthesis (spliced recordings)\n- Obvious robotic quality\n- Limited voice options\n\n### 2020-2022: Neural TTS Emerges\n- Tacotron, WaveNet improve naturalness\n- Still detectable as synthetic\n- Voice cloning requires hours of data\n\n### 2023-2024: AI Voice Revolution\n- ElevenLabs instant voice cloning (30 seconds)\n- Near-human quality in TTS\n- Real-time voice transformation\n- Voice agents for customer service\n\n### 2025+: Current Best Practices\n- Emotional TTS (control tone, pace, emotion)\n- Cross-lingual voice cloning\n- Real-time voice transformation in apps\n- Personalized voice agents\n- Voice authentication integration\n\n## Core Concepts\n\n### ElevenLabs Voice Selection\n\n**Model comparison:**\n| Model | Quality | Latency | Languages | Use Case |\n|-------|---------|---------|-----------|----------|\n| `eleven_multilingual_v2` | Best | Higher | 29 | Production, quality-critical |\n| `eleven_flash_v2_5` | Good | Lowest | 32 | Real-time, voice UI |\n| `eleven_turbo_v2_5` | Better | Low | 32 | Balanced |\n\n**Voice parameters:**\n```python\n# Stability: 0-1 (lower = more expressive, higher = more consistent)\n# Similarity boost: 0-1 (higher = closer to original voice)\n# Style: 0-1 (higher = more exaggerated style)\n\n# For natural speech:\nstability = 0.5       # Balanced expression\nsimilarity = 0.75     # Close to voice but natural\nstyle = 0.0           # Neutral (increase for dramatic)\n```\n\n### Voice Cloning Best Practices\n\n**Audio requirements:**\n- Duration: 1-3 minutes (more = better, diminishing returns after 3min)\n- Quality: Clean, no background noise, no reverb\n- Content: Varied speech (questions, statements, emotions)\n- Format: WAV/MP3, 44.1kHz or higher\n\n**Cloning workflow:**\n1. `isolate_audio` to clean source material\n2. `voice_clone` with cleaned audio\n3. Test with varied prompts\n4. Adjust stability/similarity for output quality\n\n### Voice Processing Chain\n\n**Standard voice chain (order matters!):**\n```\n[Raw Recording]\n    ↓\n[High-Pass Filter @ 80Hz]  ← Remove rumble, plosives\n    ↓\n[De-esser @ 5-8kHz]        ← Before compression!\n    ↓\n[Compressor 3:1, 10ms/100ms] ← Smooth dynamics\n    ↓\n[EQ: +2dB @ 3kHz presence] ← Clarity boost\n    ↓\n[Limiter -1 dBTP]          ← Prevent clipping\n    ↓\n[Loudness Norm -16 LUFS]   ← Target loudness\n```\n\n### Loudness Standards\n\n| Platform/Format | Target LUFS | True Peak |\n|-----------------|-------------|-----------|\n| Podcast | -16 to -19 | -1 dBTP |\n| Audiobook (ACX) | -18 to -23 RMS | -3 dBFS |\n| YouTube | -14 | -1 dBTP |\n| Spotify/Apple Music | -14 | -1 dBTP |\n| Broadcast (EBU R128) | -23 ±1 | -1 dBTP |\n\n**Measurement:**\n- LUFS = Loudness Units Full Scale (integrated)\n- True Peak = Maximum level including intersample peaks\n- Always measure with K-weighting (ITU-R BS.1770)\n\n### Conversational AI Agents\n\n**ElevenLabs agent configuration:**\n```python\ncreate_agent(\n    name=\"Support Agent\",\n    first_message=\"Hi, how can I help you today?\",\n    system_prompt=\"You are a helpful customer support agent...\",\n    voice_id=\"your_voice_id\",\n    language=\"en\",\n    llm=\"gemini-2.0-flash-001\",  # Fast for conversation\n    temperature=0.5,\n    asr_quality=\"high\",          # Speech recognition quality\n    turn_timeout=7,              # Seconds before agent responds\n    max_duration_seconds=300     # 5 minute call limit\n)\n```\n\n**Voice UI considerations:**\n- Use fast model (`eleven_flash_v2_5`) for real-time\n- Keep responses concise (< 30 seconds)\n- Add pauses for natural conversation flow\n- Handle interruptions gracefully\n\n## Quick Reference\n\n### Voice Selection Decision Tree\n- **Brand/professional content?** → Custom clone or curated voice\n- **Real-time/interactive?** → `eleven_flash_v2_5` model\n- **Quality-critical?** → `eleven_multilingual_v2` model\n- **Multiple languages?** → Check language support per voice\n\n### Processing Decision Tree\n- **Voice sounds muddy?** → HPF at 80Hz, boost 3kHz\n- **Sibilance harsh?** → De-ess at 5-8kHz\n- **Inconsistent volume?** → Compress 3:1, then limit\n- **Too quiet?** → Normalize to target LUFS\n- **Background noise?** → Use `isolate_audio` first\n\n### Common Settings\n```\nDe-esser: 5-8kHz, -6dB reduction, Q=2\nCompressor: 3:1 ratio, -20dB threshold, 10ms attack, 100ms release\nEQ presence: +2-3dB shelf at 3kHz\nHPF: 80-100Hz, 12dB/oct\nLimiter: -1 dBTP ceiling\n```\n\n## Working With Speech Disfluencies\n\n### Cluttering vs Stuttering\n\n| Type | Characteristics | ASR Impact |\n|------|-----------------|------------|\n| **Stuttering** | Repetitions (\"I-I-I\"), prolongations (\"wwwant\"), blocks (silent pauses) | Word boundaries confused; repetitions misrecognized |\n| **Cluttering** | Irregular rate, collapsed syllables, filler overload, tangential speech | Words merged; rate changes confuse timing |\n\n### ASR Challenges with Disfluent Speech\n\nMost ASR models trained on fluent speech. Disfluencies cause:\n- Word boundary detection errors\n- Repetitions transcribed literally (\"I I I want\" vs \"I want\")\n- Collapsed syllables missed entirely\n- Timing models confused by irregular pace\n\n### Solutions & Workarounds\n\n**1. Model selection (best to worst for disfluencies):**\n- **Whisper large-v3** - Most robust to disfluencies\n- **ElevenLabs speech_to_text** - Good with varied speech\n- **Google Speech-to-Text** - Decent with enhanced models\n- **Fast/lightweight models** - Usually worst\n\n**2. Pre-processing:**\n```python\n# Normalize speech rate before ASR\n# Use librosa to stretch irregular segments toward target rate\nimport librosa\ny, sr = librosa.load(\"disfluent.wav\")\ny_stretched = librosa.effects.time_stretch(y, rate=0.9)  # Slow down\n```\n\n**3. Post-processing:**\n- Remove duplicate words: \"I I I want\" → \"I want\"\n- Filter common fillers: \"um\", \"uh\", \"like\", \"you know\"\n- Use LLM to clean transcripts while preserving meaning\n\n**4. Fine-tuning Whisper (advanced):**\n```python\n# Fine-tune on disfluent speech dataset\n# Datasets: FluencyBank, UCLASS, SEP-28k (stuttering)\nfrom transformers import WhisperForConditionalGeneration, WhisperProcessor\n\nmodel = WhisperForConditionalGeneration.from_pretrained(\"openai/whisper-large-v3\")\n# Fine-tune on your speech samples with corrected transcripts\n# Training loop with disfluent audio → fluent transcript pairs\n```\n\n**5. ElevenLabs voice cloning approach:**\n- Clone your voice from fluent segments\n- Use TTS for fluent output with your voice\n- Great for pre-recorded content, not live\n\n### Accessibility Considerations\n\n- Always provide manual transcript correction option\n- Consider hybrid: ASR + human review\n- For voice UI: longer timeout, confirmation prompts\n- Test with actual users from target population\n\n## Performance Targets\n\n| Operation | Typical Time |\n|-----------|--------------|\n| TTS (100 words) | 2-5 seconds |\n| Voice clone creation | 10-30 seconds |\n| Speech-to-speech | 3-8 seconds |\n| Transcription (1 min audio) | 5-15 seconds |\n| Audio isolation | 5-20 seconds |\n\n## Integrates With\n\n- **sound-engineer** - For spatial audio, game audio, procedural SFX\n- **native-app-designer** - Voice UI implementation in apps\n- **vr-avatar-engineer** - Avatar voice integration\n\n---\n\n**For detailed implementations**: See `/references/implementations.md`\n\n**Remember**: Voice is intimate—it speaks directly to the listener's brain. Match voice to brand, process for clarity not loudness, and always respect the platform's loudness standards. With ElevenLabs, you have instant access to professional voice synthesis; use it thoughtfully.\n"
    }
  ]
}