{
  "name": "security-auditor",
  "type": "folder",
  "path": "security-auditor",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "security-auditor/references",
      "children": [
        {
          "name": "owasp-top-10-2024.md",
          "type": "file",
          "path": "security-auditor/references/owasp-top-10-2024.md",
          "size": 9594,
          "content": "# OWASP Top 10 2021 Reference Guide\n\nThis reference provides detailed guidance for each OWASP Top 10 category with detection patterns and remediation strategies.\n\n## A01:2021 - Broken Access Control\n\n### What It Is\nFailures in enforcing access control policies that allow users to act outside their intended permissions.\n\n### Common Vulnerabilities\n- Missing authorization checks on API endpoints\n- IDOR (Insecure Direct Object References)\n- Elevation of privilege through parameter tampering\n- JWT manipulation bypassing access controls\n- CORS misconfigurations\n\n### Detection Patterns\n\n**Missing Auth Middleware:**\n```javascript\n// BAD: No auth check\napp.get('/api/users/:id', (req, res) => {\n  const user = db.getUser(req.params.id);\n  res.json(user);\n});\n\n// GOOD: Auth middleware applied\napp.get('/api/users/:id', authMiddleware, checkOwnership, (req, res) => {\n  const user = db.getUser(req.params.id);\n  res.json(user);\n});\n```\n\n**IDOR Vulnerability:**\n```python\n# BAD: No ownership check\n@app.route('/documents/<doc_id>')\ndef get_document(doc_id):\n    return Document.query.get(doc_id)\n\n# GOOD: Ownership verification\n@app.route('/documents/<doc_id>')\n@login_required\ndef get_document(doc_id):\n    doc = Document.query.get(doc_id)\n    if doc.owner_id != current_user.id:\n        abort(403)\n    return doc\n```\n\n### Remediation\n1. Deny by default - require explicit authorization\n2. Implement server-side access control\n3. Log access control failures and alert on suspicious patterns\n4. Rate limit APIs to prevent enumeration\n5. Use indirect references (UUIDs vs sequential IDs)\n\n---\n\n## A02:2021 - Cryptographic Failures\n\n### What It Is\nFailures related to cryptography that expose sensitive data.\n\n### Common Vulnerabilities\n- Weak or deprecated algorithms (MD5, SHA1 for passwords)\n- Insufficient key length\n- Improper key management\n- Transmitting data in clear text\n- Not enforcing encryption\n\n### Detection Patterns\n\n**Weak Hash Algorithms:**\n```javascript\n// BAD: MD5 for passwords\nconst hash = crypto.createHash('md5').update(password).digest('hex');\n\n// GOOD: bcrypt with proper rounds\nconst hash = await bcrypt.hash(password, 12);\n```\n\n**Insecure Randomness:**\n```python\n# BAD: Predictable random\ntoken = str(random.randint(100000, 999999))\n\n# GOOD: Cryptographically secure\nimport secrets\ntoken = secrets.token_urlsafe(32)\n```\n\n### Remediation\n1. Use bcrypt/argon2 for passwords (work factor ≥10)\n2. Use SHA-256+ for integrity\n3. Use TLS 1.3 for data in transit\n4. Use secrets/crypto.randomBytes for security-sensitive random values\n5. Rotate keys regularly\n\n---\n\n## A03:2021 - Injection\n\n### What It Is\nUser-supplied data sent to an interpreter as part of a command or query.\n\n### Common Vulnerabilities\n- SQL injection\n- Command injection\n- LDAP injection\n- XSS (Cross-Site Scripting)\n- Template injection\n\n### Detection Patterns\n\n**SQL Injection:**\n```python\n# BAD: String concatenation\nquery = f\"SELECT * FROM users WHERE name = '{name}'\"\n\n# GOOD: Parameterized query\ncursor.execute(\"SELECT * FROM users WHERE name = %s\", (name,))\n```\n\n**Command Injection:**\n```javascript\n// BAD: User input in exec\nexec(`convert ${userInput} output.pdf`);\n\n// GOOD: Use execFile with array\nexecFile('convert', [sanitizedInput, 'output.pdf']);\n```\n\n**XSS:**\n```javascript\n// BAD: innerHTML with user content\nelement.innerHTML = userContent;\n\n// GOOD: textContent for text, sanitize for HTML\nelement.textContent = userContent;\n// OR\nelement.innerHTML = DOMPurify.sanitize(userContent);\n```\n\n### Remediation\n1. Use parameterized queries/prepared statements\n2. Validate and sanitize all input\n3. Use allowlists for command arguments\n4. Escape output based on context\n5. Use CSP headers\n\n---\n\n## A04:2021 - Insecure Design\n\n### What It Is\nMissing or ineffective security controls at the design level.\n\n### Common Vulnerabilities\n- Missing rate limiting\n- No account lockout\n- Credential recovery flaws\n- Missing fraud detection\n- Trust boundary violations\n\n### Detection Patterns\n\n**Missing Rate Limiting:**\n```javascript\n// BAD: No limits on sensitive endpoint\napp.post('/login', (req, res) => {\n  // Unlimited attempts\n});\n\n// GOOD: Rate limiting applied\napp.post('/login',\n  rateLimit({ windowMs: 15*60*1000, max: 5 }),\n  (req, res) => { }\n);\n```\n\n### Remediation\n1. Establish secure design patterns\n2. Threat model for each feature\n3. Implement defense in depth\n4. Segment trust levels\n5. Test abuse cases, not just use cases\n\n---\n\n## A05:2021 - Security Misconfiguration\n\n### What It Is\nMissing security hardening or improperly configured permissions.\n\n### Common Vulnerabilities\n- Default credentials\n- Unnecessary features enabled\n- Verbose error messages\n- Missing security headers\n- Cloud storage misconfigurations\n\n### Detection Patterns\n\n**Debug Mode in Production:**\n```python\n# BAD\nDEBUG = True  # In production\n\n# GOOD\nDEBUG = os.environ.get('DEBUG', 'False').lower() == 'true'\n```\n\n**Missing Security Headers:**\n```javascript\n// GOOD: Security headers applied\napp.use(helmet());\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"]\n  }\n}));\n```\n\n### Remediation\n1. Minimal platform without unnecessary features\n2. Review and update configurations regularly\n3. Implement security headers\n4. Automated security configuration verification\n5. Different credentials for each environment\n\n---\n\n## A06:2021 - Vulnerable and Outdated Components\n\n### What It Is\nUsing components with known vulnerabilities.\n\n### Detection Commands\n```bash\n# Node.js\nnpm audit\nnpm audit --json | jq '.vulnerabilities'\n\n# Python\npip-audit\nsafety check\n\n# General\nsnyk test\ntrivy fs .\n```\n\n### Remediation\n1. Remove unused dependencies\n2. Subscribe to security bulletins\n3. Scan dependencies in CI/CD\n4. Plan for regular updates\n5. Use LTS versions when possible\n\n---\n\n## A07:2021 - Identification and Authentication Failures\n\n### What It Is\nWeaknesses in authentication mechanisms.\n\n### Common Vulnerabilities\n- Credential stuffing susceptibility\n- Weak password policies\n- Session fixation\n- Missing MFA\n- Improper session management\n\n### Detection Patterns\n\n**Weak Password Policy:**\n```javascript\n// BAD: No validation\nif (password) { createUser(password); }\n\n// GOOD: Strong validation\nconst strongPassword = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{12,}$/;\nif (strongPassword.test(password)) { createUser(password); }\n```\n\n### Remediation\n1. Implement MFA where possible\n2. Use strong password policies\n3. Limit failed login attempts\n4. Use secure session management\n5. Invalidate sessions on logout/password change\n\n---\n\n## A08:2021 - Software and Data Integrity Failures\n\n### What It Is\nCode and infrastructure that doesn't protect against integrity violations.\n\n### Common Vulnerabilities\n- Insecure deserialization\n- CI/CD pipeline compromise\n- Auto-update without verification\n- Unsigned code\n\n### Detection Patterns\n\n**Insecure Deserialization:**\n```python\n# BAD: Pickle with untrusted data\ndata = pickle.loads(user_input)\n\n# GOOD: JSON with validation\ndata = json.loads(user_input)\nvalidate_schema(data, expected_schema)\n```\n\n### Remediation\n1. Use digital signatures for data/code\n2. Verify component integrity\n3. Secure CI/CD pipelines\n4. Avoid insecure serialization formats\n5. Review code before deployment\n\n---\n\n## A09:2021 - Security Logging and Monitoring Failures\n\n### What It Is\nInsufficient logging, monitoring, or response to security events.\n\n### What to Log\n- Authentication attempts (success/fail)\n- Authorization failures\n- Input validation failures\n- Application errors\n- Admin activities\n\n### Detection Patterns\n\n**Sensitive Data in Logs:**\n```python\n# BAD: Password in logs\nlogger.info(f\"Login attempt: {username}, password: {password}\")\n\n# GOOD: Redacted sensitive data\nlogger.info(f\"Login attempt: {username}, password: [REDACTED]\")\n```\n\n### Remediation\n1. Log security-relevant events\n2. Use centralized log management\n3. Set up alerting thresholds\n4. Establish incident response procedures\n5. Retain logs for forensics\n\n---\n\n## A10:2021 - Server-Side Request Forgery (SSRF)\n\n### What It Is\nWeb application fetches a remote resource without validating the user-supplied URL.\n\n### Common Vulnerabilities\n- URL parameter passed to fetch/request\n- Webhook configurations\n- File imports from URLs\n- PDF generators with external resources\n\n### Detection Patterns\n\n**SSRF Vulnerability:**\n```javascript\n// BAD: User-controlled URL\nconst response = await fetch(req.query.url);\n\n// GOOD: URL validation\nconst allowedDomains = ['api.trusted.com', 'cdn.trusted.com'];\nconst url = new URL(req.query.url);\nif (!allowedDomains.includes(url.hostname)) {\n  throw new Error('Domain not allowed');\n}\nconst response = await fetch(url);\n```\n\n### Remediation\n1. Validate and sanitize all URLs\n2. Use allowlists for permitted domains\n3. Disable HTTP redirects or validate targets\n4. Block requests to private IP ranges\n5. Use network segmentation\n\n---\n\n## Quick Reference Table\n\n| Category | Key Detection Pattern | Critical Fix |\n|----------|----------------------|--------------|\n| A01 | Missing auth middleware | Add authorization checks |\n| A02 | MD5/SHA1 for passwords | Use bcrypt/argon2 |\n| A03 | String concat in queries | Parameterized queries |\n| A04 | No rate limiting | Add rate limits |\n| A05 | DEBUG=True in prod | Environment-based config |\n| A06 | Old dependency versions | npm audit fix |\n| A07 | No account lockout | Limit failed attempts |\n| A08 | pickle.loads() | Use safe deserialization |\n| A09 | Passwords in logs | Redact sensitive data |\n| A10 | User URL in fetch() | URL allowlisting |\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "security-auditor/scripts",
      "children": [
        {
          "name": "detect-secrets.sh",
          "type": "file",
          "path": "security-auditor/scripts/detect-secrets.sh",
          "size": 6480,
          "content": "#!/bin/bash\n# Secret Detection Script\n# Scans for high-entropy strings, API keys, credentials, and sensitive patterns\n\nset -euo pipefail\n\nTARGET_DIR=\"${1:-.}\"\nOUTPUT_FILE=\"${2:-secrets-report.json}\"\n\n# Colors for output\nRED='\\033[0;31m'\nYELLOW='\\033[1;33m'\nGREEN='\\033[0;32m'\nNC='\\033[0m' # No Color\n\necho \"Scanning for secrets in: $TARGET_DIR\"\necho \"==================================\"\n\n# Initialize findings array\nFINDINGS=\"[]\"\nCRITICAL_COUNT=0\nHIGH_COUNT=0\nMEDIUM_COUNT=0\n\n# Function to add finding\nadd_finding() {\n    local severity=\"$1\"\n    local pattern_name=\"$2\"\n    local file=\"$3\"\n    local line_num=\"$4\"\n    local evidence=\"$5\"\n\n    local finding=$(jq -n \\\n        --arg sev \"$severity\" \\\n        --arg pat \"$pattern_name\" \\\n        --arg file \"$file\" \\\n        --arg line \"$line_num\" \\\n        --arg ev \"$evidence\" \\\n        '{severity: $sev, pattern: $pat, file: $file, line: $line, evidence: $ev}')\n\n    FINDINGS=$(echo \"$FINDINGS\" | jq \". + [$finding]\")\n}\n\n# Skip patterns for files we shouldn't scan\nSKIP_PATTERNS=(\n    \"node_modules\"\n    \".git\"\n    \"dist\"\n    \"build\"\n    \".next\"\n    \"__pycache__\"\n    \"*.min.js\"\n    \"*.bundle.js\"\n    \"package-lock.json\"\n    \"yarn.lock\"\n    \"*.woff\"\n    \"*.woff2\"\n    \"*.ttf\"\n    \"*.png\"\n    \"*.jpg\"\n    \"*.gif\"\n    \"*.ico\"\n    \"*.svg\"\n)\n\n# Build find exclusion\nFIND_EXCLUDES=\"\"\nfor pattern in \"${SKIP_PATTERNS[@]}\"; do\n    FIND_EXCLUDES=\"$FIND_EXCLUDES -not -path '*/$pattern/*' -not -name '$pattern'\"\ndone\n\necho -e \"\\n${YELLOW}[1/5] Checking for AWS credentials...${NC}\"\n# AWS Access Key ID\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        echo -e \"${RED}CRITICAL: AWS Key in $file:$line${NC}\"\n        add_finding \"critical\" \"AWS Access Key\" \"$file\" \"$line\" \"AKIA... pattern detected\"\n        ((CRITICAL_COUNT++))\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -Hn 'AKIA[0-9A-Z]\\{16\\}' {} \\; 2>/dev/null\" || true)\n\n# AWS Secret Key pattern\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        echo -e \"${RED}CRITICAL: Possible AWS Secret in $file:$line${NC}\"\n        add_finding \"critical\" \"AWS Secret Key\" \"$file\" \"$line\" \"40-char base64 near 'secret'\"\n        ((CRITICAL_COUNT++))\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -Hin 'aws.*secret.*[A-Za-z0-9/+=]\\{40\\}' {} \\; 2>/dev/null\" || true)\n\necho -e \"\\n${YELLOW}[2/5] Checking for private keys...${NC}\"\n# Private keys\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        echo -e \"${RED}CRITICAL: Private key in $file:$line${NC}\"\n        add_finding \"critical\" \"Private Key\" \"$file\" \"$line\" \"BEGIN PRIVATE KEY detected\"\n        ((CRITICAL_COUNT++))\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -Hn 'BEGIN.*PRIVATE KEY' {} \\; 2>/dev/null\" || true)\n\necho -e \"\\n${YELLOW}[3/5] Checking for API keys and tokens...${NC}\"\n# Generic API key patterns\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        # Skip if it's a placeholder\n        if [[ ! \"$content\" =~ (YOUR_|PLACEHOLDER|EXAMPLE|xxx|XXX) ]]; then\n            echo -e \"${YELLOW}HIGH: Possible API key in $file:$line${NC}\"\n            add_finding \"high\" \"API Key Pattern\" \"$file\" \"$line\" \"api_key or apikey assignment detected\"\n            ((HIGH_COUNT++))\n        fi\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -HinE '(api[_-]?key|apikey)[[:space:]]*[:=][[:space:]]*[\\\"'\"'\"'][A-Za-z0-9_-]{20,}[\\\"'\"'\"']' {} \\; 2>/dev/null\" || true)\n\n# JWT tokens\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        echo -e \"${YELLOW}HIGH: JWT token in $file:$line${NC}\"\n        add_finding \"high\" \"JWT Token\" \"$file\" \"$line\" \"eyJ... pattern detected\"\n        ((HIGH_COUNT++))\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -Hn 'eyJ[A-Za-z0-9_-]*\\.eyJ[A-Za-z0-9_-]*\\.' {} \\; 2>/dev/null\" || true)\n\necho -e \"\\n${YELLOW}[4/5] Checking for connection strings...${NC}\"\n# Database connection strings with passwords\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        # Skip example/placeholder patterns\n        if [[ ! \"$content\" =~ (localhost|127\\.0\\.0\\.1|example\\.com|PLACEHOLDER|password123) ]]; then\n            echo -e \"${RED}CRITICAL: Connection string with credentials in $file:$line${NC}\"\n            add_finding \"critical\" \"Connection String\" \"$file\" \"$line\" \"URL with embedded credentials\"\n            ((CRITICAL_COUNT++))\n        fi\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -HnE '(mysql|postgres|mongodb|redis)://[^:]+:[^@]+@' {} \\; 2>/dev/null\" || true)\n\necho -e \"\\n${YELLOW}[5/5] Checking for hardcoded passwords...${NC}\"\n# Password assignments (excluding common false positives)\nwhile IFS=: read -r file line content; do\n    if [[ -n \"$content\" ]]; then\n        # Skip if test file, mock, or placeholder\n        if [[ ! \"$file\" =~ (test|spec|mock|fixture) ]] && [[ ! \"$content\" =~ (PASSWORD|placeholder|example|changeme) ]]; then\n            echo -e \"${YELLOW}MEDIUM: Possible hardcoded password in $file:$line${NC}\"\n            add_finding \"medium\" \"Hardcoded Password\" \"$file\" \"$line\" \"password assignment detected\"\n            ((MEDIUM_COUNT++))\n        fi\n    fi\ndone < <(eval \"find '$TARGET_DIR' -type f $FIND_EXCLUDES -exec grep -HinE 'password[[:space:]]*[:=][[:space:]]*[\\\"'\"'\"'][^\\\"'\"'\"']{8,}[\\\"'\"'\"']' {} \\; 2>/dev/null\" || true)\n\n# Generate report\nREPORT=$(jq -n \\\n    --arg target \"$TARGET_DIR\" \\\n    --arg date \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" \\\n    --argjson critical \"$CRITICAL_COUNT\" \\\n    --argjson high \"$HIGH_COUNT\" \\\n    --argjson medium \"$MEDIUM_COUNT\" \\\n    --argjson findings \"$FINDINGS\" \\\n    '{\n        scan_target: $target,\n        scan_date: $date,\n        summary: {\n            critical: $critical,\n            high: $high,\n            medium: $medium,\n            total: ($critical + $high + $medium)\n        },\n        findings: $findings\n    }')\n\necho \"$REPORT\" > \"$OUTPUT_FILE\"\n\necho \"\"\necho \"==================================\"\necho -e \"Scan Complete!\"\necho -e \"  Critical: ${RED}$CRITICAL_COUNT${NC}\"\necho -e \"  High:     ${YELLOW}$HIGH_COUNT${NC}\"\necho -e \"  Medium:   $MEDIUM_COUNT\"\necho \"\"\necho \"Report saved to: $OUTPUT_FILE\"\n\n# Exit with error if critical findings\nif [ \"$CRITICAL_COUNT\" -gt 0 ]; then\n    echo -e \"\\n${RED}CRITICAL vulnerabilities found! Review and remediate before deployment.${NC}\"\n    exit 1\nfi\n\nexit 0\n"
        },
        {
          "name": "full-audit.sh",
          "type": "file",
          "path": "security-auditor/scripts/full-audit.sh",
          "size": 9952,
          "content": "#!/bin/bash\n# Full Security Audit Script\n# Runs all security checks and generates a unified report\n\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nTARGET_DIR=\"${1:-.}\"\nOUTPUT_DIR=\"${2:-./security-reports}\"\nTIMESTAMP=$(date +%Y%m%d-%H%M%S)\n\n# Colors\nRED='\\033[0;31m'\nYELLOW='\\033[1;33m'\nGREEN='\\033[0;32m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\necho -e \"${BLUE}╔════════════════════════════════════════════════════════════╗${NC}\"\necho -e \"${BLUE}║           FULL SECURITY AUDIT                              ║${NC}\"\necho -e \"${BLUE}╚════════════════════════════════════════════════════════════╝${NC}\"\necho \"\"\necho \"Target: $TARGET_DIR\"\necho \"Output: $OUTPUT_DIR\"\necho \"Time:   $(date)\"\necho \"\"\n\n# Create output directory\nmkdir -p \"$OUTPUT_DIR\"\n\n# Track overall status\nOVERALL_STATUS=\"pass\"\nCRITICAL_TOTAL=0\nHIGH_TOTAL=0\n\n# ─────────────────────────────────────────────────────────────────────────────\necho -e \"\\n${BLUE}[1/4] Dependency Vulnerability Scan${NC}\"\necho \"────────────────────────────────────\"\n\nDEP_REPORT=\"$OUTPUT_DIR/dependencies-$TIMESTAMP.json\"\n\n# Check for package managers and run appropriate audits\nif [ -f \"$TARGET_DIR/package.json\" ]; then\n    echo \"  Found package.json - running npm audit...\"\n    if npm audit --json --prefix \"$TARGET_DIR\" > \"$DEP_REPORT\" 2>/dev/null; then\n        echo -e \"  ${GREEN}✓ No vulnerabilities found${NC}\"\n    else\n        # Parse npm audit output\n        VULN_CRITICAL=$(jq -r '.metadata.vulnerabilities.critical // 0' \"$DEP_REPORT\" 2>/dev/null || echo \"0\")\n        VULN_HIGH=$(jq -r '.metadata.vulnerabilities.high // 0' \"$DEP_REPORT\" 2>/dev/null || echo \"0\")\n        echo -e \"  ${RED}Critical: $VULN_CRITICAL${NC}\"\n        echo -e \"  ${YELLOW}High: $VULN_HIGH${NC}\"\n        CRITICAL_TOTAL=$((CRITICAL_TOTAL + VULN_CRITICAL))\n        HIGH_TOTAL=$((HIGH_TOTAL + VULN_HIGH))\n        if [ \"$VULN_CRITICAL\" -gt 0 ]; then\n            OVERALL_STATUS=\"fail\"\n        fi\n    fi\nfi\n\nif [ -f \"$TARGET_DIR/requirements.txt\" ] || [ -f \"$TARGET_DIR/pyproject.toml\" ]; then\n    echo \"  Found Python project - checking for pip-audit...\"\n    if command -v pip-audit &> /dev/null; then\n        PY_REPORT=\"$OUTPUT_DIR/pip-audit-$TIMESTAMP.json\"\n        if pip-audit --format json --output \"$PY_REPORT\" -r \"$TARGET_DIR/requirements.txt\" 2>/dev/null; then\n            echo -e \"  ${GREEN}✓ No Python vulnerabilities found${NC}\"\n        else\n            echo -e \"  ${YELLOW}Python vulnerabilities found - see $PY_REPORT${NC}\"\n        fi\n    else\n        echo -e \"  ${YELLOW}pip-audit not installed. Run: pip install pip-audit${NC}\"\n    fi\nfi\n\n# ─────────────────────────────────────────────────────────────────────────────\necho -e \"\\n${BLUE}[2/4] Secret Detection Scan${NC}\"\necho \"────────────────────────────────────\"\n\nSECRET_REPORT=\"$OUTPUT_DIR/secrets-$TIMESTAMP.json\"\n\nif [ -f \"$SCRIPT_DIR/detect-secrets.sh\" ]; then\n    if bash \"$SCRIPT_DIR/detect-secrets.sh\" \"$TARGET_DIR\" \"$SECRET_REPORT\"; then\n        echo -e \"  ${GREEN}✓ No secrets detected${NC}\"\n    else\n        SECRET_CRITICAL=$(jq -r '.summary.critical // 0' \"$SECRET_REPORT\" 2>/dev/null || echo \"0\")\n        SECRET_HIGH=$(jq -r '.summary.high // 0' \"$SECRET_REPORT\" 2>/dev/null || echo \"0\")\n        CRITICAL_TOTAL=$((CRITICAL_TOTAL + SECRET_CRITICAL))\n        HIGH_TOTAL=$((HIGH_TOTAL + SECRET_HIGH))\n        if [ \"$SECRET_CRITICAL\" -gt 0 ]; then\n            OVERALL_STATUS=\"fail\"\n        fi\n    fi\nelse\n    echo -e \"  ${YELLOW}detect-secrets.sh not found${NC}\"\nfi\n\n# ─────────────────────────────────────────────────────────────────────────────\necho -e \"\\n${BLUE}[3/4] OWASP Static Analysis${NC}\"\necho \"────────────────────────────────────\"\n\nOWASP_REPORT=\"$OUTPUT_DIR/owasp-$TIMESTAMP.json\"\n\nif [ -f \"$SCRIPT_DIR/owasp-check.py\" ]; then\n    if python3 \"$SCRIPT_DIR/owasp-check.py\" \"$TARGET_DIR\" --json --output \"$OWASP_REPORT\"; then\n        echo -e \"  ${GREEN}✓ No OWASP violations found${NC}\"\n    else\n        OWASP_CRITICAL=$(jq -r '.summary.critical // 0' \"$OWASP_REPORT\" 2>/dev/null || echo \"0\")\n        OWASP_HIGH=$(jq -r '.summary.high // 0' \"$OWASP_REPORT\" 2>/dev/null || echo \"0\")\n        echo -e \"  ${RED}Critical: $OWASP_CRITICAL${NC}\"\n        echo -e \"  ${YELLOW}High: $OWASP_HIGH${NC}\"\n        CRITICAL_TOTAL=$((CRITICAL_TOTAL + OWASP_CRITICAL))\n        HIGH_TOTAL=$((HIGH_TOTAL + OWASP_HIGH))\n        if [ \"$OWASP_CRITICAL\" -gt 0 ]; then\n            OVERALL_STATUS=\"fail\"\n        fi\n    fi\nelse\n    echo -e \"  ${YELLOW}owasp-check.py not found${NC}\"\nfi\n\n# ─────────────────────────────────────────────────────────────────────────────\necho -e \"\\n${BLUE}[4/4] Configuration Security Check${NC}\"\necho \"────────────────────────────────────\"\n\nCONFIG_ISSUES=0\n\n# Check for .env files in git\nif [ -d \"$TARGET_DIR/.git\" ]; then\n    if git -C \"$TARGET_DIR\" ls-files --error-unmatch .env 2>/dev/null; then\n        echo -e \"  ${RED}✗ .env file is tracked in git!${NC}\"\n        CONFIG_ISSUES=$((CONFIG_ISSUES + 1))\n        OVERALL_STATUS=\"fail\"\n    else\n        echo -e \"  ${GREEN}✓ .env not in git${NC}\"\n    fi\nfi\n\n# Check .gitignore for common security files\nif [ -f \"$TARGET_DIR/.gitignore\" ]; then\n    MISSING_IGNORES=\"\"\n    for pattern in \".env\" \"*.pem\" \"*.key\" \"credentials.json\" \"*.p12\"; do\n        if ! grep -q \"^$pattern\" \"$TARGET_DIR/.gitignore\" 2>/dev/null; then\n            MISSING_IGNORES=\"$MISSING_IGNORES $pattern\"\n        fi\n    done\n    if [ -n \"$MISSING_IGNORES\" ]; then\n        echo -e \"  ${YELLOW}Consider adding to .gitignore:$MISSING_IGNORES${NC}\"\n    else\n        echo -e \"  ${GREEN}✓ Sensitive patterns in .gitignore${NC}\"\n    fi\nfi\n\n# Check for debug flags in common config files\nfor config in \"$TARGET_DIR/package.json\" \"$TARGET_DIR/tsconfig.json\"; do\n    if [ -f \"$config\" ]; then\n        if grep -q '\"debug\"\\s*:\\s*true' \"$config\" 2>/dev/null; then\n            echo -e \"  ${YELLOW}Debug flag found in $(basename \"$config\")${NC}\"\n        fi\n    fi\ndone\n\n# ─────────────────────────────────────────────────────────────────────────────\necho \"\"\necho -e \"${BLUE}╔════════════════════════════════════════════════════════════╗${NC}\"\necho -e \"${BLUE}║                    AUDIT SUMMARY                           ║${NC}\"\necho -e \"${BLUE}╚════════════════════════════════════════════════════════════╝${NC}\"\necho \"\"\necho -e \"  Critical Issues: ${RED}$CRITICAL_TOTAL${NC}\"\necho -e \"  High Issues:     ${YELLOW}$HIGH_TOTAL${NC}\"\necho \"\"\n\n# Generate unified report\nUNIFIED_REPORT=\"$OUTPUT_DIR/security-report-$TIMESTAMP.json\"\n\njq -n \\\n    --arg target \"$TARGET_DIR\" \\\n    --arg date \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" \\\n    --arg status \"$OVERALL_STATUS\" \\\n    --argjson critical \"$CRITICAL_TOTAL\" \\\n    --argjson high \"$HIGH_TOTAL\" \\\n    '{\n        audit_target: $target,\n        audit_date: $date,\n        overall_status: $status,\n        summary: {\n            critical: $critical,\n            high: $high\n        },\n        reports: {\n            dependencies: \"dependencies-'$TIMESTAMP'.json\",\n            secrets: \"secrets-'$TIMESTAMP'.json\",\n            owasp: \"owasp-'$TIMESTAMP'.json\"\n        }\n    }' > \"$UNIFIED_REPORT\"\n\necho \"Reports saved to: $OUTPUT_DIR/\"\necho \"  - security-report-$TIMESTAMP.json (unified)\"\necho \"  - dependencies-$TIMESTAMP.json\"\necho \"  - secrets-$TIMESTAMP.json\"\necho \"  - owasp-$TIMESTAMP.json\"\necho \"\"\n\nif [ \"$OVERALL_STATUS\" = \"fail\" ]; then\n    echo -e \"${RED}╔════════════════════════════════════════════════════════════╗${NC}\"\n    echo -e \"${RED}║  AUDIT FAILED - Critical vulnerabilities require action    ║${NC}\"\n    echo -e \"${RED}╚════════════════════════════════════════════════════════════╝${NC}\"\n    exit 1\nelse\n    echo -e \"${GREEN}╔════════════════════════════════════════════════════════════╗${NC}\"\n    echo -e \"${GREEN}║  AUDIT PASSED - No critical issues found                   ║${NC}\"\n    echo -e \"${GREEN}╚════════════════════════════════════════════════════════════╝${NC}\"\n    exit 0\nfi\n"
        },
        {
          "name": "owasp-check.py",
          "type": "file",
          "path": "security-auditor/scripts/owasp-check.py",
          "size": 15335,
          "content": "#!/usr/bin/env python3\n\"\"\"\nOWASP Top 10 Static Analysis Scanner\nDetects common vulnerabilities in JavaScript, TypeScript, and Python code.\n\"\"\"\n\nimport argparse\nimport json\nimport os\nimport re\nimport sys\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\n@dataclass\nclass Finding:\n    \"\"\"Security finding data class\"\"\"\n    id: str\n    severity: str\n    owasp_category: str\n    title: str\n    file: str\n    line: int\n    evidence: str\n    description: str\n    remediation: str\n\nclass OWASPScanner:\n    \"\"\"Static analysis scanner for OWASP Top 10 vulnerabilities\"\"\"\n\n    # Patterns organized by OWASP category\n    PATTERNS = {\n        \"A03:Injection\": {\n            \"js\": [\n                (r'eval\\s*\\(', \"eval() usage\", \"critical\",\n                 \"eval() can execute arbitrary code\",\n                 \"Use JSON.parse() for data, avoid dynamic code execution\"),\n                (r'new\\s+Function\\s*\\(', \"new Function() usage\", \"critical\",\n                 \"new Function() can execute arbitrary code\",\n                 \"Avoid dynamic function creation, use static alternatives\"),\n                (r'child_process\\.exec\\s*\\([^)]*\\+', \"Command injection risk\", \"critical\",\n                 \"String concatenation in exec() allows command injection\",\n                 \"Use execFile() with array arguments, validate input\"),\n                (r'\\.innerHTML\\s*=', \"innerHTML assignment\", \"high\",\n                 \"innerHTML can execute scripts in user content\",\n                 \"Use textContent for text, sanitize HTML with DOMPurify\"),\n                (r'document\\.write\\s*\\(', \"document.write() usage\", \"high\",\n                 \"document.write() can inject malicious content\",\n                 \"Use DOM manipulation methods instead\"),\n                (r'\\$\\{[^}]+\\}.*(?:SELECT|INSERT|UPDATE|DELETE)', \"SQL template injection\", \"critical\",\n                 \"Template literals in SQL queries allow injection\",\n                 \"Use parameterized queries with placeholders\"),\n            ],\n            \"py\": [\n                (r'eval\\s*\\(', \"eval() usage\", \"critical\",\n                 \"eval() executes arbitrary Python code\",\n                 \"Use ast.literal_eval() for data, avoid eval()\"),\n                (r'exec\\s*\\(', \"exec() usage\", \"critical\",\n                 \"exec() executes arbitrary Python code\",\n                 \"Avoid exec(), use safer alternatives\"),\n                (r'subprocess\\..*shell\\s*=\\s*True', \"Shell=True in subprocess\", \"critical\",\n                 \"shell=True allows command injection\",\n                 \"Use shell=False with list arguments\"),\n                (r'pickle\\.loads?\\s*\\(', \"Pickle deserialization\", \"critical\",\n                 \"Pickle can execute arbitrary code during deserialization\",\n                 \"Use JSON or other safe serialization formats\"),\n                (r'yaml\\.load\\s*\\([^)]*\\)(?!\\s*,\\s*Loader)', \"Unsafe YAML load\", \"high\",\n                 \"yaml.load() without SafeLoader can execute code\",\n                 \"Use yaml.safe_load() or Loader=yaml.SafeLoader\"),\n                (r'cursor\\.execute\\s*\\([^)]*%', \"SQL string formatting\", \"critical\",\n                 \"String formatting in SQL queries allows injection\",\n                 \"Use parameterized queries: cursor.execute(sql, (param,))\"),\n                (r'cursor\\.execute\\s*\\([^)]*\\.format', \"SQL .format() injection\", \"critical\",\n                 \".format() in SQL queries allows injection\",\n                 \"Use parameterized queries with placeholders\"),\n            ]\n        },\n        \"A02:Cryptographic Failures\": {\n            \"js\": [\n                (r'crypto\\.createHash\\s*\\([\\'\"]md5[\\'\"]\\)', \"MD5 hash usage\", \"high\",\n                 \"MD5 is cryptographically broken\",\n                 \"Use SHA-256 or better for integrity, bcrypt/argon2 for passwords\"),\n                (r'crypto\\.createHash\\s*\\([\\'\"]sha1[\\'\"]\\)', \"SHA1 hash usage\", \"medium\",\n                 \"SHA1 is deprecated for security purposes\",\n                 \"Use SHA-256 or better\"),\n                (r'Math\\.random\\s*\\(', \"Math.random() for security\", \"medium\",\n                 \"Math.random() is not cryptographically secure\",\n                 \"Use crypto.randomBytes() or crypto.getRandomValues()\"),\n            ],\n            \"py\": [\n                (r'hashlib\\.md5\\s*\\(', \"MD5 hash usage\", \"high\",\n                 \"MD5 is cryptographically broken\",\n                 \"Use hashlib.sha256() or better, bcrypt for passwords\"),\n                (r'hashlib\\.sha1\\s*\\(', \"SHA1 hash usage\", \"medium\",\n                 \"SHA1 is deprecated for security purposes\",\n                 \"Use hashlib.sha256() or better\"),\n                (r'random\\.(random|randint|choice)', \"random module for security\", \"medium\",\n                 \"random module is not cryptographically secure\",\n                 \"Use secrets module for security-sensitive randomness\"),\n            ]\n        },\n        \"A05:Security Misconfiguration\": {\n            \"js\": [\n                (r'cors\\s*\\(\\s*\\)', \"CORS allow all\", \"high\",\n                 \"Unrestricted CORS allows any origin\",\n                 \"Configure specific allowed origins\"),\n                (r'app\\.use\\s*\\(\\s*cors\\s*\\(\\s*\\{\\s*origin\\s*:\\s*[\\'\"]?\\*', \"CORS wildcard origin\", \"high\",\n                 \"CORS wildcard allows any origin\",\n                 \"Specify allowed origins explicitly\"),\n                (r'debug\\s*[:=]\\s*true', \"Debug mode enabled\", \"medium\",\n                 \"Debug mode may expose sensitive information\",\n                 \"Disable debug mode in production\"),\n                (r'NODE_ENV\\s*!==?\\s*[\\'\"]production', \"Non-production check\", \"low\",\n                 \"Ensure production settings in deployment\",\n                 \"Use environment-specific configuration\"),\n            ],\n            \"py\": [\n                (r'DEBUG\\s*=\\s*True', \"Django DEBUG=True\", \"high\",\n                 \"Debug mode exposes sensitive error details\",\n                 \"Set DEBUG=False in production\"),\n                (r'ALLOWED_HOSTS\\s*=\\s*\\[\\s*[\\'\"]?\\*', \"Django wildcard hosts\", \"high\",\n                 \"Wildcard ALLOWED_HOSTS is insecure\",\n                 \"Specify exact hostnames\"),\n                (r'app\\.run\\s*\\([^)]*debug\\s*=\\s*True', \"Flask debug mode\", \"high\",\n                 \"Debug mode enables code execution via debugger\",\n                 \"Disable debug mode in production\"),\n            ]\n        },\n        \"A07:Authentication Failures\": {\n            \"js\": [\n                (r'jwt\\.sign\\s*\\([^)]*expiresIn\\s*:\\s*[\\'\"]?\\d{8,}', \"Long JWT expiry\", \"medium\",\n                 \"Very long token expiration increases risk\",\n                 \"Use shorter expiration times (hours, not days)\"),\n                (r'password.*[\\'\"][a-zA-Z0-9]{1,7}[\\'\"]', \"Short password constant\", \"high\",\n                 \"Hardcoded short password is insecure\",\n                 \"Remove hardcoded passwords, use secrets management\"),\n                (r'bcrypt.*rounds?\\s*[:=]\\s*[1-9]\\b', \"Low bcrypt rounds\", \"medium\",\n                 \"Low bcrypt rounds make passwords easier to crack\",\n                 \"Use at least 10-12 rounds\"),\n            ],\n            \"py\": [\n                (r'password.*=\\s*[\\'\"][a-zA-Z0-9]{1,7}[\\'\"]', \"Short password constant\", \"high\",\n                 \"Hardcoded short password is insecure\",\n                 \"Remove hardcoded passwords, use secrets management\"),\n                (r'SECRET_KEY\\s*=\\s*[\\'\"][^\\'\\\"]{1,20}[\\'\"]', \"Short SECRET_KEY\", \"high\",\n                 \"Short secret key is vulnerable to brute force\",\n                 \"Use at least 50 random characters\"),\n            ]\n        },\n        \"A10:SSRF\": {\n            \"js\": [\n                (r'fetch\\s*\\(\\s*(?:req\\.(?:query|body|params)|[a-zA-Z]+Input)', \"SSRF risk in fetch\", \"high\",\n                 \"User input directly in fetch URL allows SSRF\",\n                 \"Validate and whitelist allowed domains\"),\n                (r'axios\\.\\w+\\s*\\(\\s*(?:req\\.(?:query|body|params)|[a-zA-Z]+Input)', \"SSRF risk in axios\", \"high\",\n                 \"User input directly in axios URL allows SSRF\",\n                 \"Validate and whitelist allowed domains\"),\n            ],\n            \"py\": [\n                (r'requests\\.\\w+\\s*\\(\\s*(?:request\\.\\w+|user_input|url_param)', \"SSRF risk in requests\", \"high\",\n                 \"User input directly in request URL allows SSRF\",\n                 \"Validate and whitelist allowed domains\"),\n                (r'urllib\\.request\\.urlopen\\s*\\(\\s*[a-zA-Z]', \"SSRF risk in urllib\", \"high\",\n                 \"Unvalidated URL in urlopen allows SSRF\",\n                 \"Validate and whitelist allowed domains\"),\n            ]\n        }\n    }\n\n    # File extensions to language mapping\n    EXTENSIONS = {\n        '.js': 'js',\n        '.jsx': 'js',\n        '.ts': 'js',\n        '.tsx': 'js',\n        '.mjs': 'js',\n        '.cjs': 'js',\n        '.py': 'py',\n    }\n\n    # Directories to skip\n    SKIP_DIRS = {\n        'node_modules', '.git', 'dist', 'build', '.next', '__pycache__',\n        'venv', '.venv', 'env', '.env', 'coverage', '.nyc_output'\n    }\n\n    def __init__(self):\n        self.findings: List[Finding] = []\n        self.finding_counter = 0\n\n    def scan_file(self, filepath: Path) -> None:\n        \"\"\"Scan a single file for vulnerabilities\"\"\"\n        ext = filepath.suffix.lower()\n        lang = self.EXTENSIONS.get(ext)\n\n        if not lang:\n            return\n\n        try:\n            content = filepath.read_text(encoding='utf-8', errors='ignore')\n            lines = content.split('\\n')\n        except Exception as e:\n            print(f\"Warning: Could not read {filepath}: {e}\", file=sys.stderr)\n            return\n\n        for owasp_cat, lang_patterns in self.PATTERNS.items():\n            patterns = lang_patterns.get(lang, [])\n            for pattern, title, severity, description, remediation in patterns:\n                for i, line in enumerate(lines, 1):\n                    # Skip comments\n                    stripped = line.strip()\n                    if stripped.startswith('//') or stripped.startswith('#'):\n                        continue\n                    if stripped.startswith('/*') or stripped.startswith('\"\"\"') or stripped.startswith(\"'''\"):\n                        continue\n\n                    if re.search(pattern, line, re.IGNORECASE):\n                        self.finding_counter += 1\n                        self.findings.append(Finding(\n                            id=f\"OWASP-{self.finding_counter:04d}\",\n                            severity=severity,\n                            owasp_category=owasp_cat,\n                            title=title,\n                            file=str(filepath),\n                            line=i,\n                            evidence=line.strip()[:100],\n                            description=description,\n                            remediation=remediation\n                        ))\n\n    def scan_directory(self, path: Path) -> None:\n        \"\"\"Recursively scan a directory\"\"\"\n        if not path.exists():\n            print(f\"Error: Path does not exist: {path}\", file=sys.stderr)\n            sys.exit(1)\n\n        if path.is_file():\n            self.scan_file(path)\n            return\n\n        for item in path.rglob('*'):\n            # Skip excluded directories\n            if any(skip in item.parts for skip in self.SKIP_DIRS):\n                continue\n            if item.is_file():\n                self.scan_file(item)\n\n    def get_summary(self) -> dict:\n        \"\"\"Get summary counts by severity\"\"\"\n        summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}\n        for f in self.findings:\n            if f.severity in summary:\n                summary[f.severity] += 1\n        summary['total'] = len(self.findings)\n        return summary\n\n    def to_json(self) -> str:\n        \"\"\"Export findings as JSON\"\"\"\n        return json.dumps({\n            'summary': self.get_summary(),\n            'findings': [\n                {\n                    'id': f.id,\n                    'severity': f.severity,\n                    'owasp_category': f.owasp_category,\n                    'title': f.title,\n                    'file': f.file,\n                    'line': f.line,\n                    'evidence': f.evidence,\n                    'description': f.description,\n                    'remediation': f.remediation\n                }\n                for f in self.findings\n            ]\n        }, indent=2)\n\n    def print_report(self) -> None:\n        \"\"\"Print human-readable report\"\"\"\n        summary = self.get_summary()\n\n        print(\"\\n\" + \"=\" * 60)\n        print(\"OWASP Top 10 Static Analysis Report\")\n        print(\"=\" * 60)\n\n        print(f\"\\nSummary:\")\n        print(f\"  Critical: {summary['critical']}\")\n        print(f\"  High:     {summary['high']}\")\n        print(f\"  Medium:   {summary['medium']}\")\n        print(f\"  Low:      {summary['low']}\")\n        print(f\"  Total:    {summary['total']}\")\n\n        if self.findings:\n            print(\"\\nFindings:\")\n            print(\"-\" * 60)\n            for f in sorted(self.findings, key=lambda x: ['critical', 'high', 'medium', 'low'].index(x.severity)):\n                sev_color = {\n                    'critical': '\\033[91m',  # Red\n                    'high': '\\033[93m',      # Yellow\n                    'medium': '\\033[94m',    # Blue\n                    'low': '\\033[90m'        # Gray\n                }.get(f.severity, '')\n                reset = '\\033[0m'\n\n                print(f\"\\n[{sev_color}{f.severity.upper()}{reset}] {f.id}: {f.title}\")\n                print(f\"  Category: {f.owasp_category}\")\n                print(f\"  Location: {f.file}:{f.line}\")\n                print(f\"  Evidence: {f.evidence}\")\n                print(f\"  Issue: {f.description}\")\n                print(f\"  Fix: {f.remediation}\")\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='OWASP Top 10 Static Analysis Scanner',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  %(prog)s /path/to/project\n  %(prog)s src/api/users.js --json\n  %(prog)s . --output report.json\n        \"\"\"\n    )\n    parser.add_argument('path', help='File or directory to scan')\n    parser.add_argument('--json', '-j', action='store_true', help='Output JSON format')\n    parser.add_argument('--output', '-o', help='Write report to file')\n    parser.add_argument('--fail-on', choices=['critical', 'high', 'medium', 'low'],\n                        default='critical', help='Exit with error if findings at this level or above')\n\n    args = parser.parse_args()\n\n    scanner = OWASPScanner()\n    scanner.scan_directory(Path(args.path))\n\n    if args.json:\n        output = scanner.to_json()\n        if args.output:\n            Path(args.output).write_text(output)\n            print(f\"Report written to {args.output}\")\n        else:\n            print(output)\n    else:\n        scanner.print_report()\n        if args.output:\n            Path(args.output).write_text(scanner.to_json())\n            print(f\"\\nJSON report written to {args.output}\")\n\n    # Exit code based on findings\n    summary = scanner.get_summary()\n    severity_levels = ['critical', 'high', 'medium', 'low']\n    fail_index = severity_levels.index(args.fail_on)\n\n    for level in severity_levels[:fail_index + 1]:\n        if summary[level] > 0:\n            sys.exit(1)\n\n    sys.exit(0)\n\nif __name__ == '__main__':\n    main()\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "security-auditor/SKILL.md",
      "size": 8856,
      "content": "---\nname: security-auditor\ndescription: Security vulnerability scanner and OWASP compliance auditor for codebases. Dependency scanning (npm audit, pip-audit), secret detection (high-entropy strings, API keys), SAST for injection/XSS vulnerabilities, and security posture reports. Activate on 'security audit', 'vulnerability scan', 'OWASP', 'secret detection', 'dependency check', 'CVE', 'security review', 'penetration testing prep'. NOT for runtime WAF configuration (use infrastructure tools), network security/firewalls, or compliance certifications like SOC2/HIPAA (legal/organizational).\nallowed-tools: Read,Write,Edit,Bash(npm audit:*,pip-audit:*,grep:*,find:*),Grep,Glob\ncategory: Code Quality & Testing\ntags:\n  - security\n  - owasp\n  - vulnerabilities\n  - sast\n  - dependencies\npairs-with:\n  - skill: devops-automator\n    reason: Secure deployment pipelines\n  - skill: mcp-creator\n    reason: Secure MCP server development\n---\n\n# Security Auditor\n\nComprehensive security scanning for codebases. Identifies vulnerabilities before they become incidents. Focuses on actionable findings with remediation guidance.\n\n## When to Use\n\n**Use for:**\n- Pre-deployment security audits\n- Dependency vulnerability scanning\n- Secret/credential leak detection\n- Code-level SAST (Static Application Security Testing)\n- Security posture reports for stakeholders\n- OWASP Top 10 compliance checking\n- Pre-PR security reviews\n\n**Do NOT use for:**\n- Runtime security (WAF, rate limiting) - use infrastructure tools\n- Network security/firewall rules - use cloud/DevOps skills\n- SOC2/HIPAA/PCI compliance - requires legal/organizational process\n- Penetration testing execution - this is detection, not exploitation\n\n## Quick Start\n\n### Full Security Audit\n```bash\n# Run comprehensive scan\n./scripts/full-audit.sh /path/to/project\n\n# Output: security-report.json + summary\n```\n\n### Quick Checks\n```bash\n# Dependency vulnerabilities only\nnpm audit --json > deps-audit.json\n\n# Secret detection only\n./scripts/detect-secrets.sh /path/to/project\n\n# OWASP check specific file\n./scripts/owasp-check.py /path/to/file.js\n```\n\n## Core Scanning Capabilities\n\n### 1. Dependency Scanning\n\n| Package Manager | Command | Severity Levels |\n|-----------------|---------|-----------------|\n| npm | `npm audit --json` | critical, high, moderate, low |\n| yarn | `yarn audit --json` | same as npm |\n| pip | `pip-audit --format json` | critical, high, medium, low |\n| cargo | `cargo audit --json` | same |\n\n**Decision Tree:**\n```\nCritical severity found?\n├── YES → Block deployment, immediate fix required\n│   └── Check if patch available → npm audit fix --force\n├── NO → High severity?\n    ├── YES → Fix within sprint, document if deferred\n    └── NO → Low/Moderate → Track, fix during maintenance\n```\n\n### 2. Secret Detection\n\n**High-Risk Patterns:**\n- API keys: `/[A-Za-z0-9_]{20,}/` near \"key\", \"api\", \"secret\"\n- AWS credentials: `AKIA[0-9A-Z]{16}`\n- Private keys: `-----BEGIN (RSA|EC|OPENSSH) PRIVATE KEY-----`\n- JWT tokens: `eyJ[A-Za-z0-9_-]+\\.eyJ[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+`\n- Connection strings: `://[^:]+:[^@]+@`\n\n**Entropy Analysis:**\n- Shannon entropy > 4.5 on strings > 20 chars = suspicious\n- Base64-encoded blobs in source = investigate\n\n**False Positive Handling:**\n```\nSecret-like pattern found?\n├── In test file? → Lower severity, document\n├── In example/docs? → Check if placeholder\n├── High entropy + near \"password\"/\"secret\" → High confidence\n└── In .env.example? → Acceptable if placeholder values\n```\n\n### 3. OWASP Top 10 Static Analysis\n\n| # | Vulnerability | Detection Pattern |\n|---|---------------|-------------------|\n| A01 | Broken Access Control | Missing auth checks on routes |\n| A02 | Cryptographic Failures | Weak algorithms (MD5, SHA1 for passwords) |\n| A03 | Injection | Unparameterized queries, eval(), innerHTML |\n| A04 | Insecure Design | Hardcoded credentials, missing rate limits |\n| A05 | Security Misconfiguration | Debug mode in prod, default credentials |\n| A06 | Vulnerable Components | Known CVEs in dependencies |\n| A07 | Auth Failures | Weak password policies, session issues |\n| A08 | Integrity Failures | Unsigned updates, untrusted deserialization |\n| A09 | Logging Failures | Sensitive data in logs, missing audit trails |\n| A10 | SSRF | Unvalidated URL inputs to fetch/request |\n\n### 4. Language-Specific Checks\n\n**JavaScript/TypeScript:**\n- `eval()`, `new Function()` - code injection\n- `innerHTML`, `outerHTML` - XSS vectors\n- `document.write()` - DOM-based XSS\n- `child_process.exec()` with user input - command injection\n- Regex without timeout - ReDoS vulnerability\n\n**Python:**\n- `pickle.loads()` with untrusted data - arbitrary code execution\n- `yaml.load()` without `Loader=SafeLoader` - code injection\n- `subprocess.shell=True` - command injection\n- `eval()`, `exec()` - code injection\n- SQL string concatenation - SQL injection\n\n**SQL:**\n- String concatenation in queries - SQL injection\n- `LIKE '%' + input + '%'` - injection via wildcards\n- Missing parameterization - critical vulnerability\n\n## Anti-Patterns\n\n### Anti-Pattern: Security by Obscurity\n**What it looks like**: \"Nobody will find this hardcoded password\"\n**Why wrong**: Secrets in source always leak eventually\n**Instead**: Environment variables, secret managers, zero hardcoded secrets\n\n### Anti-Pattern: Audit Fatigue\n**What it looks like**: 500 findings, all \"medium\", team ignores\n**Why wrong**: Critical issues buried in noise\n**Instead**: Prioritize by exploitability, start with critical/high only\n\n### Anti-Pattern: Fix Without Understanding\n**What it looks like**: `npm audit fix --force` without review\n**Why wrong**: May introduce breaking changes, doesn't address root cause\n**Instead**: Review each fix, understand the vulnerability, test after\n\n### Anti-Pattern: One-Time Audit\n**What it looks like**: \"We did a security audit last year\"\n**Why wrong**: New CVEs daily, code changes constantly\n**Instead**: CI/CD integration, weekly automated scans minimum\n\n## Security Report Format\n\n```json\n{\n  \"summary\": {\n    \"critical\": 0,\n    \"high\": 2,\n    \"medium\": 5,\n    \"low\": 12,\n    \"informational\": 8\n  },\n  \"findings\": [\n    {\n      \"id\": \"SEC-001\",\n      \"severity\": \"high\",\n      \"category\": \"A03:Injection\",\n      \"title\": \"SQL Injection in user search\",\n      \"location\": \"src/api/users.js:45\",\n      \"description\": \"User input concatenated directly into SQL query\",\n      \"evidence\": \"const query = `SELECT * FROM users WHERE name = '${input}'`\",\n      \"remediation\": \"Use parameterized queries: db.query('SELECT * FROM users WHERE name = $1', [input])\",\n      \"references\": [\"https://owasp.org/www-community/attacks/SQL_Injection\"]\n    }\n  ],\n  \"recommendations\": [\n    \"Implement parameterized queries across all database access\",\n    \"Add input validation layer\",\n    \"Enable SQL query logging for monitoring\"\n  ]\n}\n```\n\n## CI/CD Integration\n\n### GitHub Actions Example\n```yaml\nsecurity-scan:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - name: Run security audit\n      run: |\n        npm audit --json > audit.json\n        ./scripts/detect-secrets.sh . > secrets.json\n        ./scripts/generate-report.py\n    - name: Fail on critical\n      run: |\n        if jq '.summary.critical > 0' report.json; then\n          echo \"Critical vulnerabilities found!\"\n          exit 1\n        fi\n```\n\n## Scripts (in `scripts/` folder)\n\n| Script | Purpose |\n|--------|---------|\n| `full-audit.sh` | Comprehensive security scan |\n| `detect-secrets.sh` | High-entropy string and pattern detection |\n| `owasp-check.py` | OWASP Top 10 static analysis |\n| `generate-report.py` | Combine findings into unified report |\n\n## Expert vs Novice Approach\n\n| Novice | Expert |\n|--------|--------|\n| Runs audit once before release | CI/CD integration, every commit |\n| Focuses on tool output only | Understands vulnerability context |\n| Fixes everything or nothing | Triages by exploitability |\n| Uses one scanner | Layers multiple tools |\n| Ignores false positives | Tunes detection rules |\n\n## Success Metrics\n\n| Metric | Target |\n|--------|--------|\n| Critical/High pre-production | 0 |\n| Mean time to remediate critical | &lt; 24 hours |\n| False positive rate | &lt; 10% |\n| Scan coverage | 100% of deployable code |\n\n## Reference Files\n\n- `references/owasp-top-10-2024.md` - Detailed OWASP guidance\n- `references/secret-patterns.md` - Comprehensive regex patterns\n- `references/remediation-playbook.md` - Fix guidance by vulnerability type\n- `references/ci-cd-templates.md` - Integration examples\n- `scripts/` - Working security scanning scripts\n\n---\n\n**Detects**: Dependency CVEs | Secret leaks | Injection vulnerabilities | OWASP violations | Security misconfigurations\n\n**Use with**: site-reliability-engineer (deployment gates) | code-review (PR security checks)\n"
    }
  ]
}