{
  "name": "vaporwave-glassomorphic-ui-designer",
  "type": "folder",
  "path": "vaporwave-glassomorphic-ui-designer",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "vaporwave-glassomorphic-ui-designer/references",
      "children": [
        {
          "name": "animations-interactions.md",
          "type": "file",
          "path": "vaporwave-glassomorphic-ui-designer/references/animations-interactions.md",
          "size": 12347,
          "content": "# Animations & Micro-Interactions\n\nSwiftUI animations, button styles, and interactive elements for vaporwave-glass UI.\n\n## Button Styles\n\n### Bouncy Neon Button\n\n```swift\nstruct BouncyNeonButton: ButtonStyle {\n    @State private var isHovered = false\n\n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .padding(.horizontal, 24)\n            .padding(.vertical, 14)\n            .background(\n                RoundedRectangle(cornerRadius: 12)\n                    .fill(\n                        LinearGradient(\n                            colors: [.vaporwavePink, .vaporwavePurple],\n                            startPoint: .topLeading,\n                            endPoint: .bottomTrailing\n                        )\n                    )\n            )\n            .overlay(\n                RoundedRectangle(cornerRadius: 12)\n                    .stroke(Color.white.opacity(0.5), lineWidth: 2)\n            )\n            // Glow effect\n            .shadow(color: .vaporwavePink.opacity(0.6), radius: 15, y: 0)\n            .shadow(color: .vaporwavePink.opacity(0.3), radius: 30, y: 0)\n            // Press animation\n            .scaleEffect(configuration.isPressed ? 0.92 : 1.0)\n            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)\n    }\n}\n\n// Usage\nButton(\"Create Collage\") { /* action */ }\n    .buttonStyle(BouncyNeonButton())\n```\n\n### Glass Button\n\n```swift\nstruct GlassButtonStyle: ButtonStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .padding(.horizontal, 20)\n            .padding(.vertical, 12)\n            .background(.ultraThinMaterial)\n            .clipShape(RoundedRectangle(cornerRadius: 10))\n            .overlay(\n                RoundedRectangle(cornerRadius: 10)\n                    .stroke(\n                        LinearGradient(\n                            colors: [.white.opacity(0.6), .white.opacity(0.2)],\n                            startPoint: .topLeading,\n                            endPoint: .bottomTrailing\n                        ),\n                        lineWidth: 1\n                    )\n            )\n            .scaleEffect(configuration.isPressed ? 0.96 : 1.0)\n            .opacity(configuration.isPressed ? 0.9 : 1.0)\n            .animation(.easeInOut(duration: 0.15), value: configuration.isPressed)\n    }\n}\n```\n\n### Button Variants System\n\n```swift\nenum VaporwaveButtonStyle {\n    case primary      // Gradient fill, neon glow\n    case secondary    // Glass with border\n    case minimal      // Text only with underline glow\n}\n\nstruct VaporwaveButton: View {\n    let title: String\n    let style: VaporwaveButtonStyle\n    let action: () -> Void\n\n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .font(.vaporwaveBody)\n                .fontWeight(.semibold)\n                .padding(.horizontal, 24)\n                .padding(.vertical, 14)\n        }\n        .buttonStyle(styleForType)\n    }\n\n    @ViewBuilder\n    private var styleForType: some ButtonStyle {\n        switch style {\n        case .primary:\n            PrimaryVaporwaveButtonStyle()\n        case .secondary:\n            SecondaryGlassButtonStyle()\n        case .minimal:\n            MinimalGlowButtonStyle()\n        }\n    }\n}\n\nstruct PrimaryVaporwaveButtonStyle: ButtonStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .foregroundColor(.white)\n            .background(\n                LinearGradient(\n                    colors: [.vaporwavePink, .vaporwaveCyan],\n                    startPoint: .leading,\n                    endPoint: .trailing\n                )\n            )\n            .clipShape(RoundedRectangle(cornerRadius: 12))\n            .shadow(color: .vaporwaveCyan.opacity(0.5), radius: 15, y: 8)\n            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)\n            .animation(.spring(response: 0.3), value: configuration.isPressed)\n    }\n}\n```\n\n## Staggered Animations\n\n### Cascading List Animation\n\n```swift\nstruct StaggeredList: View {\n    let items: [String]\n    @State private var animatedItems: Set<String> = []\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            ForEach(Array(items.enumerated()), id: \\.offset) { index, item in\n                HStack {\n                    Circle()\n                        .fill(.vaporwaveCyan)\n                        .frame(width: 8, height: 8)\n                    Text(item)\n                        .font(.vaporwaveBody)\n                }\n                .opacity(animatedItems.contains(item) ? 1.0 : 0.0)\n                .offset(x: animatedItems.contains(item) ? 0 : -20)\n            }\n        }\n        .onAppear {\n            for (index, item) in items.enumerated() {\n                DispatchQueue.main.asyncAfter(deadline: .now() + Double(index) * 0.1) {\n                    withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {\n                        animatedItems.insert(item)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Grid Reveal Animation\n\n```swift\nstruct AnimatedPhotoGrid: View {\n    let photos: [Photo]\n    @State private var visiblePhotos: Set<UUID> = []\n\n    var body: some View {\n        LazyVGrid(columns: [GridItem(.adaptive(minimum: 100))], spacing: 12) {\n            ForEach(Array(photos.enumerated()), id: \\.element.id) { index, photo in\n                PhotoThumbnail(photo: photo)\n                    .opacity(visiblePhotos.contains(photo.id) ? 1.0 : 0.0)\n                    .scaleEffect(visiblePhotos.contains(photo.id) ? 1.0 : 0.8)\n                    .onAppear {\n                        // Stagger based on grid position\n                        let row = index / 3\n                        let col = index % 3\n                        let delay = Double(row + col) * 0.05\n\n                        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {\n                            withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {\n                                visiblePhotos.insert(photo.id)\n                            }\n                        }\n                    }\n            }\n        }\n    }\n}\n```\n\n## Glow Effects\n\n### Pulsing Glow\n\n```swift\nstruct PulsingGlow: ViewModifier {\n    let color: Color\n    let intensity: CGFloat\n    @State private var isGlowing = false\n\n    func body(content: Content) -> some View {\n        content\n            .shadow(\n                color: color.opacity(isGlowing ? intensity : intensity * 0.3),\n                radius: isGlowing ? 20 : 10,\n                y: 0\n            )\n            .onAppear {\n                withAnimation(\n                    .easeInOut(duration: 1.5)\n                    .repeatForever(autoreverses: true)\n                ) {\n                    isGlowing = true\n                }\n            }\n    }\n}\n\nextension View {\n    func pulsingGlow(color: Color = .vaporwaveCyan, intensity: CGFloat = 0.6) -> some View {\n        modifier(PulsingGlow(color: color, intensity: intensity))\n    }\n}\n```\n\n### Reactive Glow (Responds to Interaction)\n\n```swift\nstruct ReactiveGlowButton: View {\n    @State private var isPressed = false\n    @State private var glowRadius: CGFloat = 10\n\n    var body: some View {\n        Button(action: {\n            // Action\n        }) {\n            Text(\"Tap Me\")\n                .padding()\n                .background(.vaporwavePink)\n                .clipShape(RoundedRectangle(cornerRadius: 12))\n                .shadow(color: .vaporwavePink.opacity(0.8), radius: glowRadius)\n        }\n        .simultaneousGesture(\n            DragGesture(minimumDistance: 0)\n                .onChanged { _ in\n                    withAnimation(.spring(response: 0.2)) {\n                        isPressed = true\n                        glowRadius = 25\n                    }\n                }\n                .onEnded { _ in\n                    withAnimation(.spring(response: 0.3)) {\n                        isPressed = false\n                        glowRadius = 10\n                    }\n                }\n        )\n    }\n}\n```\n\n## Page Transitions\n\n### Dreamy Dissolve\n\n```swift\nstruct DreamyTransition: ViewModifier {\n    let isActive: Bool\n\n    func body(content: Content) -> some View {\n        content\n            .opacity(isActive ? 1.0 : 0.0)\n            .scaleEffect(isActive ? 1.0 : 1.1)  // Slight zoom\n            .blur(radius: isActive ? 0 : 10)     // Dreamy blur\n            .animation(.easeInOut(duration: 0.5), value: isActive)\n    }\n}\n```\n\n### Sliding Glass Panels\n\n```swift\nstruct SlidingPanelTransition: ViewModifier {\n    let edge: Edge\n    let isPresented: Bool\n\n    func body(content: Content) -> some View {\n        content\n            .offset(offsetForEdge)\n            .opacity(isPresented ? 1.0 : 0.0)\n            .animation(.spring(response: 0.4, dampingFraction: 0.8), value: isPresented)\n    }\n\n    private var offsetForEdge: CGSize {\n        guard !isPresented else { return .zero }\n        switch edge {\n        case .leading: return CGSize(width: -300, height: 0)\n        case .trailing: return CGSize(width: 300, height: 0)\n        case .top: return CGSize(width: 0, height: -300)\n        case .bottom: return CGSize(width: 0, height: 300)\n        }\n    }\n}\n```\n\n## Spring Physics Cheat Sheet\n\n```swift\n// Snappy, responsive\n.spring(response: 0.3, dampingFraction: 0.7)\n\n// Bouncy, playful\n.spring(response: 0.5, dampingFraction: 0.5)\n\n// Smooth, elegant\n.spring(response: 0.6, dampingFraction: 0.8)\n\n// Dramatic, slow\n.spring(response: 0.8, dampingFraction: 0.6)\n```\n\n## Animation Timing Guidelines\n\n| Category | Duration | Use Case |\n|----------|----------|----------|\n| Immediate feedback | 0-100ms | Button press, tap |\n| Quick transitions | 150-300ms | Page change, navigation |\n| Deliberate animations | 300-500ms | Onboarding, revealing |\n| Dramatic moments | 500-1000ms | Celebrations, achievements |\n\n## Accessibility: Reduced Motion\n\n```swift\nstruct MotionSafeAnimation: ViewModifier {\n    @Environment(\\.accessibilityReduceMotion) var reduceMotion\n    let animation: Animation\n\n    func body(content: Content) -> some View {\n        content\n            .animation(reduceMotion ? nil : animation, value: UUID())\n    }\n}\n\n// Alternative transitions for reduced motion\nextension AnyTransition {\n    static var motionSafe: AnyTransition {\n        @Environment(\\.accessibilityReduceMotion) var reduceMotion\n        return reduceMotion ? .opacity : .asymmetric(\n            insertion: .opacity.combined(with: .scale),\n            removal: .opacity\n        )\n    }\n}\n```\n\n## Interactive Examples\n\n### Pull-to-Refresh with Personality\n\n```swift\nstruct VaporwaveRefresh: View {\n    @State private var isRefreshing = false\n\n    var body: some View {\n        ScrollView {\n            // Content\n        }\n        .refreshable {\n            // Haptic feedback\n            let generator = UIImpactFeedbackGenerator(style: .medium)\n            generator.impactOccurred()\n\n            await performRefresh()\n\n            // Success haptic\n            let successGenerator = UINotificationFeedbackGenerator()\n            successGenerator.notificationOccurred(.success)\n        }\n    }\n}\n```\n\n### Delightful Empty State\n\n```swift\nstruct EmptyStateView: View {\n    @State private var rotation: Double = 0\n\n    var body: some View {\n        VStack(spacing: 20) {\n            Image(systemName: \"photo.on.rectangle.angled\")\n                .font(.system(size: 60))\n                .foregroundStyle(\n                    LinearGradient(\n                        colors: [.vaporwavePink, .vaporwaveCyan],\n                        startPoint: .topLeading,\n                        endPoint: .bottomTrailing\n                    )\n                )\n                .rotationEffect(.degrees(rotation))\n                .onAppear {\n                    withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {\n                        rotation = 5\n                    }\n                }\n\n            Text(\"No photos yet\")\n                .font(.vaporwaveTitle)\n                .foregroundStyle(.white)\n\n            Text(\"Start creating beautiful memories\")\n                .font(.vaporwaveBody)\n                .foregroundStyle(.white.opacity(0.7))\n        }\n        .padding()\n    }\n}\n```\n"
        },
        {
          "name": "glassmorphism-patterns.md",
          "type": "file",
          "path": "vaporwave-glassomorphic-ui-designer/references/glassmorphism-patterns.md",
          "size": 10760,
          "content": "# Glassmorphism Patterns for SwiftUI\n\nComplete SwiftUI implementations for glassmorphic UI components.\n\n## Core Glass Card Component\n\n```swift\nstruct GlassCard<Content: View>: View {\n    let content: Content\n\n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n\n    var body: some View {\n        content\n            .padding(20)\n            .background(.ultraThinMaterial)  // Key: System blur material\n            .overlay(\n                RoundedRectangle(cornerRadius: 16)\n                    .stroke(\n                        LinearGradient(\n                            colors: [\n                                Color.white.opacity(0.6),\n                                Color.white.opacity(0.2)\n                            ],\n                            startPoint: .topLeading,\n                            endPoint: .bottomTrailing\n                        ),\n                        lineWidth: 1.5\n                    )\n            )\n            .clipShape(RoundedRectangle(cornerRadius: 16))\n            .shadow(color: .black.opacity(0.1), radius: 10, y: 5)\n    }\n}\n```\n\n## Material Hierarchy\n\niOS provides 5 material types for glassmorphism:\n\n```swift\n// Material options (from most to least transparent)\n.background(.ultraThinMaterial)    // Most transparent (floating panels)\n.background(.thinMaterial)         // Subtle blur (toolbars)\n.background(.regularMaterial)      // Balanced (sheets, modals)\n.background(.thickMaterial)        // Strong blur (backgrounds)\n.background(.ultraThickMaterial)   // Opaque-ish (critical UI)\n\n// Selection criteria:\n// - Content importance: critical UI = thicker\n// - Visual hierarchy: foreground = thinner, background = thicker\n// - Readability needs: text-heavy = thicker\n```\n\n## Advanced Glass with Gradient Border\n\n```swift\nstruct GlassPanel: View {\n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            Text(\"Create Collage\")\n                .font(.title2.weight(.semibold))\n                .foregroundStyle(.white)\n\n            Text(\"AI will find photos that belong together\")\n                .font(.subheadline)\n                .foregroundStyle(.white.opacity(0.7))\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n        .padding(24)\n        .background {\n            // Multi-layer glass effect\n            ZStack {\n                // Blur layer\n                RoundedRectangle(cornerRadius: 20)\n                    .fill(.ultraThinMaterial)\n\n                // Gradient overlay for depth\n                LinearGradient(\n                    colors: [\n                        Color.white.opacity(0.15),\n                        Color.clear\n                    ],\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                )\n                .blendMode(.overlay)\n\n                // Border gradient\n                RoundedRectangle(cornerRadius: 20)\n                    .strokeBorder(\n                        LinearGradient(\n                            colors: [\n                                Color.white.opacity(0.8),\n                                Color.white.opacity(0.2),\n                                Color.purple.opacity(0.3)\n                            ],\n                            startPoint: .topLeading,\n                            endPoint: .bottomTrailing\n                        ),\n                        lineWidth: 2\n                    )\n            }\n        }\n        .shadow(color: .purple.opacity(0.3), radius: 20, y: 10)\n    }\n}\n```\n\n## Adaptive Glass (Dark/Light Mode)\n\n```swift\nstruct AdaptiveGlassCard: View {\n    @Environment(\\.colorScheme) var colorScheme\n\n    var body: some View {\n        VStack {\n            // Content\n        }\n        .padding()\n        .background {\n            if colorScheme == .dark {\n                // Dark mode: lighter glass\n                RoundedRectangle(cornerRadius: 16)\n                    .fill(.thinMaterial)\n                    .overlay(\n                        RoundedRectangle(cornerRadius: 16)\n                            .stroke(Color.white.opacity(0.3), lineWidth: 1)\n                    )\n            } else {\n                // Light mode: subtle tint\n                RoundedRectangle(cornerRadius: 16)\n                    .fill(.ultraThinMaterial)\n                    .overlay(\n                        RoundedRectangle(cornerRadius: 16)\n                            .stroke(Color.black.opacity(0.1), lineWidth: 1)\n                    )\n            }\n        }\n    }\n}\n```\n\n## Card Style Variants\n\n```swift\nenum GlassCardStyle {\n    case thin        // Minimal blur\n    case regular     // Standard\n    case thick       // Heavy blur, more opaque\n    case neon        // Glass + colored glow\n}\n\nstruct StyledGlassCard<Content: View>: View {\n    let style: GlassCardStyle\n    let content: Content\n\n    init(style: GlassCardStyle, @ViewBuilder content: () -> Content) {\n        self.style = style\n        self.content = content()\n    }\n\n    var body: some View {\n        content\n            .padding(20)\n            .background(materialForStyle)\n            .overlay(borderForStyle)\n            .clipShape(RoundedRectangle(cornerRadius: 16))\n            .shadow(color: shadowColorForStyle, radius: shadowRadiusForStyle, y: 5)\n    }\n\n    @ViewBuilder\n    private var materialForStyle: some ShapeStyle {\n        switch style {\n        case .thin:\n            AnyShapeStyle(.ultraThinMaterial)\n        case .regular:\n            AnyShapeStyle(.regularMaterial)\n        case .thick:\n            AnyShapeStyle(.thickMaterial)\n        case .neon:\n            AnyShapeStyle(.thinMaterial)\n        }\n    }\n\n    @ViewBuilder\n    private var borderForStyle: some View {\n        if style == .neon {\n            RoundedRectangle(cornerRadius: 16)\n                .stroke(\n                    LinearGradient(\n                        colors: [.vaporwavePink, .vaporwaveCyan],\n                        startPoint: .topLeading,\n                        endPoint: .bottomTrailing\n                    ),\n                    lineWidth: 2\n                )\n        } else {\n            RoundedRectangle(cornerRadius: 16)\n                .stroke(Color.white.opacity(0.3), lineWidth: 1)\n        }\n    }\n\n    private var shadowColorForStyle: Color {\n        style == .neon ? .vaporwavePink.opacity(0.4) : .black.opacity(0.1)\n    }\n\n    private var shadowRadiusForStyle: CGFloat {\n        style == .neon ? 20 : 10\n    }\n}\n```\n\n## Glass Sheet (Modal Presentation)\n\n```swift\n.sheet(isPresented: $showingModal) {\n    GlassSheet {\n        VStack(spacing: 20) {\n            Text(\"Export Collage\")\n                .font(.vaporwaveTitle)\n\n            // Content\n        }\n        .padding()\n    }\n    .presentationDetents([.medium, .large])\n    .presentationDragIndicator(.visible)\n}\n\nstruct GlassSheet<Content: View>: View {\n    let content: Content\n\n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n\n    var body: some View {\n        content\n            .background(.regularMaterial)\n            .overlay(\n                Rectangle()\n                    .fill(\n                        LinearGradient(\n                            colors: [\n                                Color.white.opacity(0.1),\n                                Color.clear\n                            ],\n                            startPoint: .top,\n                            endPoint: .bottom\n                        )\n                    )\n            )\n    }\n}\n```\n\n## Performance Optimization\n\n### Lazy Loading for Photo Grids\n\n```swift\nstruct OptimizedPhotoGrid: View {\n    let photos: [Photo]\n\n    var body: some View {\n        ScrollView {\n            LazyVGrid(\n                columns: [\n                    GridItem(.adaptive(minimum: 150), spacing: 16)\n                ],\n                spacing: 16\n            ) {\n                ForEach(photos) { photo in\n                    AsyncImage(url: photo.thumbnailURL) { phase in\n                        switch phase {\n                        case .empty:\n                            // Placeholder glass card\n                            GlassCard {\n                                ProgressView()\n                            }\n                            .frame(height: 150)\n\n                        case .success(let image):\n                            image\n                                .resizable()\n                                .aspectRatio(contentMode: .fill)\n                                .frame(height: 150)\n                                .clipped()\n                                .clipShape(RoundedRectangle(cornerRadius: 12))\n\n                        case .failure:\n                            GlassCard {\n                                Image(systemName: \"photo.fill\")\n                                    .foregroundColor(.gray)\n                            }\n                            .frame(height: 150)\n\n                        @unknown default:\n                            EmptyView()\n                        }\n                    }\n                }\n            }\n            .padding()\n        }\n        .scrollIndicators(.hidden)  // Cleaner aesthetic\n    }\n}\n```\n\n### Drawing Group for Complex Glass\n\n```swift\nstruct OptimizedGlassStack: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            ForEach(0..<10) { index in\n                GlassCard {\n                    Text(\"Card \\(index)\")\n                }\n            }\n        }\n        .drawingGroup()  // Flatten into single texture (faster rendering)\n    }\n}\n```\n\n## Accessibility Considerations\n\n```swift\nstruct AccessibleGlassCard<Content: View>: View {\n    let content: Content\n    @Environment(\\.accessibilityReduceTransparency) var reduceTransparency\n\n    var body: some View {\n        content\n            .padding(20)\n            .background {\n                if reduceTransparency {\n                    // Solid background for accessibility\n                    RoundedRectangle(cornerRadius: 16)\n                        .fill(Color(.systemBackground).opacity(0.95))\n                } else {\n                    RoundedRectangle(cornerRadius: 16)\n                        .fill(.ultraThinMaterial)\n                }\n            }\n            .overlay(\n                RoundedRectangle(cornerRadius: 16)\n                    .stroke(Color.white.opacity(0.3), lineWidth: 1)\n            )\n    }\n}\n```\n\n## Why Glassmorphism for Photo Apps\n\n1. **Content-aware**: Photos visible through translucent UI\n2. **Adaptive**: Automatically adjusts to any photo color palette\n3. **Premium feel**: Modern, polished aesthetic\n4. **Better accessibility**: Superior contrast compared to neumorphism\n5. **System integration**: Uses iOS Material system for best performance\n"
        },
        {
          "name": "metal-shaders.md",
          "type": "file",
          "path": "vaporwave-glassomorphic-ui-designer/references/metal-shaders.md",
          "size": 11432,
          "content": "# Metal Shaders for Vaporwave Effects\n\nCustom Metal shaders for GPU-accelerated vaporwave and glass effects in SwiftUI.\n\n## Performance Optimization\n\n### Custom Blur Shader\n\n```metal\n#include <metal_stdlib>\nusing namespace metal;\n\n// Custom blur shader for glass effect\n// Faster than system blur for custom effects\nkernel void gaussianBlur(\n    texture2d<float, access::read> inputTexture [[texture(0)]],\n    texture2d<float, access::write> outputTexture [[texture(1)]],\n    constant float &blurRadius [[buffer(0)]],\n    uint2 gid [[thread_position_in_grid]]\n) {\n    float4 color = float4(0.0);\n    int radius = int(blurRadius);\n    float weightSum = 0.0;\n\n    for (int dy = -radius; dy <= radius; dy++) {\n        for (int dx = -radius; dx <= radius; dx++) {\n            uint2 samplePos = gid + uint2(dx, dy);\n\n            // Gaussian weight\n            float distance = sqrt(float(dx * dx + dy * dy));\n            float weight = exp(-(distance * distance) / (2.0 * blurRadius * blurRadius));\n\n            color += inputTexture.read(samplePos) * weight;\n            weightSum += weight;\n        }\n    }\n\n    outputTexture.write(color / weightSum, gid);\n}\n```\n\n### Animated Gradient Shader\n\n```metal\nfragment float4 vaporwaveGradient(\n    float2 uv [[point_coord]],\n    constant float &time [[buffer(0)]]\n) {\n    // Animated vaporwave gradient\n    float3 color1 = float3(1.0, 0.71, 0.95);  // Pink\n    float3 color2 = float3(0.49, 0.87, 1.0);  // Blue\n    float3 color3 = float3(0.71, 0.58, 1.0);  // Purple\n\n    // Animated wave pattern\n    float wave = sin(uv.x * 3.0 + time) * 0.5 + 0.5;\n    float wave2 = cos(uv.y * 2.0 - time * 0.5) * 0.5 + 0.5;\n\n    // Mix colors based on position and time\n    float3 color = mix(color1, color2, uv.y);\n    color = mix(color, color3, wave * wave2);\n\n    return float4(color, 1.0);\n}\n```\n\n## Vaporwave Grid Shader\n\n```metal\n#include <metal_stdlib>\nusing namespace metal;\n\n[[ stitchable ]] half4 vaporwaveGrid(\n    float2 position,\n    float time,\n    float2 size,\n    half4 currentColor\n) {\n    float2 uv = position / size;\n\n    // Create perspective grid effect\n    float perspectiveFactor = (1.0 - uv.y) * 2.0 + 0.5;\n    float2 gridUV = uv * float2(20.0, 30.0) * perspectiveFactor;\n\n    // Grid lines with glow\n    float gridX = abs(sin(gridUV.x * 3.14159));\n    float gridY = abs(sin(gridUV.y * 3.14159));\n\n    // Animated pulsing\n    float pulse = sin(time * 2.0) * 0.5 + 0.5;\n\n    // Cyan grid lines\n    float grid = step(0.95, max(gridX, gridY));\n    float3 gridColor = float3(0.0, 0.93, 1.0) * grid * (0.3 + pulse * 0.3);\n\n    // Pink horizontal lines (more prominent at bottom)\n    float horizStrength = smoothstep(0.3, 1.0, uv.y);\n    float horizGrid = step(0.98, gridY) * horizStrength;\n    float3 horizColor = float3(1.0, 0.23, 0.68) * horizGrid * 0.5;\n\n    // Combine with original color\n    float3 finalColor = float3(currentColor.rgb) + gridColor + horizColor;\n\n    return half4(half3(finalColor), currentColor.a);\n}\n```\n\n## Holographic Shimmer Effect\n\n```metal\n[[ stitchable ]] half4 holographicShimmer(\n    float2 position,\n    float time,\n    float2 size,\n    half4 currentColor\n) {\n    float2 uv = position / size;\n\n    // Rainbow shimmer that moves across surface\n    float shimmerPhase = uv.x * 10.0 + uv.y * 5.0 - time * 2.0;\n    float shimmer = sin(shimmerPhase) * 0.5 + 0.5;\n\n    // Create RGB chromatic aberration\n    float3 rainbow = float3(\n        sin(shimmerPhase) * 0.5 + 0.5,\n        sin(shimmerPhase + 2.0) * 0.5 + 0.5,\n        sin(shimmerPhase + 4.0) * 0.5 + 0.5\n    );\n\n    // Soft glow\n    float glow = shimmer * 0.3;\n\n    // Blend with original\n    float3 finalColor = mix(\n        float3(currentColor.rgb),\n        rainbow,\n        glow\n    );\n\n    return half4(half3(finalColor), currentColor.a);\n}\n```\n\n## Glass Refraction with Color Shift\n\n```metal\n[[ stitchable ]] half4 glassRefraction(\n    float2 position,\n    float time,\n    float2 size,\n    half4 currentColor,\n    texture2d<half> backgroundTexture\n) {\n    float2 uv = position / size;\n\n    // Animated distortion\n    float2 distortion = float2(\n        sin(uv.y * 10.0 + time) * 0.01,\n        cos(uv.x * 10.0 + time) * 0.01\n    );\n\n    // Sample background with distortion (refraction)\n    float2 refractUV = uv + distortion;\n    half4 refracted = backgroundTexture.sample(sampler(filter::linear), refractUV);\n\n    // Add chromatic aberration (RGB split)\n    half r = backgroundTexture.sample(sampler(filter::linear), refractUV + float2(0.002, 0)).r;\n    half g = refracted.g;\n    half b = backgroundTexture.sample(sampler(filter::linear), refractUV - float2(0.002, 0)).b;\n\n    half4 aberrated = half4(r, g, b, refracted.a);\n\n    // Mix with vaporwave tint\n    half3 vaporTint = half3(0.7, 0.58, 1.0); // Vaporwave purple\n    half3 tinted = mix(aberrated.rgb, vaporTint, 0.15);\n\n    // Blend with current glass material\n    half3 final = mix(currentColor.rgb, tinted, 0.3);\n\n    return half4(final, currentColor.a * 0.9);\n}\n```\n\n## Neon Glow Shader\n\n```metal\n[[ stitchable ]] half4 neonGlow(\n    float2 position,\n    float time,\n    float2 size,\n    half4 currentColor,\n    half3 glowColor,\n    float glowIntensity\n) {\n    float2 uv = position / size;\n    float2 center = float2(0.5, 0.5);\n\n    // Distance from edge\n    float distFromEdge = min(\n        min(uv.x, 1.0 - uv.x),\n        min(uv.y, 1.0 - uv.y)\n    );\n\n    // Edge glow\n    float edgeGlow = smoothstep(0.0, 0.1, distFromEdge);\n    edgeGlow = 1.0 - edgeGlow;\n\n    // Pulsing animation\n    float pulse = (sin(time * 3.0) * 0.5 + 0.5) * 0.3 + 0.7;\n\n    // Apply neon glow\n    half3 glow = half3(glowColor) * half(edgeGlow * pulse * glowIntensity);\n    half3 final = currentColor.rgb + glow;\n\n    return half4(final, currentColor.a);\n}\n```\n\n## SwiftUI Integration\n\n### Vaporwave Grid View\n\n```swift\nstruct VaporwaveGridView: View {\n    @State private var startTime = Date()\n\n    var body: some View {\n        TimelineView(.animation) { timeline in\n            Rectangle()\n                .fill(.ultraThinMaterial)\n                .visualEffect { content, proxy in\n                    content\n                        .colorEffect(\n                            ShaderLibrary.vaporwaveGrid(\n                                .float(timeline.date.timeIntervalSince(startTime)),\n                                .float2(proxy.size)\n                            )\n                        )\n                }\n        }\n    }\n}\n```\n\n### Holographic Button\n\n```swift\nstruct HolographicButton: View {\n    let title: String\n    let action: () -> Void\n    @State private var startTime = Date()\n\n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .font(.vaporwaveBody)\n                .padding(.horizontal, 32)\n                .padding(.vertical, 16)\n        }\n        .background(\n            TimelineView(.animation) { timeline in\n                RoundedRectangle(cornerRadius: 12)\n                    .fill(.regularMaterial)\n                    .visualEffect { content, proxy in\n                        content\n                            .colorEffect(\n                                ShaderLibrary.holographicShimmer(\n                                    .float(timeline.date.timeIntervalSince(startTime)),\n                                    .float2(proxy.size)\n                                )\n                            )\n                    }\n            }\n        )\n        .overlay(\n            RoundedRectangle(cornerRadius: 12)\n                .stroke(\n                    LinearGradient(\n                        colors: [.vaporwavePink, .vaporwaveCyan],\n                        startPoint: .topLeading,\n                        endPoint: .bottomTrailing\n                    ),\n                    lineWidth: 2\n                )\n        )\n    }\n}\n```\n\n### Neon Glass Card\n\n```swift\nstruct NeonGlassCard<Content: View>: View {\n    let content: Content\n    let glowColor: Color\n    @State private var startTime = Date()\n\n    init(glowColor: Color = .vaporwaveCyan, @ViewBuilder content: () -> Content) {\n        self.glowColor = glowColor\n        self.content = content()\n    }\n\n    var body: some View {\n        TimelineView(.animation) { timeline in\n            content\n                .padding(20)\n                .background(.ultraThinMaterial)\n                .clipShape(RoundedRectangle(cornerRadius: 16))\n                .visualEffect { content, proxy in\n                    content\n                        .colorEffect(\n                            ShaderLibrary.neonGlow(\n                                .float(timeline.date.timeIntervalSince(startTime)),\n                                .float2(proxy.size),\n                                .color(glowColor),\n                                .float(0.8)\n                            )\n                        )\n                }\n        }\n    }\n}\n```\n\n### Metal Background Integration\n\n```swift\nstruct MetalVaporwaveBackground: View {\n    @State private var time: Float = 0.0\n    let timer = Timer.publish(every: 0.016, on: .main, in: .common).autoconnect()  // 60fps\n\n    var body: some View {\n        TimelineView(.animation) { timeline in\n            Canvas { context, size in\n                // Render using Metal shader\n                // (Actual Metal integration requires MetalKit setup)\n            }\n        }\n        .onReceive(timer) { _ in\n            time += 0.016\n        }\n    }\n}\n```\n\n## Performance Tips\n\n### Optimization Guidelines\n\n1. **Simplify Calculations**: Keep shader math simple\n   - Avoid complex trigonometry in every pixel\n   - Precompute values when possible\n   - Use lookup tables for repeated calculations\n\n2. **Limit Texture Samples**: Each sample is expensive\n   - Minimize blur radius\n   - Use mipmaps for distant samples\n   - Cache frequently sampled regions\n\n3. **Conditional Execution**: Minimize branching\n   - Use `smoothstep` instead of `if` statements\n   - Blend values rather than choosing\n   - Keep code path consistent\n\n4. **Resolution Awareness**: Adapt to device\n   ```swift\n   let isHighPerformanceDevice = UIDevice.current.userInterfaceIdiom == .pad\n   let blurSamples = isHighPerformanceDevice ? 20 : 10\n   ```\n\n5. **FPS Monitoring**: Test on real devices\n   ```swift\n   @State private var fps: Double = 60.0\n\n   var body: some View {\n       content\n           .onReceive(NotificationCenter.default.publisher(\n               for: UIApplication.didBecomeActiveNotification\n           )) { _ in\n               // Start FPS monitoring\n               CADisplayLink.monitorFrameRate { fps in\n                   self.fps = fps\n               }\n           }\n   }\n   ```\n\n## Shader Resources\n\n### Learning Metal Shaders\n- **Metal by Example**: Practical Metal shader guide\n- **The Book of Shaders**: GLSL fundamentals (translates to Metal)\n- **Apple WWDC Sessions**: Official Metal shader workshops\n- **Shadertoy**: Experiment with similar GLSL techniques\n\n### Tools\n- **Xcode Metal Debugger**: Profile shader performance\n- **RenderDoc**: Capture and analyze frames\n- **Metal System Trace**: Identify bottlenecks\n\n### When to Use Custom Shaders\n\n**Good candidates:**\n- Unique ambient backgrounds\n- Loading state animations\n- Transition effects\n- Glass/glassmorphism effects\n- Particle systems\n- Data visualizations\n\n**Avoid shaders for:**\n- Simple color changes (use CSS/SwiftUI)\n- Basic animations (use native animations)\n- Text rendering (performance issues)\n- Simple gradients (native is better)\n"
        },
        {
          "name": "vaporwave-aesthetic.md",
          "type": "file",
          "path": "vaporwave-glassomorphic-ui-designer/references/vaporwave-aesthetic.md",
          "size": 11027,
          "content": "# Vaporwave Aesthetic System\n\nComplete color palettes, typography, and visual elements for vaporwave-inspired UI.\n\n## Color Palette System\n\n### Primary Neon Pastels\n\n```swift\nextension Color {\n    // Vaporwave Core Palette (2025)\n    static let vaporwavePink = Color(red: 1.0, green: 0.71, blue: 0.95)      // #FFAFEF\n    static let vaporwaveBlue = Color(red: 0.49, green: 0.87, blue: 1.0)      // #7DE0FF\n    static let vaporwavePurple = Color(red: 0.71, green: 0.58, blue: 1.0)    // #B595FF\n    static let vaporwaveMint = Color(red: 0.67, green: 1.0, blue: 0.89)      // #ABFFE3\n    static let vaporwaveOrange = Color(red: 1.0, green: 0.77, blue: 0.54)    // #FFC48A\n\n    // Accent Colors (Higher Saturation)\n    static let vaporwaveHotPink = Color(red: 1.0, green: 0.23, blue: 0.68)   // #FF3BAE\n    static let vaporwaveCyan = Color(red: 0.0, green: 0.93, blue: 1.0)       // #00EDFF\n\n    // Neutral Base\n    static let vaporwaveCharcoal = Color(red: 0.18, green: 0.18, blue: 0.22) // #2E2E38\n    static let vaporwaveIvory = Color(red: 0.98, green: 0.96, blue: 0.93)    // #FAF5ED\n}\n```\n\n### Gradient Combinations\n\n```swift\n// Sunset Dream\nlet sunsetGradient = LinearGradient(\n    colors: [.vaporwavePink, .vaporwaveOrange, .vaporwavePurple],\n    startPoint: .topLeading,\n    endPoint: .bottomTrailing\n)\n\n// Cyber Ocean\nlet cyberOceanGradient = LinearGradient(\n    colors: [.vaporwaveBlue, .vaporwaveCyan, .vaporwaveMint],\n    startPoint: .top,\n    endPoint: .bottom\n)\n\n// Twilight Zone\nlet twilightGradient = LinearGradient(\n    colors: [.vaporwavePurple, .vaporwaveBlue, .vaporwavePink],\n    startPoint: .topTrailing,\n    endPoint: .bottomLeading\n)\n\n// Pastel Candy\nlet candyGradient = LinearGradient(\n    colors: [\n        .vaporwaveMint,\n        .vaporwaveBlue.opacity(0.7),\n        .vaporwavePink.opacity(0.6)\n    ],\n    startPoint: .leading,\n    endPoint: .trailing\n)\n```\n\n### Dynamic Theming System\n\n```swift\nstruct VaporwaveTheme {\n    let primary: Color\n    let secondary: Color\n    let accent: Color\n    let background: LinearGradient\n\n    static let sunsetDream = VaporwaveTheme(\n        primary: .vaporwavePink,\n        secondary: .vaporwaveOrange,\n        accent: .vaporwaveHotPink,\n        background: LinearGradient(\n            colors: [\n                Color.vaporwavePurple.opacity(0.2),\n                Color.vaporwaveOrange.opacity(0.1)\n            ],\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    )\n\n    static let cyberNight = VaporwaveTheme(\n        primary: .vaporwaveBlue,\n        secondary: .vaporwavePurple,\n        accent: .vaporwaveCyan,\n        background: LinearGradient(\n            colors: [\n                Color.vaporwaveCharcoal,\n                Color.vaporwavePurple.opacity(0.3)\n            ],\n            startPoint: .top,\n            endPoint: .bottom\n        )\n    )\n}\n```\n\n### Theme Manager\n\n```swift\nclass VaporwaveThemeManager: ObservableObject {\n    @Published var currentTheme: VaporwaveTheme = .sunsetDream\n\n    enum ThemePreference: String, CaseIterable {\n        case sunsetDream = \"Sunset Dream\"\n        case cyberNight = \"Cyber Night\"\n        case pastelCandy = \"Pastel Candy\"\n        case auto = \"Auto (Match Photos)\"\n\n        var theme: VaporwaveTheme {\n            switch self {\n            case .sunsetDream: return .sunsetDream\n            case .cyberNight: return .cyberNight\n            case .pastelCandy: return .init(/* ... */)\n            case .auto: return .sunsetDream  // Will adapt to photo colors\n            }\n        }\n    }\n\n    func setTheme(_ preference: ThemePreference) {\n        withAnimation(.easeInOut(duration: 0.8)) {\n            currentTheme = preference.theme\n        }\n    }\n\n    func adaptToPhotoPalette(_ colors: [Color]) {\n        // Extract dominant colors from photo and create matching theme\n        let averageHue = colors.map { $0.hue }.reduce(0, +) / Double(colors.count)\n        // Generate complementary vaporwave palette\n    }\n}\n```\n\n## Typography System\n\n### Font Definitions\n\n```swift\nextension Font {\n    // Headers: Bold, wide tracking for that 80s computer feel\n    static let vaporwaveTitle = Font.system(\n        size: 32,\n        weight: .black,\n        design: .rounded  // Softer than default\n    ).width(.expanded)    // Wide tracking\n\n    // Body: Clean, readable\n    static let vaporwaveBody = Font.system(\n        size: 16,\n        weight: .medium,\n        design: .rounded\n    )\n\n    // Captions: Small, mono for that terminal aesthetic\n    static let vaporwaveCaption = Font.system(\n        size: 12,\n        weight: .regular,\n        design: .monospaced\n    )\n}\n```\n\n### Text Effects\n\n```swift\nstruct VaporwaveText: View {\n    let text: String\n\n    var body: some View {\n        Text(text)\n            .font(.vaporwaveTitle)\n            .foregroundStyle(\n                LinearGradient(\n                    colors: [.vaporwavePink, .vaporwaveCyan],\n                    startPoint: .leading,\n                    endPoint: .trailing\n                )\n            )\n            // Outline effect (vaporwave staple)\n            .shadow(color: .vaporwavePurple, radius: 0, x: -2, y: -2)\n            .shadow(color: .vaporwaveCyan, radius: 0, x: 2, y: 2)\n            .shadow(color: .black.opacity(0.5), radius: 10, y: 5)\n    }\n}\n```\n\n## Visual Elements\n\n### Retro Grid Background\n\n```swift\nstruct VaporwaveGrid: View {\n    var body: some View {\n        GeometryReader { geometry in\n            Canvas { context, size in\n                let spacing: CGFloat = 40\n\n                // Horizontal lines (perspective grid)\n                for i in stride(from: 0, through: size.height, by: spacing) {\n                    let progress = i / size.height\n                    let lineWidth = 1 + (progress * 2)  // Thicker at bottom (perspective)\n\n                    var path = Path()\n                    path.move(to: CGPoint(x: 0, y: i))\n                    path.addLine(to: CGPoint(x: size.width, y: i))\n\n                    context.stroke(\n                        path,\n                        with: .color(.vaporwaveCyan.opacity(0.3 + progress * 0.3)),\n                        lineWidth: lineWidth\n                    )\n                }\n\n                // Vertical lines (converging to horizon)\n                let horizonY = size.height * 0.3\n                let vanishingPointX = size.width / 2\n\n                for x in stride(from: 0, through: size.width, by: spacing) {\n                    var path = Path()\n                    path.move(to: CGPoint(x: x, y: size.height))\n                    path.addLine(to: CGPoint(x: vanishingPointX, y: horizonY))\n\n                    context.stroke(\n                        path,\n                        with: .color(.vaporwavePink.opacity(0.4)),\n                        lineWidth: 1\n                    )\n                }\n            }\n        }\n        .background(\n            LinearGradient(\n                colors: [\n                    .vaporwavePurple.opacity(0.3),\n                    .vaporwaveCharcoal\n                ],\n                startPoint: .top,\n                endPoint: .bottom\n            )\n        )\n    }\n}\n```\n\n### Scan Lines Effect\n\n```swift\nstruct ScanLines: View {\n    var body: some View {\n        GeometryReader { geometry in\n            Canvas { context, size in\n                for y in stride(from: 0, through: size.height, by: 4) {\n                    var path = Path()\n                    path.move(to: CGPoint(x: 0, y: y))\n                    path.addLine(to: CGPoint(x: size.width, y: y))\n\n                    context.stroke(\n                        path,\n                        with: .color(.black.opacity(0.1)),\n                        lineWidth: 2\n                    )\n                }\n            }\n        }\n        .allowsHitTesting(false)  // Pass through touches\n    }\n}\n```\n\n### Sun/Moon Shape\n\n```swift\nstruct VaporwaveSun: View {\n    var body: some View {\n        ZStack {\n            // Sun disc\n            Circle()\n                .fill(\n                    LinearGradient(\n                        colors: [\n                            .vaporwavePink,\n                            .vaporwaveOrange,\n                            .vaporwaveHotPink\n                        ],\n                        startPoint: .top,\n                        endPoint: .bottom\n                    )\n                )\n                .frame(width: 200, height: 200)\n\n            // Horizontal stripes (retrowave sun effect)\n            ForEach(0..<10) { i in\n                Rectangle()\n                    .fill(Color.vaporwaveCharcoal)\n                    .frame(height: 3)\n                    .offset(y: CGFloat(i) * 15 + 40)\n            }\n            .clipShape(Circle())\n        }\n    }\n}\n```\n\n## 2025 Vaporwave Evolution\n\n### Historical Context\n\n**Original Vaporwave (2010-2015):**\n- Critique of consumerism and nostalgia\n- 80s/90s mall aesthetic, early internet imagery\n- Deliberately glitchy, surreal, melancholic\n- Greco-Roman statues, Japanese text, palm trees\n\n**2025 Modern Interpretation:**\n- Softer, more accessible (Y2K revival influence)\n- Neon pastels over harsh synthwave colors\n- Cleaner execution (less glitch, more polish)\n- Nostalgic but optimistic\n- Dreamlike, not dystopian\n\n### Design Philosophy\n\n> \"Make it feel like a dreamlike memory itself.\" - Design Principle for Photo Apps\n\nWhen designing for photo applications:\n1. **Evoke Emotion** - Nostalgia, joy, wonder through color and motion\n2. **Respect Content** - Photos are the hero, UI supports not competes\n3. **Enable Flow** - Frictionless creation, experimentation, sharing\n4. **Delight Constantly** - Micro-interactions, surprises, polish\n5. **Perform Flawlessly** - 60fps animations, instant feedback, GPU-optimized\n\n### Contextual Design\n\n```swift\nstruct ContextualDesign: View {\n    let photoCount: Int\n    @Environment(\\.colorScheme) var colorScheme\n    @Environment(\\.sizeCategory) var sizeCategory\n\n    var body: some View {\n        ZStack {\n            // Busy library (1000+ photos) = Calmer design\n            if photoCount > 1000 {\n                // Minimal vaporwave (less overwhelming)\n                LinearGradient(\n                    colors: [\n                        Color.vaporwaveIvory,\n                        Color.vaporwaveMint.opacity(0.2)\n                    ],\n                    startPoint: .top,\n                    endPoint: .bottom\n                )\n            } else {\n                // Smaller library = More expressive design\n                VaporwaveTheme.sunsetDream.background\n            }\n\n            // UI adapts to context\n            ContentView()\n        }\n    }\n}\n```\n\n## Color Psychology for Photo Apps\n\n| Color | Emotion | Use Case |\n|-------|---------|----------|\n| Pink | Warmth, nostalgia | Memory browsing, love-themed collections |\n| Cyan | Energy, freshness | Action buttons, new content |\n| Purple | Creativity, mystery | Creation tools, AI features |\n| Mint | Calm, growth | Success states, collections |\n| Orange | Joy, playfulness | Celebrations, highlights |\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "vaporwave-glassomorphic-ui-designer/CHANGELOG.md",
      "size": 3007,
      "content": "# Changelog\n\nAll notable changes to the vaporwave-glassomorphic-ui-designer skill will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [2.0.0] - 2025-11-26\n\n### Changed\n- **BREAKING**: Refactored from single 1586-line file to modular structure\n- Reduced SKILL.md from 1586 lines to 185 lines (88% reduction)\n- Moved detailed code patterns to `/references/` directory\n- Updated frontmatter to standard `allowed-tools` format\n- Simplified description with proper NOT clause and activation keywords\n\n### Added\n- **When to Use This Skill** section with clear scope boundaries\n- **Do NOT use for** section with skill alternatives\n- **MCP Integrations** section with workflow guidance\n- Created `/references/glassmorphism-patterns.md`:\n  - GlassCard component with variants (thin, regular, thick, neon)\n  - Material hierarchy guide\n  - Adaptive glass for dark/light mode\n  - Performance optimization (LazyVGrid, drawingGroup)\n  - Accessibility considerations (reduceTransparency)\n- Created `/references/vaporwave-aesthetic.md`:\n  - Complete color palette system (6 primary colors)\n  - Gradient presets (Sunset Dream, Cyber Ocean, Twilight Zone, Pastel Candy)\n  - Typography system (title, body, caption fonts)\n  - VaporwaveTheme and ThemeManager implementations\n  - Visual elements (grid background, scan lines, sun shape)\n  - 2025 design philosophy evolution\n- Created `/references/animations-interactions.md`:\n  - Button styles (bouncy neon, glass, variants)\n  - Staggered list and grid animations\n  - Glow effects (pulsing, reactive)\n  - Page transitions (dreamy dissolve, sliding panels)\n  - Spring physics cheat sheet\n  - Animation timing guidelines\n- Created `/references/metal-shaders.md`:\n  - Gaussian blur shader\n  - Animated vaporwave gradient\n  - Vaporwave grid shader\n  - Holographic shimmer effect\n  - Glass refraction with color shift\n  - Neon glow shader\n  - SwiftUI shader integration examples\n  - Performance optimization tips\n\n### Removed\n- Custom YAML frontmatter format (tools, triggers, integrates_with)\n- Extensive inline SwiftUI code examples (moved to references)\n- Detailed shader implementations (moved to references)\n- Redundant 21st Century Dev usage section (condensed)\n\n### Improved\n- Progressive disclosure: essential concepts in SKILL.md, full code in references\n- Cross-references to related skills (windows-3-1, native-app, web-design, design-system)\n- Color system condensed to quick-reference table\n- Animation timing as actionable table\n\n## [1.0.0] - 2024-XX-XX\n\n### Added\n- Initial vaporwave-glassomorphic-ui-designer skill\n- Glassmorphism patterns for SwiftUI\n- Vaporwave color palettes and gradients\n- Typography system\n- Grid and scan line visual elements\n- Micro-interactions and button styles\n- Metal shader examples\n- 21st Century Dev integration\n- Dark mode and accessibility support\n- Photo app design guidelines\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "vaporwave-glassomorphic-ui-designer/SKILL.md",
      "size": 7775,
      "content": "---\nname: vaporwave-glassomorphic-ui-designer\ndescription: Expert in creating modern, aesthetic UI designs blending vaporwave nostalgia with glassomorphic elegance for photo/memory applications. Masters SwiftUI Material effects, neon pastel color palettes, frosted glass blur techniques, and retro-futuristic design principles. Specializes in creating emotionally resonant interfaces for photo collage apps with dark mode support, accessibility-first design, and GPU-accelerated Metal shader effects. Deep knowledge of 2025 UI trends (glassmorphism, neubrutalism, Y2K revival), iOS Human Interface Guidelines, and creating delightful micro-interactions. Bridges computational aesthetics with human emotional connection through thoughtful color theory, typography, and spatial design. Use for iOS/Mac photo apps, vaporwave-themed UI, glassmorphic components, neon/retro aesthetics. Activate on \"vaporwave\", \"glassmorphism\", \"SwiftUI design\", \"frosted glass\", \"neon aesthetic\", \"retro-futuristic\", \"Y2K design\". NOT for backend logic, API design (use backend-architect), Windows 3.1 authentic retro (use windows-3-1-web-designer), generic web design (use web-design-expert), or non-photo app UI (use native-app-designer).\nallowed-tools: Read,Write,Edit,mcp__magic__21st_magic_component_builder,mcp__magic__21st_magic_component_refiner,mcp__magic__21st_magic_component_inspiration,mcp__stability-ai__stability-ai-generate-image,mcp__firecrawl__firecrawl_search,WebFetch\n---\n\n# Vaporwave & Glassomorphic UI Designer\n\nElite UI/UX designer specializing in **vaporwave-inspired and glassomorphic aesthetics** for photo and memory applicationswhere nostalgia meets futurism.\n\n## When to Use This Skill\n\n **Use for:**\n- iOS/Mac photo and memory applications\n- Vaporwave-themed UI with neon pastels\n- Glassmorphic components (frosted glass cards, panels)\n- Retro-futuristic and Y2K revival aesthetics\n- Metal shader effects for unique visuals\n- Photo app empty states, onboarding, celebrations\n- Combining glass effects with vaporwave gradients\n\n **Do NOT use for:**\n- Backend API logic  use **backend-architect**\n- Authentic Windows 3.1 retro  use **windows-3-1-web-designer**\n- Generic web design  use **web-design-expert**\n- Non-photo app native UI  use **native-app-designer**\n- Design system tokens only  use **design-system-creator**\n\n## MCP Integrations\n\n### Available MCPs\n\n| MCP | Purpose |\n|-----|---------|\n| **21st Century Dev** | Component inspiration, building, and refinement |\n| **Stability AI** | Generate design mockups and assets |\n| **Firecrawl** | Research 2025 UI trends and patterns |\n| **WebFetch** | Access Apple HIG documentation |\n\n### Design Discovery Workflow\n```\n1. Query 21st.dev: \"glassmorphic modal with blur\"\n2. Study modern trends (blur levels, gradients, timings)\n3. Adapt for vaporwave (neon pastels, scan lines, glow)\n4. Build custom: mix patterns, add shaders, signature animations\n```\n\n## Core Philosophy\n\n> **\"Make it feel like a dreamlike memory itself.\"** - Design Principle for Photo Apps\n\n1. **Evoke Emotion** - Nostalgia, joy, wonder through color and motion\n2. **Respect Content** - Photos are the hero, UI supports not competes\n3. **Enable Flow** - Frictionless creation, experimentation, sharing\n4. **Delight Constantly** - Micro-interactions, surprises, polish\n5. **Perform Flawlessly** - 60fps animations, instant feedback, GPU-optimized\n\n## Glassmorphism Essentials\n\n**The 2025 Standard for Photo Apps:**\n- Semi-transparent backgrounds with blur (frosted glass appearance)\n- Subtle borders with multi-layer depth\n- Photos visible through translucent UI (content-aware)\n- Excellent accessibility vs. neumorphism's low contrast\n\n### Material Hierarchy (SwiftUI)\n```swift\n.background(.ultraThinMaterial)    // Floating panels (most transparent)\n.background(.thinMaterial)         // Toolbars\n.background(.regularMaterial)      // Sheets, modals\n.background(.thickMaterial)        // Backgrounds\n.background(.ultraThickMaterial)   // Critical UI (most opaque)\n```\n\n**Selection criteria:** Critical UI = thicker, foreground = thinner, text-heavy = thicker\n\n## Vaporwave Color System\n\n### Primary Neon Pastels\n| Color | Hex | Swift |\n|-------|-----|-------|\n| Pink | #FFAFEF | `Color(red: 1.0, green: 0.71, blue: 0.95)` |\n| Blue | #7DE0FF | `Color(red: 0.49, green: 0.87, blue: 1.0)` |\n| Purple | #B595FF | `Color(red: 0.71, green: 0.58, blue: 1.0)` |\n| Mint | #ABFFE3 | `Color(red: 0.67, green: 1.0, blue: 0.89)` |\n| Hot Pink | #FF3BAE | `Color(red: 1.0, green: 0.23, blue: 0.68)` |\n| Cyan | #00EDFF | `Color(red: 0.0, green: 0.93, blue: 1.0)` |\n\n### Gradient Presets\n- **Sunset Dream**: Pink  Orange  Purple\n- **Cyber Ocean**: Blue  Cyan  Mint\n- **Twilight Zone**: Purple  Blue  Pink\n- **Pastel Candy**: Mint  Blue  Pink (soft)\n\n## Typography Guidelines\n\n```swift\n// Headers: Bold, wide tracking (80s computer feel)\n.font(.system(size: 32, weight: .black, design: .rounded).width(.expanded))\n\n// Body: Clean, readable\n.font(.system(size: 16, weight: .medium, design: .rounded))\n\n// Captions: Terminal aesthetic\n.font(.system(size: 12, weight: .regular, design: .monospaced))\n```\n\n## Animation Timing\n\n| Category | Duration | Use Case |\n|----------|----------|----------|\n| Immediate | 0-100ms | Button press, tap feedback |\n| Quick | 150-300ms | Navigation, page changes |\n| Deliberate | 300-500ms | Onboarding, reveals |\n| Dramatic | 500-1000ms | Celebrations, achievements |\n\n### Spring Physics Presets\n```swift\n.spring(response: 0.3, dampingFraction: 0.7)  // Snappy\n.spring(response: 0.5, dampingFraction: 0.5)  // Bouncy\n.spring(response: 0.6, dampingFraction: 0.8)  // Smooth\n.spring(response: 0.8, dampingFraction: 0.6)  // Dramatic\n```\n\n## Expertise in Action\n\nWhen designing UI for photo/memory apps:\n\n1. **Assess User Emotional State**\n   - First collage?  Warm palette (sunset dream)\n   - Power user?  Clean glass panels\n   - Nostalgic browsing?  Softer vaporwave, slower animations\n\n2. **Choose Visual Strategy**\n   - Heavy photo content  Minimal UI, glass panels\n   - Empty states / onboarding  Full vaporwave, expressive\n   - Settings / technical  Clean glass, less decoration\n\n3. **Implement Responsibly**\n   - Always support dark mode\n   - Test with accessibility settings (reduce transparency)\n   - Use system materials (better performance)\n   - Animate at 60fps or don't animate\n\n4. **Balance Aesthetics with Usability**\n   - Glass is beautiful but ensure text is readable (WCAG AA)\n   - Vaporwave colors are fun but don't distract from photos\n   - Animations delight but respect reduced motion\n\n5. **Optimize for Platform**\n   - Use Metal for custom effects\n   - Leverage SwiftUI's Material system\n   - Lazy load images in grids\n   - Cache rendered glass panels\n\n## Accessibility Considerations\n\n```swift\n// Respect reduce transparency preference\n@Environment(\\.accessibilityReduceTransparency) var reduceTransparency\n\n// Respect reduce motion preference\n@Environment(\\.accessibilityReduceMotion) var reduceMotion\n\n// Provide solid fallbacks when needed\nif reduceTransparency {\n    RoundedRectangle(cornerRadius: 16)\n        .fill(Color(.systemBackground).opacity(0.95))\n} else {\n    RoundedRectangle(cornerRadius: 16)\n        .fill(.ultraThinMaterial)\n}\n```\n\n---\n\n**Technical references for deep dives:**\n- `/references/glassmorphism-patterns.md` - SwiftUI glass cards, materials, adaptive components\n- `/references/vaporwave-aesthetic.md` - Color palettes, typography, visual elements, themes\n- `/references/animations-interactions.md` - Button styles, staggered animations, glow effects\n- `/references/metal-shaders.md` - Custom Metal shaders for vaporwave grid, holographic, neon glow\n\n---\n\n*Make it dreamlike. Make it delightful. Make it theirs.*\n"
    }
  ]
}