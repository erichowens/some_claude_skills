{
  "name": "frontend-architect",
  "type": "folder",
  "path": "frontend-architect",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "frontend-architect/references",
      "children": [
        {
          "name": "cloudflare-patterns.md",
          "type": "file",
          "path": "frontend-architect/references/cloudflare-patterns.md",
          "size": 9186,
          "content": "# Advanced Cloudflare Patterns\n\nDeep dive into Cloudflare Pages and Workers patterns for frontend applications.\n\n## OpenNext for Next.js on Cloudflare\n\nNext.js on Cloudflare Pages requires OpenNext adapter:\n\n### Setup\n\n```bash\nnpm install @opennext/cloudflare\n```\n\n### open-next.config.ts\n\n```typescript\nimport type { OpenNextConfig } from \"@opennextjs/cloudflare\";\n\nconst config: OpenNextConfig = {\n  default: {\n    override: {\n      wrapper: \"cloudflare-node\",\n      converter: \"edge\",\n      // Use for KV caching\n      incrementalCache: async () => (await import(\"./cache.mjs\")).default,\n    },\n  },\n};\n\nexport default config;\n```\n\n### Build and Deploy\n\n```bash\n# Build with OpenNext\nnpx @opennext/cloudflare build\n\n# Deploy\nnpx wrangler pages deploy .open-next\n```\n\n---\n\n## Multi-Environment Setup\n\n### wrangler.toml\n\n```toml\nname = \"my-app\"\ncompatibility_date = \"2026-01-31\"\n\n# Production\n[env.production]\nvars = { ENVIRONMENT = \"production\" }\nroutes = [{ pattern = \"app.example.com/*\", zone_name = \"example.com\" }]\n\n# Staging\n[env.staging]\nvars = { ENVIRONMENT = \"staging\" }\nroutes = [{ pattern = \"staging.example.com/*\", zone_name = \"example.com\" }]\n\n# Preview (default for branch deploys)\n[vars]\nENVIRONMENT = \"preview\"\n```\n\n### Deploy Commands\n\n```bash\n# Deploy to production\nnpx wrangler pages deploy .open-next --env production\n\n# Deploy to staging\nnpx wrangler pages deploy .open-next --env staging\n\n# Deploy preview (automatic on PR)\nnpx wrangler pages deploy .open-next\n```\n\n---\n\n## Caching Patterns\n\n### KV-Based ISR Cache\n\n```typescript\n// cache.mjs\nimport { KVNamespace } from \"@cloudflare/workers-types\";\n\nexport default class CloudflareKVCache {\n  private kv: KVNamespace;\n\n  constructor(kv: KVNamespace) {\n    this.kv = kv;\n  }\n\n  async get(key: string) {\n    const value = await this.kv.get(key, \"json\");\n    if (!value) return null;\n    return value;\n  }\n\n  async set(key: string, value: any, options?: { ttl?: number }) {\n    await this.kv.put(key, JSON.stringify(value), {\n      expirationTtl: options?.ttl || 86400,\n    });\n  }\n\n  async delete(key: string) {\n    await this.kv.delete(key);\n  }\n}\n```\n\n### Edge Caching with Cache API\n\n```typescript\n// functions/_middleware.ts\nexport async function onRequest(context: EventContext<Env, string, unknown>) {\n  const cache = caches.default;\n  const cacheKey = new Request(context.request.url, context.request);\n\n  // Check cache first\n  let response = await cache.match(cacheKey);\n\n  if (response) {\n    // Add cache hit header\n    response = new Response(response.body, response);\n    response.headers.set(\"X-Cache\", \"HIT\");\n    return response;\n  }\n\n  // Get fresh response\n  response = await context.next();\n\n  // Cache if cacheable\n  if (response.status === 200) {\n    const responseToCache = new Response(response.body, response);\n    responseToCache.headers.set(\"Cache-Control\", \"public, max-age=3600\");\n\n    context.waitUntil(cache.put(cacheKey, responseToCache.clone()));\n\n    responseToCache.headers.set(\"X-Cache\", \"MISS\");\n    return responseToCache;\n  }\n\n  return response;\n}\n```\n\n---\n\n## Authentication Patterns\n\n### Cloudflare Access Integration\n\n```typescript\n// lib/auth.ts\nexport function getAccessEmail(request: Request): string | null {\n  // Cloudflare Access sets this header\n  return request.headers.get(\"Cf-Access-Authenticated-User-Email\");\n}\n\nexport function getAccessIdentity(request: Request): string | null {\n  // JWT from Access\n  return request.headers.get(\"Cf-Access-Jwt-Assertion\");\n}\n\n// In your middleware or API route\nexport async function onRequest(context: EventContext<Env, string, unknown>) {\n  const email = getAccessEmail(context.request);\n\n  if (!email) {\n    return new Response(\"Unauthorized\", { status: 401 });\n  }\n\n  // Check if user is allowed\n  const allowedEmails = (context.env.ALLOWED_EMAILS || \"\").split(\",\");\n  if (!allowedEmails.includes(email)) {\n    return new Response(\"Forbidden\", { status: 403 });\n  }\n\n  return context.next();\n}\n```\n\n### Setting Up Cloudflare Access\n\n1. Go to Zero Trust dashboard\n2. Create an Access Application\n3. Set application domain (e.g., `internal.example.com`)\n4. Configure identity providers (GitHub, Google, etc.)\n5. Create Access policies (email domain, specific emails, etc.)\n\n---\n\n## Image Optimization\n\n### Using Cloudflare Images\n\n```typescript\n// lib/images.ts\nexport function getOptimizedUrl(\n  imageUrl: string,\n  options: {\n    width?: number;\n    height?: number;\n    fit?: \"contain\" | \"cover\" | \"crop\" | \"pad\";\n    quality?: number;\n  }\n): string {\n  const params = new URLSearchParams();\n\n  if (options.width) params.set(\"w\", String(options.width));\n  if (options.height) params.set(\"h\", String(options.height));\n  if (options.fit) params.set(\"fit\", options.fit);\n  if (options.quality) params.set(\"q\", String(options.quality));\n\n  // Cloudflare Images transform URL\n  return `https://imagedelivery.net/${ACCOUNT_ID}/${imageUrl}/public?${params}`;\n}\n```\n\n### next/image with Cloudflare\n\n```typescript\n// next.config.js\nmodule.exports = {\n  images: {\n    loader: \"custom\",\n    loaderFile: \"./lib/cloudflare-image-loader.ts\",\n  },\n};\n\n// lib/cloudflare-image-loader.ts\nexport default function cloudflareLoader({\n  src,\n  width,\n  quality,\n}: {\n  src: string;\n  width: number;\n  quality?: number;\n}) {\n  const params = [`width=${width}`];\n  if (quality) params.push(`quality=${quality}`);\n\n  // Using Cloudflare Image Resizing\n  return `https://your-domain.com/cdn-cgi/image/${params.join(\",\")}/${src}`;\n}\n```\n\n---\n\n## A/B Testing at Edge\n\n```typescript\n// functions/_middleware.ts\nconst EXPERIMENT_COOKIE = \"experiment_variant\";\n\nexport async function onRequest(context: EventContext<Env, string, unknown>) {\n  const request = context.request;\n  const url = new URL(request.url);\n\n  // Only run experiment on specific paths\n  if (!url.pathname.startsWith(\"/pricing\")) {\n    return context.next();\n  }\n\n  // Get or assign variant\n  const cookies = request.headers.get(\"Cookie\") || \"\";\n  let variant = getCookie(cookies, EXPERIMENT_COOKIE);\n\n  if (!variant) {\n    // 50/50 split\n    variant = Math.random() < 0.5 ? \"control\" : \"variant\";\n  }\n\n  // Rewrite to variant\n  const response = await context.next();\n\n  // Set cookie for consistency\n  if (!getCookie(cookies, EXPERIMENT_COOKIE)) {\n    const newResponse = new Response(response.body, response);\n    newResponse.headers.append(\n      \"Set-Cookie\",\n      `${EXPERIMENT_COOKIE}=${variant}; Path=/; Max-Age=86400`\n    );\n    return newResponse;\n  }\n\n  return response;\n}\n\nfunction getCookie(cookies: string, name: string): string | null {\n  const match = cookies.match(new RegExp(`${name}=([^;]+)`));\n  return match ? match[1] : null;\n}\n```\n\n---\n\n## Analytics at Edge\n\n```typescript\n// functions/_middleware.ts\nexport async function onRequest(context: EventContext<Env, string, unknown>) {\n  const start = Date.now();\n  const response = await context.next();\n  const duration = Date.now() - start;\n\n  // Log to Analytics Engine (Cloudflare)\n  context.waitUntil(\n    context.env.ANALYTICS.writeDataPoint({\n      blobs: [context.request.url, context.request.method],\n      doubles: [duration, response.status],\n      indexes: [context.request.headers.get(\"CF-Connecting-IP\") || \"unknown\"],\n    })\n  );\n\n  return response;\n}\n```\n\n---\n\n## Error Handling\n\n### Custom Error Pages\n\n```typescript\n// functions/_middleware.ts\nexport async function onRequest(context: EventContext<Env, string, unknown>) {\n  try {\n    const response = await context.next();\n\n    // Handle 404s with custom page\n    if (response.status === 404) {\n      return context.env.ASSETS.fetch(\n        new Request(new URL(\"/404.html\", context.request.url))\n      );\n    }\n\n    return response;\n  } catch (error) {\n    console.error(\"Middleware error:\", error);\n\n    // Return custom 500 page\n    return new Response(\"Internal Server Error\", {\n      status: 500,\n      headers: { \"Content-Type\": \"text/html\" },\n    });\n  }\n}\n```\n\n### Error Tracking\n\n```typescript\n// lib/error-tracking.ts\nexport async function trackError(\n  error: Error,\n  context: { url: string; userAgent: string }\n) {\n  // Send to your error tracking service\n  await fetch(\"https://your-error-service.com/api/errors\", {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      message: error.message,\n      stack: error.stack,\n      url: context.url,\n      userAgent: context.userAgent,\n      timestamp: new Date().toISOString(),\n    }),\n  });\n}\n```\n\n---\n\n## Performance Monitoring\n\n### Core Web Vitals Collection\n\n```typescript\n// app/layout.tsx (Next.js) or main entry\n\"use client\";\n\nimport { useReportWebVitals } from \"next/web-vitals\";\n\nexport function WebVitals() {\n  useReportWebVitals((metric) => {\n    // Send to analytics\n    const body = JSON.stringify({\n      name: metric.name,\n      value: metric.value,\n      rating: metric.rating,\n      delta: metric.delta,\n      id: metric.id,\n      navigationType: metric.navigationType,\n    });\n\n    // Use sendBeacon for reliability\n    if (navigator.sendBeacon) {\n      navigator.sendBeacon(\"/api/vitals\", body);\n    } else {\n      fetch(\"/api/vitals\", { body, method: \"POST\", keepalive: true });\n    }\n  });\n\n  return null;\n}\n```\n"
        },
        {
          "name": "internal-tools.md",
          "type": "file",
          "path": "frontend-architect/references/internal-tools.md",
          "size": 10376,
          "content": "# Internal Tools Patterns\n\nPatterns for building prototypes and side projects exposed to select users.\n\n## Philosophy\n\nInternal tools are for:\n1. **Experimentation** - Try ideas without production polish\n2. **Learning** - Discover what to build right\n3. **Velocity** - Ship fast, iterate faster\n4. **Stakeholder demos** - Show progress without risk\n\n---\n\n## Access Control Layers\n\n### Layer 1: Cloudflare Access (Authentication)\n\nWho can reach the tool at all.\n\n```\nConfiguration:\n- Create Access Application\n- Domain: internal.example.com\n- Identity: GitHub (or Google, OIDC, etc.)\n- Policy: Allow specific email domain (@yourcompany.com)\n```\n\n### Layer 2: Application-Level (Authorization)\n\nWhat features they can use.\n\n```typescript\n// lib/permissions.ts\nconst ROLES = {\n  admin: [\"*\"],\n  beta: [\"stable-tool\", \"beta-tool\"],\n  viewer: [\"stable-tool\"],\n};\n\nconst USER_ROLES: Record<string, keyof typeof ROLES> = {\n  \"admin@example.com\": \"admin\",\n  \"beta@example.com\": \"beta\",\n};\n\nexport function canAccess(email: string, tool: string): boolean {\n  const role = USER_ROLES[email] || \"viewer\";\n  const permissions = ROLES[role];\n\n  return permissions.includes(\"*\") || permissions.includes(tool);\n}\n```\n\n### Layer 3: Feature Flags (Gradual Rollout)\n\nFine-grained control within tools.\n\n```typescript\n// lib/flags.ts\ninterface FeatureFlags {\n  newUploader: boolean;\n  experimentalAPI: boolean;\n  betaUI: boolean;\n}\n\nconst FLAGS_BY_USER: Record<string, Partial<FeatureFlags>> = {\n  \"admin@example.com\": { newUploader: true, experimentalAPI: true, betaUI: true },\n  \"beta@example.com\": { newUploader: true, betaUI: true },\n};\n\nexport function getFlags(email: string): FeatureFlags {\n  const defaults: FeatureFlags = {\n    newUploader: false,\n    experimentalAPI: false,\n    betaUI: false,\n  };\n\n  return { ...defaults, ...(FLAGS_BY_USER[email] || {}) };\n}\n```\n\n---\n\n## Project Structure\n\n### Monorepo Layout\n\n```\napps/\n‚îú‚îÄ‚îÄ web/                    # Public production site\n‚îú‚îÄ‚îÄ internal/               # Protected internal tools\n‚îÇ   ‚îú‚îÄ‚îÄ _shared/           # Shared internal components\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx     # Common internal layout\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts        # Auth utilities\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ nav.tsx        # Internal navigation\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard/         # Admin dashboard\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wrangler.toml\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ experiment-1/      # First experiment\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wrangler.toml\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ experiment-2/      # Second experiment\n‚îÇ       ‚îî‚îÄ‚îÄ ...\n\npackages/\n‚îú‚îÄ‚îÄ ui/                     # Shared design system\n‚îú‚îÄ‚îÄ db/                     # Database clients\n‚îî‚îÄ‚îÄ types/                  # Shared TypeScript types\n```\n\n### Per-Tool Configuration\n\nEach internal tool gets its own:\n\n```toml\n# apps/internal/experiment-1/wrangler.toml\nname = \"internal-experiment-1\"\ncompatibility_date = \"2026-01-31\"\n\n[vars]\nTOOL_NAME = \"experiment-1\"\nENVIRONMENT = \"internal\"\n\n# Secrets via: wrangler secret put SECRET_NAME\n```\n\n---\n\n## Quick Start Patterns\n\n### New Prototype Script\n\n```bash\n#!/bin/bash\n# scripts/new-prototype.sh\n\nset -e\n\nNAME=$1\nif [ -z \"$NAME\" ]; then\n  echo \"Usage: ./new-prototype.sh <name>\"\n  exit 1\nfi\n\nDIR=\"apps/internal/$NAME\"\nmkdir -p \"$DIR\"\n\n# Create minimal package.json\ncat > \"$DIR/package.json\" << EOF\n{\n  \"name\": \"@internal/$NAME\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev --port 3100\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"deploy\": \"wrangler pages deploy out --project-name=internal-$NAME\"\n  },\n  \"dependencies\": {\n    \"next\": \"^14.0.0\",\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\"\n  }\n}\nEOF\n\n# Create minimal app\nmkdir -p \"$DIR/app\"\ncat > \"$DIR/app/page.tsx\" << 'EOF'\nexport default function Home() {\n  return (\n    <main className=\"min-h-screen p-8\">\n      <h1 className=\"text-2xl font-bold\">Internal Prototype</h1>\n      <p className=\"mt-4\">Replace this with your experiment.</p>\n    </main>\n  );\n}\nEOF\n\ncat > \"$DIR/app/layout.tsx\" << 'EOF'\nimport type { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"Internal Tool\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  );\n}\nEOF\n\n# Create wrangler config\ncat > \"$DIR/wrangler.toml\" << EOF\nname = \"internal-$NAME\"\ncompatibility_date = \"2026-01-31\"\npages_build_output_dir = \"out\"\nEOF\n\necho \"Created $DIR\"\necho \"\"\necho \"Next steps:\"\necho \"  cd $DIR\"\necho \"  pnpm install\"\necho \"  pnpm dev\"\n```\n\n### Shared Internal Layout\n\n```typescript\n// apps/internal/_shared/layout.tsx\nimport { getAccessEmail } from \"./auth\";\nimport { InternalNav } from \"./nav\";\n\nexport function InternalLayout({\n  children,\n  title,\n}: {\n  children: React.ReactNode;\n  title: string;\n}) {\n  const email = getAccessEmail();\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      {/* Header */}\n      <header className=\"bg-yellow-400 border-b-2 border-black\">\n        <div className=\"max-w-7xl mx-auto px-4 py-2 flex justify-between items-center\">\n          <span className=\"font-bold\">üîí Internal Tools</span>\n          <span className=\"text-sm\">{email}</span>\n        </div>\n      </header>\n\n      {/* Navigation */}\n      <InternalNav />\n\n      {/* Content */}\n      <main className=\"max-w-7xl mx-auto px-4 py-8\">\n        <h1 className=\"text-2xl font-bold mb-6\">{title}</h1>\n        {children}\n      </main>\n\n      {/* Footer */}\n      <footer className=\"fixed bottom-0 left-0 right-0 bg-gray-100 border-t text-center text-sm py-2 text-gray-600\">\n        Internal use only. Do not share externally.\n      </footer>\n    </div>\n  );\n}\n```\n\n---\n\n## Lifecycle Management\n\n### Stage 1: Experiment\n\n```\nCharacteristics:\n- Minimal polish (70%)\n- No tests\n- Manual deployment\n- Single user (you)\n\nDuration: 1-2 weeks\n\nArtifacts:\n- Working prototype\n- Learnings document\n- Decision: promote or kill\n```\n\n### Stage 2: Beta\n\n```\nCharacteristics:\n- Medium polish (85%)\n- Basic tests for critical paths\n- CI deployment\n- 3-5 beta users\n\nDuration: 2-4 weeks\n\nArtifacts:\n- Feedback collection\n- Bug fixes\n- Feature prioritization\n```\n\n### Stage 3: Internal Launch\n\n```\nCharacteristics:\n- High polish (95%)\n- Comprehensive tests\n- Automatic deployment\n- All internal users\n\nDuration: Ongoing\n\nArtifacts:\n- Documentation\n- User onboarding\n- Metrics dashboard\n```\n\n### Stage 4: Productization\n\n```\nIf internal tool proves valuable:\n- Extract to production codebase\n- Add public auth\n- Performance optimization\n- Full test coverage\n```\n\n---\n\n## Common Patterns\n\n### Quick Feedback Form\n\n```typescript\n// components/feedback.tsx\n\"use client\";\n\nimport { useState } from \"react\";\n\nexport function FeedbackButton({ toolName }: { toolName: string }) {\n  const [open, setOpen] = useState(false);\n  const [feedback, setFeedback] = useState(\"\");\n  const [sent, setSent] = useState(false);\n\n  const submit = async () => {\n    await fetch(\"/api/feedback\", {\n      method: \"POST\",\n      body: JSON.stringify({ tool: toolName, feedback }),\n    });\n    setSent(true);\n  };\n\n  if (sent) return <div className=\"text-green-600\">Thanks!</div>;\n\n  return (\n    <div className=\"fixed bottom-4 right-4\">\n      {open ? (\n        <div className=\"bg-white border-2 border-black p-4 shadow-lg\">\n          <textarea\n            className=\"border p-2 w-64\"\n            placeholder=\"What do you think?\"\n            value={feedback}\n            onChange={(e) => setFeedback(e.target.value)}\n          />\n          <div className=\"flex gap-2 mt-2\">\n            <button onClick={submit} className=\"bg-black text-white px-4 py-1\">\n              Send\n            </button>\n            <button onClick={() => setOpen(false)}>Cancel</button>\n          </div>\n        </div>\n      ) : (\n        <button\n          onClick={() => setOpen(true)}\n          className=\"bg-yellow-400 border-2 border-black px-4 py-2 font-bold\"\n        >\n          Feedback\n        </button>\n      )}\n    </div>\n  );\n}\n```\n\n### Usage Analytics\n\n```typescript\n// lib/analytics.ts\nexport function trackEvent(event: string, data?: Record<string, unknown>) {\n  // Simple logging for internal tools\n  console.log(\"[Analytics]\", event, data);\n\n  // Or send to simple endpoint\n  fetch(\"/api/analytics\", {\n    method: \"POST\",\n    body: JSON.stringify({\n      event,\n      data,\n      timestamp: new Date().toISOString(),\n      user: getAccessEmail(),\n    }),\n  });\n}\n\n// Usage\ntrackEvent(\"feature_used\", { feature: \"export\", format: \"csv\" });\ntrackEvent(\"error\", { message: \"API failed\", code: 500 });\n```\n\n### Version Display\n\n```typescript\n// components/version.tsx\nexport function VersionBadge() {\n  return (\n    <div className=\"fixed bottom-2 left-2 text-xs text-gray-400\">\n      v{process.env.NEXT_PUBLIC_VERSION || \"dev\"} |{\" \"}\n      {process.env.NEXT_PUBLIC_COMMIT_SHA?.slice(0, 7) || \"local\"}\n    </div>\n  );\n}\n```\n\n---\n\n## Anti-Patterns\n\n### ‚ùå Over-Engineering\n\n```\nWRONG: \"Let me set up full CI/CD, comprehensive tests, and proper architecture\"\n\nRIGHT: \"Ship it, see if it's useful, then add rigor\"\n```\n\n### ‚ùå Waiting for Polish\n\n```\nWRONG: \"I'll share it when it's ready\"\n\nRIGHT: \"Share it now, get feedback, iterate\"\n```\n\n### ‚ùå Ignoring Feedback\n\n```\nWRONG: Build in isolation for weeks\n\nRIGHT: Daily/weekly feedback loops with beta users\n```\n\n### ‚ùå Keeping Zombie Projects\n\n```\nWRONG: Keep all experiments around forever\n\nRIGHT: Archive/delete after 30 days of no activity\n```\n\n---\n\n## Cleanup Process\n\n### Monthly Review\n\n```markdown\n## Internal Tools Review - [Month]\n\n### Active Tools\n- [ ] Tool A - Last used: [date] - Keep\n- [ ] Tool B - Last used: [date] - Keep\n\n### Candidates for Archival\n- [ ] Tool C - Last used: 45 days ago - Archive?\n- [ ] Tool D - Never launched - Delete?\n\n### Candidates for Promotion\n- [ ] Tool E - High usage, stable - Promote to production?\n```\n\n### Archive Script\n\n```bash\n#!/bin/bash\n# scripts/archive-internal-tool.sh\n\nNAME=$1\nif [ -z \"$NAME\" ]; then\n  echo \"Usage: ./archive-internal-tool.sh <name>\"\n  exit 1\nfi\n\n# Move to archive\nmv \"apps/internal/$NAME\" \"apps/internal/_archived/$NAME\"\n\n# Remove from Cloudflare\nwrangler pages project delete \"internal-$NAME\" --yes\n\necho \"Archived $NAME\"\n```\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "frontend-architect/CHANGELOG.md",
      "size": 865,
      "content": "# Changelog\n\nAll notable changes to the frontend-architect skill.\n\n## [1.0.0] - 2026-01-31\n\n### Added\n- Initial release of frontend-architect skill\n- Framework selection decision tree (Next.js, Astro, Remix, etc.)\n- Cloudflare Pages deployment patterns with OpenNext\n- Internal tools architecture for prototypes and experiments\n- shadcn/ui setup and customization guidance\n- Design system bridging (catalog ‚Üí Tailwind ‚Üí components)\n- Stack recommendations by use case\n- Reference documentation:\n  - `cloudflare-patterns.md` - Advanced Cloudflare Pages/Workers patterns\n  - `internal-tools.md` - Patterns for prototype-to-internal pipelines\n- Anti-patterns section for common architecture mistakes\n\n### Technical\n- Full tool permissions for implementation work\n- Proper NOT clause to avoid false activation\n- Under 500 lines in SKILL.md (progressive disclosure)\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "frontend-architect/SKILL.md",
      "size": 11682,
      "content": "---\nname: frontend-architect\ndescription: Frontend stack decisions, Cloudflare deployment patterns, component systems, and internal tools architecture. Use for framework selection, deployment strategy, design system bridging, shadcn setup. Activate on \"frontend architecture\", \"tech stack\", \"Cloudflare Pages\", \"component library\", \"internal tools\", \"shadcn setup\". NOT for writing CSS (use frontend-developer), design critique (use design-critic), or backend APIs.\nallowed-tools: Read,Write,Edit,Bash,Glob,Grep,WebFetch,WebSearch\n---\n\n# Frontend Architect\n\nExpert in frontend stack decisions, Cloudflare deployment, and bridging design systems to component implementations. Specializes in internal tools that expose prototypes to select users.\n\n## When to Use\n\n‚úÖ **Use for**:\n- Choosing between Next.js, Astro, Remix, etc.\n- Setting up Cloudflare Pages/Workers\n- Designing internal tool architectures\n- Bridging design catalogs to component libraries\n- Setting up shadcn/ui from scratch\n- Feature flag and preview URL strategies\n\n‚ùå **NOT for**:\n- Writing CSS or component styling (use `frontend-developer`)\n- Design assessment (use `design-critic`)\n- Backend API design (use `api-architect`)\n- Database decisions\n- DevOps/CI beyond deployment\n\n## Framework Selection Decision Tree\n\n### Question 1: What's the Content Type?\n\n| Content | Framework | Why |\n|---------|-----------|-----|\n| Mostly static, some interactivity | **Astro** | Islands architecture, minimal JS |\n| Full-stack app, heavy interactivity | **Next.js** | RSC, API routes, ecosystem |\n| Content-heavy with CMS | **Astro** or **Next.js** | Both have great CMS integrations |\n| SPA with complex state | **React + Vite** | Faster builds, simpler mental model |\n| Marketing/landing pages | **Astro** | Best performance, partial hydration |\n\n### Question 2: Where's It Deployed?\n\n| Platform | Best Fit | Considerations |\n|----------|----------|----------------|\n| Cloudflare Pages | Astro, Next.js (OpenNext) | Edge-first, workers integration |\n| Vercel | Next.js | Native support, best DX |\n| Netlify | Astro, SvelteKit | Strong Astro support |\n| Self-hosted | Any | Control vs. maintenance tradeoff |\n\n### Question 3: Team Experience?\n\n| Team | Recommendation |\n|------|----------------|\n| React experts | Next.js or React + Vite |\n| Vue/Nuxt background | Nuxt 3 |\n| Performance obsessed | Astro or SolidStart |\n| Content team involved | Astro with MDX |\n\n## Cloudflare Pages Patterns\n\n### Basic Setup\n\n```bash\n# Initialize with wrangler\nnpx wrangler pages project create my-project\n\n# Link existing project\nnpx wrangler pages project list\n```\n\n### wrangler.toml Configuration\n\n```toml\nname = \"my-project\"\ncompatibility_date = \"2026-01-31\"\npages_build_output_dir = \"out\"  # or \".next\" for Next.js\n\n# Environment variables\n[vars]\nNEXT_PUBLIC_API_URL = \"https://api.example.com\"\n\n# Secrets (set via wrangler secret)\n# GITHUB_TOKEN, API_KEY, etc.\n\n# KV namespace (for caching)\n[[kv_namespaces]]\nbinding = \"CACHE\"\nid = \"abc123...\"\n```\n\n### Preview Deployments\n\nEvery branch gets a preview URL:\n\n```\nPattern: <branch>.<project>.pages.dev\n\nExamples:\n- main.my-project.pages.dev (production)\n- feature-123.my-project.pages.dev (preview)\n- staging.my-project.pages.dev (staging)\n```\n\n**Workflow**:\n```bash\n# Deploy preview manually\nnpx wrangler pages deploy out --project-name=my-project\n\n# Or use GitHub integration\n# Push to any branch ‚Üí automatic preview URL\n```\n\n### Access Control (Internal Tools)\n\n```toml\n# In wrangler.toml or Cloudflare dashboard\n\n# Cloudflare Access for auth\n# Configure in dashboard: Access > Applications\n\n# Patterns:\n# - internal.example.com ‚Üí Protected by Access\n# - preview-*.pages.dev ‚Üí Protected by Access\n# - example.com ‚Üí Public\n```\n\n### Feature Flags at Edge\n\n```typescript\n// src/middleware.ts (Next.js) or functions/_middleware.ts (Pages)\n\nexport async function onRequest(context: { request: Request; env: Env }) {\n  const flags = await context.env.FLAGS.get('feature-flags', 'json');\n\n  // Check user eligibility\n  const email = context.request.headers.get('cf-access-authenticated-user-email');\n\n  if (flags?.betaUsers?.includes(email)) {\n    // Rewrite to beta version\n    return context.env.ASSETS.fetch(\n      new Request('https://beta.example.com' + new URL(context.request.url).pathname)\n    );\n  }\n\n  return context.next();\n}\n```\n\n## Internal Tools Architecture\n\nFor \"prototypes/side ideas exposed as internal tools only a few users can see\":\n\n### Architecture Pattern\n\n```\nyour-domain.com/           # Public production\n‚îú‚îÄ‚îÄ internal/              # Cloudflare Access protected\n‚îÇ   ‚îú‚îÄ‚îÄ tool-1/           # Internal tool 1\n‚îÇ   ‚îú‚îÄ‚îÄ tool-2/           # Internal tool 2\n‚îÇ   ‚îî‚îÄ‚îÄ experiments/      # Wild experiments\n‚îî‚îÄ‚îÄ preview-*.pages.dev    # Branch previews (also protected)\n```\n\n### Access Levels\n\n| Role | Access | Implementation |\n|------|--------|----------------|\n| Admin | All internal tools | Cloudflare Access group |\n| Beta | Stable internal tools | Access group + feature flags |\n| Public | Production only | Default |\n\n### Monorepo Structure (Turborepo)\n\n```\napps/\n‚îú‚îÄ‚îÄ web/                   # Public site\n‚îú‚îÄ‚îÄ internal/              # Internal tools (protected)\n‚îÇ   ‚îú‚îÄ‚îÄ admin/            # Admin dashboard\n‚îÇ   ‚îú‚îÄ‚îÄ prototype-1/      # Experiment\n‚îÇ   ‚îî‚îÄ‚îÄ prototype-2/      # Another experiment\n‚îî‚îÄ‚îÄ shared/               # Shared components\n\npackages/\n‚îú‚îÄ‚îÄ ui/                    # Design system\n‚îú‚îÄ‚îÄ config/               # Shared configs\n‚îî‚îÄ‚îÄ types/                # Shared types\n```\n\n### Quick Prototype Script\n\n```bash\n#!/bin/bash\n# scripts/new-prototype.sh\n\nNAME=$1\nmkdir -p apps/internal/$NAME\n\ncat > apps/internal/$NAME/package.json << EOF\n{\n  \"name\": \"@internal/$NAME\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev --port 3100\",\n    \"build\": \"next build\",\n    \"deploy\": \"wrangler pages deploy out --project-name=$NAME\"\n  }\n}\nEOF\n\necho \"Created apps/internal/$NAME\"\necho \"Run: cd apps/internal/$NAME && pnpm dev\"\n```\n\n## shadcn/ui Setup\n\n### Initial Setup\n\n```bash\n# For Next.js\nnpx shadcn@latest init\n\n# Interactive prompts:\n# - Style: New York (more opinionated) or Default\n# - Base color: Slate, Gray, Zinc, Neutral, Stone\n# - CSS variables: Yes (recommended)\n# - tailwind.config.js path: tailwind.config.js\n# - components.json location: ./\n# - Aliases: @/components, @/lib/utils\n```\n\n### components.json\n\n```json\n{\n  \"$schema\": \"https://ui.shadcn.com/schema.json\",\n  \"style\": \"new-york\",\n  \"rsc\": true,\n  \"tsx\": true,\n  \"tailwind\": {\n    \"config\": \"tailwind.config.js\",\n    \"css\": \"app/globals.css\",\n    \"baseColor\": \"slate\",\n    \"cssVariables\": true\n  },\n  \"aliases\": {\n    \"components\": \"@/components\",\n    \"utils\": \"@/lib/utils\"\n  }\n}\n```\n\n### Adding Components\n\n```bash\n# Add specific components\nnpx shadcn@latest add button\nnpx shadcn@latest add card\nnpx shadcn@latest add dialog\n\n# Add multiple at once\nnpx shadcn@latest add button card dialog input\n\n# List available\nnpx shadcn@latest add --help\n```\n\n### Customization Pattern\n\n```typescript\n// components/ui/button.tsx (after shadcn generates it)\n\n// Add your variants to the existing cva()\nconst buttonVariants = cva(\n  \"...\", // existing base styles\n  {\n    variants: {\n      variant: {\n        default: \"...\",\n        destructive: \"...\",\n        // ADD YOUR CUSTOM VARIANTS\n        neobrutalist: \"border-3 border-black shadow-[4px_4px_0_#000] hover:shadow-[2px_2px_0_#000] active:shadow-none\",\n        ghost: \"...\",\n      },\n      size: {\n        // existing sizes...\n        // ADD YOUR CUSTOM SIZES\n        jumbo: \"h-14 px-10 text-lg\",\n      },\n    },\n  }\n);\n```\n\n## Design System Bridging\n\nConnect design catalog to component implementation:\n\n### Pattern: Token ‚Üí Tailwind ‚Üí Component\n\n```\ndesign-catalog/color-palettes.json\n          ‚Üì\ntailwind.config.js (extends theme.colors)\n          ‚Üì\ncomponents/ui/*.tsx (use Tailwind classes)\n```\n\n### Implementation\n\n```typescript\n// lib/design-catalog/loader.ts\nimport palettes from '@/design-catalog/color-palettes.json';\n\nexport function getDesignTokens(trendId: string) {\n  const palette = palettes.palettes.find(p => p.trend === trendId);\n\n  return {\n    colors: Object.fromEntries(\n      palette.colors.map(c => [c.name.toLowerCase().replace(' ', '-'), c.hex])\n    ),\n    // ... typography, spacing from other catalog files\n  };\n}\n\n// scripts/generate-tailwind-theme.ts\nimport { getDesignTokens } from '../lib/design-catalog/loader';\n\nconst tokens = getDesignTokens('neobrutalism');\nconst tailwindTheme = {\n  theme: {\n    extend: {\n      colors: tokens.colors,\n    },\n  },\n};\n\nfs.writeFileSync(\n  'tailwind.config.generated.js',\n  `module.exports = ${JSON.stringify(tailwindTheme, null, 2)}`\n);\n```\n\n## Common Anti-Patterns\n\n### Anti-Pattern: Premature Microservices\n\n**Novice thinking**: \"Let's split into 5 repos for cleanliness\"\n\n**Reality**: Coordination overhead kills velocity. Monorepo with clear boundaries is faster.\n\n**Correct approach**: Start monorepo (Turborepo), split when you have dedicated teams per service.\n\n---\n\n### Anti-Pattern: Framework FOMO\n\n**Novice thinking**: \"Remix/SolidStart is hot, let's migrate\"\n\n**Reality**: Framework migrations are expensive. Stick with working stack unless there's a clear benefit.\n\n**Correct approach**: Evaluate frameworks for NEW projects. Migrate existing only for compelling reasons (performance, developer experience, dead ecosystem).\n\n---\n\n### Anti-Pattern: Over-Engineering Internal Tools\n\n**Novice thinking**: \"Internal tool needs full CI/CD, comprehensive tests, perfect architecture\"\n\n**Reality**: Internal tools are for experimentation. Perfect is the enemy of shipped.\n\n**Correct approach**: Ship fast, iterate. Add rigor when tool becomes critical. Internal tools are for learning what to build right.\n\n---\n\n### Anti-Pattern: Ignoring Edge Runtime Constraints\n\n**Novice thinking**: \"Just use any npm package on Cloudflare Workers\"\n\n**Reality**: Workers have no Node.js APIs. Many packages fail.\n\n**Common failures**:\n- `fs` ‚Üí Use KV or R2\n- `crypto` (Node) ‚Üí Use Web Crypto API\n- Heavy libraries ‚Üí Bundle size limits\n\n**Correct approach**: Check package compatibility. Use lightweight alternatives. Test in Workers environment early.\n\n## Stack Recommendations by Use Case\n\n### SaaS Dashboard\n\n```\nFramework: Next.js 14+ (App Router)\nStyling: Tailwind + shadcn/ui\nState: Zustand or Jotai\nData: TanStack Query + tRPC\nAuth: NextAuth.js or Clerk\nDeploy: Cloudflare Pages (OpenNext) or Vercel\n```\n\n### Marketing Site\n\n```\nFramework: Astro\nStyling: Tailwind\nCMS: Sanity, Contentful, or MDX\nDeploy: Cloudflare Pages\nPerformance: Target 100 Lighthouse\n```\n\n### Internal Tool\n\n```\nFramework: Next.js (simpler) or React + Vite (faster builds)\nStyling: Tailwind + shadcn/ui\nAuth: Cloudflare Access\nDeploy: Cloudflare Pages (protected)\nPolish Level: 70% (ship fast)\n```\n\n### Design Showcase Gallery\n\n```\nFramework: Next.js 14+ or Astro\nStyling: Tailwind + Custom CSS for showcase\nImages: next/image or Astro Image\nGallery: Masonry grid, virtualized\nDeploy: Cloudflare Pages\n```\n\n## Pairs With\n\n- **design-critic**: Get design assessment before/after implementation\n- **cloudflare-worker-dev**: For edge computing patterns\n- **web-design-expert**: For design decisions\n- **devops-automator**: For CI/CD beyond Cloudflare\n\n## References\n\nSee `/references/` for detailed guides:\n- `cloudflare-patterns.md` - Advanced Cloudflare Pages/Workers patterns\n- `shadcn-customization.md` - Extending shadcn/ui components\n- `internal-tools.md` - Patterns for prototype-to-internal pipelines\n- `monorepo-setup.md` - Turborepo configuration for frontend apps\n"
    }
  ]
}