{
  "name": "execution-lifecycle-manager",
  "type": "folder",
  "path": "execution-lifecycle-manager",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "execution-lifecycle-manager/references",
      "children": [
        {
          "name": "process-signals.md",
          "type": "file",
          "path": "execution-lifecycle-manager/references/process-signals.md",
          "size": 3101,
          "content": "# Unix Process Signals Reference\n\n## Signal Types for Execution Control\n\n| Signal | Number | Catchable | Purpose |\n|--------|--------|-----------|---------|\n| SIGTERM | 15 | Yes | Graceful termination request |\n| SIGKILL | 9 | No | Immediate termination (cannot be caught) |\n| SIGINT | 2 | Yes | Interrupt (Ctrl+C) |\n| SIGHUP | 1 | Yes | Hangup (terminal closed) |\n| SIGSTOP | 19 | No | Pause process |\n| SIGCONT | 18 | Yes | Resume paused process |\n\n## Best Practices\n\n### 1. Always Try SIGTERM First\n\n```typescript\n// Give process time to clean up\nproc.kill('SIGTERM');\n\n// Wait for graceful exit\nawait Promise.race([\n  waitForExit(proc),\n  sleep(TIMEOUT_MS),\n]);\n\n// Only force kill if still running\nif (!proc.killed) {\n  proc.kill('SIGKILL');\n}\n```\n\n### 2. Handle Signals in Your Process\n\n```typescript\n// In spawned process\nprocess.on('SIGTERM', async () => {\n  console.log('Received SIGTERM, cleaning up...');\n\n  // Flush pending writes\n  await flushBuffers();\n\n  // Close connections\n  await closeConnections();\n\n  // Save progress\n  await saveCheckpoint();\n\n  process.exit(0);\n});\n```\n\n### 3. Child Process Groups\n\nWhen spawning with `detached: false` (default), children die with parent.\n\nFor independent children, use `detached: true` and track PIDs manually:\n```typescript\nconst proc = spawn(cmd, args, { detached: true });\nproc.unref(); // Parent can exit without waiting\n\n// To kill later:\nprocess.kill(-proc.pid, 'SIGTERM'); // Negative PID = process group\n```\n\n## Node.js Specifics\n\n### spawn() is Preferred\n\nAlways use `spawn()` for execution control:\n- Signals go directly to the process\n- No shell injection vulnerabilities\n- Streams available for real-time output\n\n```typescript\n// CORRECT: Use spawn with shell: false\nconst proc = spawn('claude', ['-p', prompt], {\n  shell: false,  // Direct execution, no shell\n});\n```\n\n### AbortSignal Integration\n\n```typescript\nconst controller = new AbortController();\n\nconst proc = spawn('claude', ['-p', prompt], {\n  signal: controller.signal, // Node 15+\n});\n\n// Later:\ncontroller.abort(); // Sends SIGTERM\n```\n\n## Timeout Recommendations\n\n| Scenario | Graceful Timeout | Notes |\n|----------|------------------|-------|\n| API request in flight | 5s | Allow request to complete |\n| File I/O | 2s | Flush buffers |\n| Claude CLI execution | 5s | May be mid-generation |\n| Database transaction | 10s | Must commit or rollback |\n\n## Debugging Orphaned Processes\n\n```bash\n# Find processes by name\nps aux | grep claude\n\n# Find processes by parent PID\npstree -p <parent-pid>\n\n# Kill process group\nkill -TERM -<pgid>\n\n# List all node processes\npgrep -a node\n```\n\n## Common Issues\n\n### 1. Process Doesn't Die on SIGTERM\n\n**Cause**: Process ignores or doesn't handle SIGTERM\n**Solution**: Use SIGKILL after timeout\n\n### 2. Zombie Processes\n\n**Cause**: Parent doesn't `wait()` for child exit\n**Solution**: Always handle `close` event:\n```typescript\nproc.on('close', (code) => {\n  cleanup(proc.pid);\n});\n```\n\n### 3. Shell Absorbs Signal\n\n**Cause**: Using shell execution which spawns an intermediate shell\n**Solution**: Use `spawn()` with `shell: false`\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "execution-lifecycle-manager/SKILL.md",
      "size": 5633,
      "content": "---\nname: execution-lifecycle-manager\ndescription: Manage DAG execution lifecycles including start, stop, pause, resume, and cleanup. Activate on 'execution lifecycle', 'stop execution', 'abort DAG', 'graceful shutdown', 'kill process'. NOT for cost estimation, DAG building, or skill selection.\nallowed-tools: Read,Write,Edit,Bash\n---\n\n# Execution Lifecycle Manager\n\nCentralized state management for running DAG executions with graceful shutdown patterns.\n\n## When to Use\n\n✅ **Use for**:\n- Implementing execution start/stop/pause/resume controls\n- Graceful process termination (SIGTERM → SIGKILL)\n- Tracking active executions across the system\n- Cleaning up orphaned processes\n- Implementing abort handlers with cost tracking\n\n❌ **NOT for**:\n- Cost estimation or pricing calculations (use cost-accrual-tracker)\n- Building or modifying DAG structures\n- Skill matching or selection\n- Process spawning (use the executor directly)\n\n## Core Patterns\n\n### 1. Graceful Shutdown Pattern\n\nAlways use SIGTERM first, then escalate to SIGKILL:\n\n```typescript\n// CORRECT: Two-phase shutdown\nconst GRACEFUL_TIMEOUT_MS = 2000;\n\nasync function terminateProcess(proc: ChildProcess): Promise<void> {\n  proc.kill('SIGTERM');\n\n  const forceKillTimer = setTimeout(() => {\n    if (!proc.killed) {\n      proc.kill('SIGKILL');\n    }\n  }, GRACEFUL_TIMEOUT_MS);\n\n  await waitForExit(proc);\n  clearTimeout(forceKillTimer);\n}\n```\n\n### 2. AbortController Pattern\n\nUse `AbortController` for cancellation propagation:\n\n```typescript\n// Parent (DAGExecutor)\nconst abortController = new AbortController();\n\n// Pass signal to child executors\nawait executor.execute({\n  ...request,\n  abortSignal: abortController.signal,\n});\n\n// To abort all children:\nabortController.abort();\n```\n\n### 3. Execution Registry Pattern\n\nTrack active executions for monitoring and cleanup:\n\n```typescript\ninterface ActiveExecution {\n  executionId: string;\n  abortController: AbortController;\n  status: 'running' | 'stopping' | 'stopped' | 'completed' | 'failed';\n  startedAt: number;\n  stoppedAt?: number;\n}\n\nclass ExecutionManager {\n  private executions: Map<string, ActiveExecution> = new Map();\n\n  create(id: string): ActiveExecution { /* ... */ }\n  stop(id: string, reason: string): Promise<StopResult> { /* ... */ }\n  listActive(): ActiveExecution[] { /* ... */ }\n}\n```\n\n## Anti-Patterns\n\n### SIGKILL Without SIGTERM\n\n**Novice thinking**: \"Just kill it immediately\"\n\n**Reality**: SIGKILL doesn't allow cleanup. Processes can't:\n- Flush buffers to disk\n- Close network connections gracefully\n- Release locks\n- Save partial progress\n\n**Timeline**:\n- Always: SIGTERM allows graceful shutdown\n- If stuck after 2-5s: Then use SIGKILL\n\n**Correct approach**: Always SIGTERM first, SIGKILL as fallback.\n\n### Missing Abort Signal Propagation\n\n**Novice thinking**: \"Just track the top-level execution\"\n\n**Reality**: Without signal propagation, child processes become orphans:\n- Parent dies, children keep running\n- Resources leak\n- Costs continue accruing\n\n**Correct approach**: Pass `AbortSignal` through entire execution tree.\n\n### Synchronous Stop Handler\n\n**Novice thinking**: \"Stop should return immediately\"\n\n**Reality**: Stopping is async - processes need time to terminate:\n- Network requests need to timeout\n- File handles need to close\n- Costs need final calculation\n\n**Correct approach**: Return `Promise` with final state after cleanup completes.\n\n## State Machine\n\n```\n         ┌──────────┐\n         │  idle    │\n         └────┬─────┘\n              │ start()\n              ▼\n         ┌──────────┐\n    ┌───►│ running  │◄───┐\n    │    └────┬─────┘    │\n    │         │          │ resume()\n    │         │ pause()  │\n    │         ▼          │\n    │    ┌──────────┐    │\n    │    │ paused   │────┘\n    │    └────┬─────┘\n    │         │ stop()\n    │         ▼\n    │    ┌──────────┐\n    └────│ stopping │ (transitional - 2-10s)\n         └────┬─────┘\n              │\n     ┌────────┴────────┐\n     ▼                 ▼\n┌──────────┐     ┌──────────┐\n│ stopped  │     │  failed  │\n└──────────┘     └──────────┘\n```\n\n## API Design\n\n### Stop Endpoint Response\n\n```typescript\ninterface StopResponse {\n  status: 'stopped';\n  executionId: string;\n  reason: string;  // 'user_abort' | 'timeout' | 'error'\n  finalCostUsd: number;\n  stoppedAt: number;\n  summary: {\n    nodesCompleted: number;\n    nodesFailed: number;\n    nodesTotal: number;\n    durationMs: number;\n  };\n}\n```\n\n### Cleanup on Server Shutdown\n\n```typescript\n// In server.ts\nprocess.on('SIGINT', async () => {\n  console.log('Shutting down...');\n\n  // Stop all active executions gracefully\n  const active = executionManager.listActive();\n  await Promise.all(\n    active.map(e => executionManager.stop(e.executionId, 'server_shutdown'))\n  );\n\n  server.close();\n});\n```\n\n## Integration Points\n\n| Component | Responsibility |\n|-----------|----------------|\n| `ExecutionManager` | Tracks executions, coordinates stop |\n| `DAGExecutor` | Owns AbortController, orchestrates waves |\n| `ProcessExecutor` | Spawns processes, handles SIGTERM/SIGKILL |\n| `/api/execute/stop` | HTTP interface for stop requests |\n\n## References\n\nSee `/references/process-signals.md` for Unix signal handling details.\n"
    }
  ]
}