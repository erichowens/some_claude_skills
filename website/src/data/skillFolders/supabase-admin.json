{
  "name": "supabase-admin",
  "type": "folder",
  "path": "supabase-admin",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "supabase-admin/references",
      "children": [
        {
          "name": "rls-patterns.md",
          "type": "file",
          "path": "supabase-admin/references/rls-patterns.md",
          "size": 5424,
          "content": "# Advanced RLS Policy Patterns\n\n## Policy Types\n\n| Type | Use Case |\n|------|----------|\n| `FOR SELECT` | Read access |\n| `FOR INSERT` | Create access (use `WITH CHECK`) |\n| `FOR UPDATE` | Modify access |\n| `FOR DELETE` | Remove access |\n| `FOR ALL` | All operations |\n\n## Pattern 1: Owner-Based Access\n\n```sql\n-- Only owner can see/modify their data\nCREATE POLICY \"Owner access\" ON user_data\n  FOR ALL USING (auth.uid() = user_id);\n```\n\n## Pattern 2: Public Read, Authenticated Write\n\n```sql\n-- Anyone can read\nCREATE POLICY \"Public read\" ON posts\n  FOR SELECT USING (true);\n\n-- Only authenticated users can create (owning their posts)\nCREATE POLICY \"Auth write\" ON posts\n  FOR INSERT WITH CHECK (\n    auth.role() = 'authenticated'\n    AND auth.uid() = author_id\n  );\n\n-- Only author can update\nCREATE POLICY \"Author update\" ON posts\n  FOR UPDATE USING (auth.uid() = author_id);\n```\n\n## Pattern 3: Role-Based Access Control (RBAC)\n\n```sql\n-- Store roles in profiles\nALTER TABLE profiles ADD COLUMN role text DEFAULT 'user';\n\n-- Admin can do anything\nCREATE POLICY \"Admin full access\" ON content\n  FOR ALL USING (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE profiles.id = (SELECT auth.uid())\n        AND profiles.role = 'admin'\n    )\n  );\n\n-- Moderators can read and update\nCREATE POLICY \"Mod read\" ON content\n  FOR SELECT USING (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE profiles.id = (SELECT auth.uid())\n        AND profiles.role IN ('admin', 'moderator')\n    )\n  );\n```\n\n## Pattern 4: Team/Organization Access\n\n```sql\n-- Users belong to teams\nCREATE TABLE team_members (\n  team_id uuid REFERENCES teams(id),\n  user_id uuid REFERENCES profiles(id),\n  role text DEFAULT 'member',\n  PRIMARY KEY (team_id, user_id)\n);\n\n-- Team members can access team resources\nCREATE POLICY \"Team access\" ON team_resources\n  FOR SELECT USING (\n    EXISTS (\n      SELECT 1 FROM team_members\n      WHERE team_members.team_id = team_resources.team_id\n        AND team_members.user_id = (SELECT auth.uid())\n    )\n  );\n```\n\n## Pattern 5: Privacy Settings\n\n```sql\n-- Users control their own visibility\nALTER TABLE profiles ADD COLUMN privacy text DEFAULT 'public';\n\nCREATE POLICY \"Respect privacy\" ON profiles\n  FOR SELECT USING (\n    privacy = 'public'\n    OR id = (SELECT auth.uid())\n    OR (\n      privacy = 'friends'\n      AND EXISTS (\n        SELECT 1 FROM friendships\n        WHERE status = 'accepted'\n          AND (\n            (requester_id = profiles.id AND addressee_id = (SELECT auth.uid()))\n            OR (addressee_id = profiles.id AND requester_id = (SELECT auth.uid()))\n          )\n      )\n    )\n  );\n```\n\n## Pattern 6: Temporal Access (Time-Based)\n\n```sql\n-- Content visible only during certain times\nCREATE POLICY \"Time-limited access\" ON events\n  FOR SELECT USING (\n    starts_at <= now()\n    AND (ends_at IS NULL OR ends_at > now())\n  );\n\n-- Soft-deleted items hidden\nCREATE POLICY \"Hide deleted\" ON posts\n  FOR SELECT USING (deleted_at IS NULL);\n```\n\n## Pattern 7: Hierarchical Access (Parent-Child)\n\n```sql\n-- Comments inherit visibility from posts\nCREATE POLICY \"Comments follow posts\" ON comments\n  FOR SELECT USING (\n    EXISTS (\n      SELECT 1 FROM posts\n      WHERE posts.id = comments.post_id\n        AND (\n          posts.visibility = 'public'\n          OR posts.author_id = (SELECT auth.uid())\n        )\n    )\n  );\n```\n\n## Performance Optimization\n\n### Always Use Subquery for auth.uid()\n\n```sql\n-- SLOW: JWT parsed for every row\nCREATE POLICY \"slow\" ON data\n  FOR SELECT USING (user_id = auth.uid());\n\n-- FAST: JWT parsed once\nCREATE POLICY \"fast\" ON data\n  FOR SELECT USING (user_id = (SELECT auth.uid()));\n```\n\n### Index Policy Columns\n\n```sql\n-- Create indexes on columns used in policies\nCREATE INDEX idx_posts_author ON posts(author_id);\nCREATE INDEX idx_team_members_lookup ON team_members(team_id, user_id);\nCREATE INDEX idx_profiles_role ON profiles(role);\n```\n\n### Use Security Definer Functions for Complex Logic\n\n```sql\n-- Move complex logic to a function\nCREATE OR REPLACE FUNCTION can_access_resource(resource_id uuid)\nRETURNS boolean AS $$\n  -- Complex access logic here\n  SELECT EXISTS (\n    SELECT 1 FROM permissions\n    WHERE permissions.resource_id = $1\n      AND permissions.user_id = (SELECT auth.uid())\n      AND permissions.expires_at > now()\n  );\n$$ LANGUAGE sql STABLE SECURITY DEFINER;\n\n-- Simple policy using function\nCREATE POLICY \"Check permissions\" ON resources\n  FOR SELECT USING (can_access_resource(id));\n```\n\n## Debugging Policies\n\n```sql\n-- See all policies on a table\nSELECT * FROM pg_policies WHERE tablename = 'your_table';\n\n-- Test as anonymous\nSET ROLE anon;\nSELECT * FROM your_table LIMIT 1;\nRESET ROLE;\n\n-- Test as authenticated with specific user\nSET request.jwt.claims TO '{\"sub\": \"user-uuid\", \"role\": \"authenticated\"}';\nSELECT * FROM your_table;\n\n-- Check current auth context\nSELECT\n  auth.uid() as user_id,\n  auth.role() as role,\n  current_user as db_user;\n```\n\n## Common Mistakes\n\n1. **Forgetting to enable RLS**: `ALTER TABLE t ENABLE ROW LEVEL SECURITY;`\n2. **Not indexing policy columns**: Causes full table scans\n3. **Using `auth.uid()` directly**: Use `(SELECT auth.uid())` instead\n4. **Overly permissive policies**: Start restrictive, add permissions\n5. **Circular references**: Policy A depends on B depends on A\n6. **Missing INSERT policies**: `WITH CHECK` is required for INSERT\n7. **Testing only as superuser**: Superuser bypasses RLS\n"
        },
        {
          "name": "social-schema.md",
          "type": "file",
          "path": "supabase-admin/references/social-schema.md",
          "size": 11639,
          "content": "# Social Features Schema Patterns\n\nProven database patterns for social features in Supabase.\n\n## Friend/Connection System\n\n### Basic Friend Request Schema\n\n```sql\n-- Friend relationships (bidirectional once accepted)\nCREATE TABLE friendships (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  requester_id uuid REFERENCES profiles(id) ON DELETE CASCADE,\n  addressee_id uuid REFERENCES profiles(id) ON DELETE CASCADE,\n  status text CHECK (status IN ('pending', 'accepted', 'blocked')) DEFAULT 'pending',\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now(),\n  UNIQUE(requester_id, addressee_id)\n);\n\n-- Indexes for fast lookups\nCREATE INDEX idx_friendships_requester ON friendships(requester_id);\nCREATE INDEX idx_friendships_addressee ON friendships(addressee_id);\nCREATE INDEX idx_friendships_status ON friendships(status);\n\n-- RLS Policies\nALTER TABLE friendships ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users see their friendships\" ON friendships\n  FOR SELECT USING (\n    auth.uid() IN (requester_id, addressee_id)\n  );\n\nCREATE POLICY \"Users can request friendship\" ON friendships\n  FOR INSERT WITH CHECK (\n    auth.uid() = requester_id\n    AND requester_id != addressee_id\n  );\n\nCREATE POLICY \"Addressee can accept/reject\" ON friendships\n  FOR UPDATE USING (\n    auth.uid() = addressee_id\n    AND status = 'pending'\n  );\n\nCREATE POLICY \"Either party can delete\" ON friendships\n  FOR DELETE USING (\n    auth.uid() IN (requester_id, addressee_id)\n  );\n```\n\n### Query Helpers\n\n```sql\n-- Get all friends for a user (accepted only)\nCREATE OR REPLACE FUNCTION get_friends(user_uuid uuid)\nRETURNS TABLE(friend_id uuid, friend_since timestamptz) AS $$\n  SELECT\n    CASE\n      WHEN requester_id = user_uuid THEN addressee_id\n      ELSE requester_id\n    END as friend_id,\n    updated_at as friend_since\n  FROM friendships\n  WHERE status = 'accepted'\n    AND (requester_id = user_uuid OR addressee_id = user_uuid)\n$$ LANGUAGE sql STABLE;\n\n-- Check if two users are friends\nCREATE OR REPLACE FUNCTION are_friends(user1 uuid, user2 uuid)\nRETURNS boolean AS $$\n  SELECT EXISTS (\n    SELECT 1 FROM friendships\n    WHERE status = 'accepted'\n      AND ((requester_id = user1 AND addressee_id = user2)\n           OR (requester_id = user2 AND addressee_id = user1))\n  )\n$$ LANGUAGE sql STABLE;\n```\n\n## Sponsor/Sponsee Relationships\n\n### Hierarchical Mentor Relationship\n\n```sql\n-- Sponsor relationships (one-to-many)\nCREATE TABLE sponsorships (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  sponsor_id uuid REFERENCES profiles(id) ON DELETE CASCADE,\n  sponsee_id uuid REFERENCES profiles(id) ON DELETE CASCADE,\n  invite_code text UNIQUE,\n  status text CHECK (status IN ('pending', 'active', 'ended')) DEFAULT 'pending',\n  program text, -- 'aa', 'na', 'cma', etc.\n  started_at timestamptz,\n  ended_at timestamptz,\n  created_at timestamptz DEFAULT now(),\n  UNIQUE(sponsor_id, sponsee_id)\n);\n\n-- Invite code generation function\nCREATE OR REPLACE FUNCTION generate_sponsor_invite()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.invite_code IS NULL THEN\n    NEW.invite_code := upper(substr(md5(random()::text), 1, 8));\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER set_sponsor_invite\n  BEFORE INSERT ON sponsorships\n  FOR EACH ROW EXECUTE FUNCTION generate_sponsor_invite();\n\n-- RLS Policies\nALTER TABLE sponsorships ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"View own sponsorships\" ON sponsorships\n  FOR SELECT USING (auth.uid() IN (sponsor_id, sponsee_id));\n\nCREATE POLICY \"Sponsors create invites\" ON sponsorships\n  FOR INSERT WITH CHECK (auth.uid() = sponsor_id);\n\nCREATE POLICY \"Either party can update\" ON sponsorships\n  FOR UPDATE USING (auth.uid() IN (sponsor_id, sponsee_id));\n```\n\n### Accept Invite by Code\n\n```sql\nCREATE OR REPLACE FUNCTION accept_sponsor_invite(code text)\nRETURNS sponsorships AS $$\nDECLARE\n  result sponsorships;\nBEGIN\n  UPDATE sponsorships\n  SET\n    sponsee_id = auth.uid(),\n    status = 'active',\n    started_at = now(),\n    invite_code = NULL -- Clear code after use\n  WHERE invite_code = code\n    AND status = 'pending'\n    AND sponsee_id IS NULL\n  RETURNING * INTO result;\n\n  IF result IS NULL THEN\n    RAISE EXCEPTION 'Invalid or expired invite code';\n  END IF;\n\n  RETURN result;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\n## Ad-Hoc Groups (Meeting-Based)\n\n### Ephemeral Group Schema\n\n```sql\n-- Groups that form around meetings or topics\nCREATE TABLE groups (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  name text NOT NULL,\n  description text,\n  type text CHECK (type IN ('meeting', 'topic', 'support', 'private')) DEFAULT 'topic',\n  visibility text CHECK (visibility IN ('public', 'private', 'invite')) DEFAULT 'public',\n  meeting_id uuid REFERENCES meetings(id) ON DELETE SET NULL, -- Optional meeting link\n  creator_id uuid REFERENCES profiles(id) ON DELETE SET NULL,\n  max_members int DEFAULT 50,\n  expires_at timestamptz, -- For ephemeral groups\n  created_at timestamptz DEFAULT now()\n);\n\n-- Group membership\nCREATE TABLE group_members (\n  group_id uuid REFERENCES groups(id) ON DELETE CASCADE,\n  user_id uuid REFERENCES profiles(id) ON DELETE CASCADE,\n  role text CHECK (role IN ('owner', 'admin', 'member')) DEFAULT 'member',\n  joined_at timestamptz DEFAULT now(),\n  PRIMARY KEY (group_id, user_id)\n);\n\n-- Indexes\nCREATE INDEX idx_groups_meeting ON groups(meeting_id) WHERE meeting_id IS NOT NULL;\nCREATE INDEX idx_groups_type ON groups(type);\nCREATE INDEX idx_group_members_user ON group_members(user_id);\n\n-- RLS Policies\nALTER TABLE groups ENABLE ROW LEVEL SECURITY;\nALTER TABLE group_members ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Public groups visible\" ON groups\n  FOR SELECT USING (\n    visibility = 'public'\n    OR creator_id = auth.uid()\n    OR EXISTS (\n      SELECT 1 FROM group_members\n      WHERE group_members.group_id = groups.id\n        AND group_members.user_id = auth.uid()\n    )\n  );\n\nCREATE POLICY \"Members see membership\" ON group_members\n  FOR SELECT USING (\n    user_id = auth.uid()\n    OR EXISTS (\n      SELECT 1 FROM group_members gm\n      WHERE gm.group_id = group_members.group_id\n        AND gm.user_id = auth.uid()\n    )\n  );\n```\n\n### Auto-Create Group for Meeting\n\n```sql\nCREATE OR REPLACE FUNCTION create_meeting_group(\n  meeting_uuid uuid,\n  group_name text DEFAULT NULL\n)\nRETURNS groups AS $$\nDECLARE\n  meeting_record meetings;\n  new_group groups;\nBEGIN\n  -- Get meeting info\n  SELECT * INTO meeting_record FROM meetings WHERE id = meeting_uuid;\n\n  IF meeting_record IS NULL THEN\n    RAISE EXCEPTION 'Meeting not found';\n  END IF;\n\n  -- Create group\n  INSERT INTO groups (name, type, meeting_id, creator_id, expires_at)\n  VALUES (\n    COALESCE(group_name, meeting_record.name || ' Group'),\n    'meeting',\n    meeting_uuid,\n    auth.uid(),\n    now() + interval '24 hours' -- Ephemeral by default\n  )\n  RETURNING * INTO new_group;\n\n  -- Add creator as owner\n  INSERT INTO group_members (group_id, user_id, role)\n  VALUES (new_group.id, auth.uid(), 'owner');\n\n  RETURN new_group;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\n## Direct Messaging\n\n### Conversation Schema\n\n```sql\n-- Conversations (1:1 or group)\nCREATE TABLE conversations (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  type text CHECK (type IN ('direct', 'group')) DEFAULT 'direct',\n  group_id uuid REFERENCES groups(id) ON DELETE CASCADE,\n  created_at timestamptz DEFAULT now()\n);\n\n-- Conversation participants\nCREATE TABLE conversation_participants (\n  conversation_id uuid REFERENCES conversations(id) ON DELETE CASCADE,\n  user_id uuid REFERENCES profiles(id) ON DELETE CASCADE,\n  last_read_at timestamptz DEFAULT now(),\n  muted_until timestamptz,\n  PRIMARY KEY (conversation_id, user_id)\n);\n\n-- Messages\nCREATE TABLE messages (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  conversation_id uuid REFERENCES conversations(id) ON DELETE CASCADE,\n  sender_id uuid REFERENCES profiles(id) ON DELETE SET NULL,\n  content text NOT NULL,\n  message_type text DEFAULT 'text', -- 'text', 'image', 'system'\n  created_at timestamptz DEFAULT now(),\n  edited_at timestamptz,\n  deleted_at timestamptz\n);\n\n-- Indexes\nCREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at DESC);\nCREATE INDEX idx_conversation_participants_user ON conversation_participants(user_id);\n\n-- RLS Policies\nALTER TABLE conversations ENABLE ROW LEVEL SECURITY;\nALTER TABLE conversation_participants ENABLE ROW LEVEL SECURITY;\nALTER TABLE messages ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Participants see conversations\" ON conversations\n  FOR SELECT USING (\n    EXISTS (\n      SELECT 1 FROM conversation_participants\n      WHERE conversation_participants.conversation_id = conversations.id\n        AND conversation_participants.user_id = auth.uid()\n    )\n  );\n\nCREATE POLICY \"Participants see messages\" ON messages\n  FOR SELECT USING (\n    EXISTS (\n      SELECT 1 FROM conversation_participants\n      WHERE conversation_participants.conversation_id = messages.conversation_id\n        AND conversation_participants.user_id = auth.uid()\n    )\n    AND deleted_at IS NULL\n  );\n\nCREATE POLICY \"Participants send messages\" ON messages\n  FOR INSERT WITH CHECK (\n    auth.uid() = sender_id\n    AND EXISTS (\n      SELECT 1 FROM conversation_participants\n      WHERE conversation_participants.conversation_id = messages.conversation_id\n        AND conversation_participants.user_id = auth.uid()\n    )\n  );\n```\n\n### Get or Create DM Conversation\n\n```sql\nCREATE OR REPLACE FUNCTION get_or_create_dm(other_user_id uuid)\nRETURNS conversations AS $$\nDECLARE\n  existing_conversation conversations;\n  new_conversation conversations;\nBEGIN\n  -- Check for existing DM\n  SELECT c.* INTO existing_conversation\n  FROM conversations c\n  WHERE c.type = 'direct'\n    AND EXISTS (\n      SELECT 1 FROM conversation_participants cp1\n      WHERE cp1.conversation_id = c.id AND cp1.user_id = auth.uid()\n    )\n    AND EXISTS (\n      SELECT 1 FROM conversation_participants cp2\n      WHERE cp2.conversation_id = c.id AND cp2.user_id = other_user_id\n    )\n    AND (SELECT count(*) FROM conversation_participants WHERE conversation_id = c.id) = 2\n  LIMIT 1;\n\n  IF existing_conversation IS NOT NULL THEN\n    RETURN existing_conversation;\n  END IF;\n\n  -- Create new conversation\n  INSERT INTO conversations (type)\n  VALUES ('direct')\n  RETURNING * INTO new_conversation;\n\n  -- Add participants\n  INSERT INTO conversation_participants (conversation_id, user_id)\n  VALUES\n    (new_conversation.id, auth.uid()),\n    (new_conversation.id, other_user_id);\n\n  RETURN new_conversation;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\n## Real-Time Subscriptions\n\n```typescript\n// Subscribe to new messages\nconst subscription = supabase\n  .channel('messages')\n  .on(\n    'postgres_changes',\n    {\n      event: 'INSERT',\n      schema: 'public',\n      table: 'messages',\n      filter: `conversation_id=eq.${conversationId}`\n    },\n    (payload) => {\n      addMessage(payload.new);\n    }\n  )\n  .subscribe();\n\n// Subscribe to friend requests\nconst friendRequests = supabase\n  .channel('friend-requests')\n  .on(\n    'postgres_changes',\n    {\n      event: 'INSERT',\n      schema: 'public',\n      table: 'friendships',\n      filter: `addressee_id=eq.${userId}`\n    },\n    (payload) => {\n      showNotification('New friend request!');\n    }\n  )\n  .subscribe();\n```\n\n## Performance Tips\n\n1. **Index foreign keys and filter columns**\n2. **Use `(SELECT auth.uid())` in policies for JWT caching**\n3. **Paginate messages with cursor-based pagination**\n4. **Consider materialized views for friend counts**\n5. **Use database functions for complex operations**\n6. **Clean up expired ephemeral groups with scheduled job**\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "supabase-admin/SKILL.md",
      "size": 7070,
      "content": "---\nname: supabase-admin\ndescription: Supabase administration, RLS policies, migrations, and schema design. Use for database architecture, Row Level Security, performance tuning, auth integration. Activate on \"Supabase\", \"RLS\", \"migration\", \"policy\", \"schema\", \"auth.uid()\". NOT for Supabase Auth UI configuration (use dashboard), edge functions (use cloudflare-worker-dev), or general SQL without Supabase context.\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Grep\n  - Glob\n  - mcp__supabase__*\ncategory: DevOps & Site Reliability\ntags:\n  - supabase\n  - rls\n  - database\n  - postgres\n  - migration\n  - schema\n  - security\n---\n\n# Supabase Administration Expert\n\nMaster Supabase schema design, Row Level Security policies, migrations, and performance optimization for production applications.\n\n## When to Use\n\n✅ **USE this skill for:**\n- Row Level Security (RLS) policy design and debugging\n- Database migrations and schema changes\n- Auth integration (triggers, profile creation)\n- Query performance optimization\n- Supabase-specific SQL patterns (`auth.uid()`, `auth.jwt()`)\n\n❌ **DO NOT use for:**\n- Supabase Auth UI configuration → use Supabase dashboard docs\n- Edge Functions → use `cloudflare-worker-dev` skill\n- General PostgreSQL without Supabase context → use standard SQL resources\n- Client-side Supabase SDK usage → use Supabase JS docs\n\n## Core Competencies\n\n### 1. Row Level Security (RLS)\n\n**Always Enable RLS on User Tables:**\n```sql\nALTER TABLE your_table ENABLE ROW LEVEL SECURITY;\n```\n\n**Policy Patterns:**\n\n```sql\n-- Public read, authenticated write\nCREATE POLICY \"Public read\" ON posts FOR SELECT USING (true);\nCREATE POLICY \"Owners can write\" ON posts FOR INSERT\n  WITH CHECK (auth.uid() = user_id);\n\n-- Owner-only access\nCREATE POLICY \"Users own their data\" ON profiles\n  FOR ALL USING (auth.uid() = id);\n\n-- Role-based access\nCREATE POLICY \"Admins can do anything\" ON content\n  FOR ALL USING (\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE profiles.id = auth.uid()\n      AND profiles.role = 'admin'\n    )\n  );\n```\n\n**Performance-Critical: Index auth.uid() Columns:**\n```sql\n-- 100x performance improvement for RLS policies\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_profiles_id ON profiles(id);\n```\n\n**Subquery Optimization for JWT Functions:**\n```sql\n-- BAD: JWT parsed for every row\nCREATE POLICY \"slow\" ON posts FOR SELECT\n  USING (user_id = auth.uid());\n\n-- GOOD: JWT parsed once via subquery\nCREATE POLICY \"fast\" ON posts FOR SELECT\n  USING (user_id = (SELECT auth.uid()));\n```\n\n### 2. Migration Best Practices\n\n**File Naming Convention:**\n```\nsupabase/migrations/\n├── 001_initial_schema.sql\n├── 002_add_profiles_trigger.sql\n├── 003_forum_tables.sql\n└── 004_add_rls_policies.sql\n```\n\n**Migration Template:**\n```sql\n-- Migration: 005_feature_name\n-- Description: What this migration does\n-- Author: name\n-- Date: YYYY-MM-DD\n\n-- Up migration\nBEGIN;\n\n-- Your DDL here\nCREATE TABLE ...;\nALTER TABLE ...;\nCREATE POLICY ...;\n\nCOMMIT;\n\n-- Down migration (as comment for reference)\n-- DROP TABLE ...;\n-- DROP POLICY ...;\n```\n\n**Safe Migration Patterns:**\n```sql\n-- Add column with default (no table lock)\nALTER TABLE users ADD COLUMN status text DEFAULT 'active';\n\n-- Add NOT NULL constraint safely\nALTER TABLE users ADD COLUMN email text;\nUPDATE users SET email = 'unknown@example.com' WHERE email IS NULL;\nALTER TABLE users ALTER COLUMN email SET NOT NULL;\n\n-- Create index concurrently (no lock)\nCREATE INDEX CONCURRENTLY idx_users_email ON users(email);\n```\n\n### 3. Auth Integration\n\n**Auto-create Profile on Signup:**\n```sql\n-- Function to create profile\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO public.profiles (id, email, display_name)\n  VALUES (\n    NEW.id,\n    NEW.email,\n    COALESCE(NEW.raw_user_meta_data->>'display_name', split_part(NEW.email, '@', 1))\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Trigger on auth.users\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();\n```\n\n**Check Auth Status in Policies:**\n```sql\n-- Authenticated users only\nCREATE POLICY \"Authenticated access\" ON data\n  FOR SELECT USING (auth.role() = 'authenticated');\n\n-- Get current user's ID\nSELECT auth.uid();\n\n-- Get current user's JWT claims\nSELECT auth.jwt();\n```\n\n### 4. Common Schema Patterns\n\n**Timestamps with Defaults:**\n```sql\nCREATE TABLE posts (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,\n  content text NOT NULL,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now()\n);\n\n-- Auto-update updated_at\nCREATE OR REPLACE FUNCTION update_updated_at()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_posts_updated_at\n  BEFORE UPDATE ON posts\n  FOR EACH ROW EXECUTE FUNCTION update_updated_at();\n```\n\n**Soft Delete Pattern:**\n```sql\nALTER TABLE posts ADD COLUMN deleted_at timestamptz;\n\nCREATE POLICY \"Hide deleted\" ON posts\n  FOR SELECT USING (deleted_at IS NULL);\n```\n\n**Full-Text Search:**\n```sql\n-- Add search vector column\nALTER TABLE posts ADD COLUMN search_vector tsvector;\n\n-- Create GIN index\nCREATE INDEX idx_posts_search ON posts USING GIN(search_vector);\n\n-- Update function\nCREATE OR REPLACE FUNCTION posts_search_update()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.search_vector := to_tsvector('english', COALESCE(NEW.title, '') || ' ' || COALESCE(NEW.content, ''));\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Search query\nSELECT * FROM posts\nWHERE search_vector @@ plainto_tsquery('english', 'search terms');\n```\n\n### 5. Debugging RLS Issues\n\n**Common Problem: Empty Results, No Error**\n```sql\n-- Check if RLS is enabled\nSELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public';\n\n-- List all policies\nSELECT * FROM pg_policies WHERE tablename = 'your_table';\n\n-- Test as specific role\nSET ROLE anon;\nSELECT * FROM your_table LIMIT 1;\nRESET ROLE;\n\n-- Test with specific user\nSET request.jwt.claims TO '{\"sub\": \"user-uuid-here\"}';\nSELECT * FROM your_table;\n```\n\n**Diagnostic Query:**\n```sql\n-- Check what the current user can see\nSELECT\n  auth.uid() as current_user,\n  auth.role() as current_role,\n  (SELECT count(*) FROM your_table) as visible_rows;\n```\n\n## Quick Reference\n\n| Task | Command |\n|------|---------|\n| Enable RLS | `ALTER TABLE t ENABLE ROW LEVEL SECURITY;` |\n| Create policy | `CREATE POLICY \"name\" ON t FOR action USING (condition);` |\n| Drop policy | `DROP POLICY \"name\" ON t;` |\n| Check policies | `SELECT * FROM pg_policies WHERE tablename = 't';` |\n| Current user | `SELECT auth.uid();` |\n| Force RLS for owner | `ALTER TABLE t FORCE ROW LEVEL SECURITY;` |\n\n## References\n\nSee `/references/` for detailed guides:\n- `rls-patterns.md` - Advanced RLS policy patterns\n- `migration-checklist.md` - Pre-deployment checklist\n- `performance-tuning.md` - Query and index optimization\n- `social-schema.md` - Schema patterns for social features\n"
    }
  ]
}