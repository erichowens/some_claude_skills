{
  "name": "github-actions-pipeline-builder",
  "type": "folder",
  "path": "github-actions-pipeline-builder",
  "children": [
    {
      "name": "assets",
      "type": "folder",
      "path": "github-actions-pipeline-builder/assets",
      "children": [
        {
          "name": "workflows",
          "type": "folder",
          "path": "github-actions-pipeline-builder/assets/workflows",
          "children": [
            {
              "name": "full-stack-ci-cd.yml",
              "type": "file",
              "path": "github-actions-pipeline-builder/assets/workflows/full-stack-ci-cd.yml",
              "size": 4278
            }
          ]
        }
      ]
    },
    {
      "name": "references",
      "type": "folder",
      "path": "github-actions-pipeline-builder/references",
      "children": [
        {
          "name": "advanced-caching.md",
          "type": "file",
          "path": "github-actions-pipeline-builder/references/advanced-caching.md",
          "size": 9064,
          "content": "# Advanced Caching Strategies\n\nProduction patterns for dramatically faster GitHub Actions workflows using intelligent caching.\n\n## Why Caching Matters\n\n**Impact**: Reduces build times by 50-90%\n- Typical `npm install`: 2-5 minutes ‚Üí 30 seconds with cache\n- Docker builds: 10 minutes ‚Üí 2 minutes with layer caching\n- Test databases: 1 minute setup ‚Üí 5 seconds from cache\n\n---\n\n## Pattern 1: npm Dependencies (Basic)\n\n```yaml\n- name: Cache npm dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n    restore-keys: |\n      ${{ runner.os }}-node-\n```\n\n**How it works**:\n- `key`: Exact cache match (hash of package-lock.json)\n- `restore-keys`: Fallback if exact match fails\n- Cache invalidated when package-lock.json changes\n\n**Alternative**: Use setup-node built-in caching\n```yaml\n- uses: actions/setup-node@v4\n  with:\n    node-version: 18\n    cache: 'npm'  # Automatic caching\n```\n\n---\n\n## Pattern 2: Multiple Cache Paths\n\nCache multiple directories for monorepos.\n\n```yaml\n- uses: actions/cache@v4\n  with:\n    path: |\n      ~/.npm\n      ~/.cache\n      node_modules\n      **/node_modules\n    key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}\n    restore-keys: |\n      ${{ runner.os }}-deps-\n```\n\n---\n\n## Pattern 3: Docker Layer Caching\n\nDramatically speed up Docker builds.\n\n```yaml\n- name: Set up Docker Buildx\n  uses: docker/setup-buildx-action@v3\n\n- name: Build and push\n  uses: docker/build-push-action@v5\n  with:\n    context: .\n    push: true\n    tags: myapp:latest\n    cache-from: type=gha\n    cache-to: type=gha,mode=max\n```\n\n**mode=max**: Cache all layers (not just final image)\n\n**Impact**:\n- First build: 10 minutes\n- Cached build (no changes): 20 seconds\n- Cached build (code changes): 2 minutes\n\n---\n\n## Pattern 4: Conditional Caching (Cache Only on Main)\n\nSave cache space by only caching on main branch.\n\n```yaml\n- uses: actions/cache@v4\n  id: cache\n  with:\n    path: node_modules\n    key: ${{ runner.os }}-deps-${{ hashFiles('package-lock.json') }}\n\n- name: Install dependencies\n  if: steps.cache.outputs.cache-hit != 'true'\n  run: npm ci\n\n- name: Save cache\n  if: github.ref == 'refs/heads/main' && steps.cache.outputs.cache-hit != 'true'\n  uses: actions/cache/save@v4\n  with:\n    path: node_modules\n    key: ${{ runner.os }}-deps-${{ hashFiles('package-lock.json') }}\n```\n\n---\n\n## Pattern 5: Build Output Caching\n\nCache compiled assets across jobs.\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      # Check if build exists in cache\n      - uses: actions/cache@v4\n        id: build-cache\n        with:\n          path: dist/\n          key: build-${{ hashFiles('src/**') }}\n\n      # Only build if cache miss\n      - name: Build\n        if: steps.build-cache.outputs.cache-hit != 'true'\n        run: npm run build\n\n  test:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      # Restore build from cache\n      - uses: actions/cache@v4\n        with:\n          path: dist/\n          key: build-${{ hashFiles('src/**') }}\n\n      - run: npm test\n```\n\n---\n\n## Pattern 6: Test Database Caching\n\nCache test database setup.\n\n```yaml\n- name: Cache PostgreSQL data\n  uses: actions/cache@v4\n  with:\n    path: |\n      /var/lib/postgresql/data\n      ~/.pgdata\n    key: postgres-${{ hashFiles('**/schema.sql') }}\n\n- name: Start PostgreSQL\n  run: |\n    if [ ! -d \"$HOME/.pgdata\" ]; then\n      # First time: initialize and seed\n      docker run -d -p 5432:5432 \\\n        -e POSTGRES_PASSWORD=test \\\n        -v $HOME/.pgdata:/var/lib/postgresql/data \\\n        postgres:15\n      sleep 5\n      psql -f schema.sql\n      psql -f seeds.sql\n    else\n      # Cached: just start\n      docker run -d -p 5432:5432 \\\n        -v $HOME/.pgdata:/var/lib/postgresql/data \\\n        postgres:15\n    fi\n```\n\n---\n\n## Pattern 7: Turbo/Nx Incremental Builds\n\nCache build outputs for monorepo tools.\n\n```yaml\n# Turborepo\n- uses: actions/cache@v4\n  with:\n    path: .turbo\n    key: turbo-${{ runner.os }}-${{ github.sha }}\n    restore-keys: |\n      turbo-${{ runner.os }}-\n\n- run: npx turbo build --cache-dir=.turbo\n\n# Nx\n- uses: actions/cache@v4\n  with:\n    path: |\n      node_modules/.cache/nx\n      .nx/cache\n    key: nx-${{ runner.os }}-${{ github.sha }}\n    restore-keys: |\n      nx-${{ runner.os }}-\n\n- run: npx nx run-many --target=build --all\n```\n\n---\n\n## Pattern 8: Pip Dependencies (Python)\n\n```yaml\n- uses: actions/setup-python@v5\n  with:\n    python-version: '3.11'\n    cache: 'pip'\n\n# Or manual:\n- uses: actions/cache@v4\n  with:\n    path: ~/.cache/pip\n    key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n    restore-keys: |\n      ${{ runner.os }}-pip-\n```\n\n---\n\n## Pattern 9: Cargo Dependencies (Rust)\n\n```yaml\n- uses: actions/cache@v4\n  with:\n    path: |\n      ~/.cargo/bin/\n      ~/.cargo/registry/index/\n      ~/.cargo/registry/cache/\n      ~/.cargo/git/db/\n      target/\n    key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n```\n\n---\n\n## Pattern 10: Gradle Dependencies (Java)\n\n```yaml\n- uses: actions/setup-java@v4\n  with:\n    java-version: '17'\n    distribution: 'temurin'\n    cache: 'gradle'\n\n# Or manual:\n- uses: actions/cache@v4\n  with:\n    path: |\n      ~/.gradle/caches\n      ~/.gradle/wrapper\n    key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}\n```\n\n---\n\n## Cache Management\n\n### Cache Limits\n\n- **Per repository**: 10 GB total\n- **Per cache entry**: No hard limit (but slow if &gt;1 GB)\n- **Retention**: 7 days if not accessed\n\n### Monitoring Cache Usage\n\n```bash\n# List caches\ngh api repos/{owner}/{repo}/actions/caches\n\n# Delete specific cache\ngh api -X DELETE repos/{owner}/{repo}/actions/caches/{cache_id}\n```\n\n### Cache Eviction Strategy\n\nOldest caches are deleted first when limit reached.\n\n**Best practices**:\n- Use specific cache keys (include hash)\n- Clean up old caches regularly\n- Limit cache size (compress if needed)\n\n---\n\n## Advanced Patterns\n\n### Pattern 11: Parallel Job Caching\n\nShare cache between parallel matrix jobs.\n\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node: [16, 18, 20]\n    steps:\n      - uses: actions/cache@v4\n        with:\n          path: ~/.npm\n          key: npm-${{ matrix.node }}-${{ hashFiles('package-lock.json') }}\n          restore-keys: |\n            npm-${{ matrix.node }}-\n            npm-  # Fallback to any Node version\n```\n\n### Pattern 12: Compression Before Caching\n\nFor large directories.\n\n```yaml\n- name: Compress node_modules\n  run: tar -czf node_modules.tar.gz node_modules\n\n- uses: actions/cache@v4\n  with:\n    path: node_modules.tar.gz\n    key: deps-${{ hashFiles('package-lock.json') }}\n\n- name: Extract if cache hit\n  if: steps.cache.outputs.cache-hit == 'true'\n  run: tar -xzf node_modules.tar.gz\n```\n\n### Pattern 13: Warm Cache (Pre-populate)\n\nRun a scheduled workflow to keep caches warm.\n\n```yaml\nname: Warm Cache\n\non:\n  schedule:\n    - cron: '0 2 * * *'  # Daily at 2 AM\n\njobs:\n  warm:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/cache@v4\n        with:\n          path: ~/.npm\n          key: warm-${{ hashFiles('package-lock.json') }}\n\n      - run: npm ci\n```\n\n---\n\n## Troubleshooting\n\n### Cache Not Restored\n\n**Symptom**: Build always slow, cache never hits\n\n**Fixes**:\n1. Check cache key matches exactly\n2. Verify path exists\n3. Ensure cache was saved in previous run\n\n**Debug**:\n```yaml\n- name: Debug cache\n  run: |\n    echo \"Cache key: ${{ runner.os }}-deps-${{ hashFiles('package-lock.json') }}\"\n    ls -la ~/.npm || echo \"Cache directory doesn't exist\"\n```\n\n### Cache Too Large\n\n**Symptom**: Warning \"Cache size exceeds limit\"\n\n**Fixes**:\n1. Compress before caching\n2. Exclude unnecessary files\n3. Split into multiple caches\n\n### Stale Cache\n\n**Symptom**: Using old dependencies despite package-lock.json change\n\n**Fix**: Clear caches manually or change cache key format\n\n---\n\n## Production Checklist\n\n```\n‚ñ° Dependencies cached (npm/pip/cargo/etc.)\n‚ñ° Build outputs cached between jobs\n‚ñ° Docker layer caching enabled\n‚ñ° Cache keys include file hashes\n‚ñ° Restore-keys provide fallbacks\n‚ñ° Cache size monitored (< 1 GB per entry)\n‚ñ° Conditional saving (main branch only)\n‚ñ° Cache invalidation strategy defined\n‚ñ° Compression used for large caches\n‚ñ° Warm cache scheduled for main branch\n```\n\n---\n\n## Performance Metrics\n\nTrack cache effectiveness:\n\n```yaml\n- name: Cache metrics\n  run: |\n    if [ \"${{ steps.cache.outputs.cache-hit }}\" == \"true\" ]; then\n      echo \"‚úÖ Cache hit - saved time\"\n    else\n      echo \"‚ö†Ô∏è  Cache miss - will save for next run\"\n    fi\n```\n\n---\n\n## Resources\n\n- [GitHub Actions Cache Docs](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows)\n- [actions/cache README](https://github.com/actions/cache)\n- [Cache Limits](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy)\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "github-actions-pipeline-builder/scripts",
      "children": [
        {
          "name": "action_usage_analyzer.ts",
          "type": "file",
          "path": "github-actions-pipeline-builder/scripts/action_usage_analyzer.ts",
          "size": 7346,
          "content": "#!/usr/bin/env node\n/**\n * GitHub Actions Usage Analyzer\n *\n * Analyzes workflows to find outdated actions and suggest updates.\n *\n * Usage: npx tsx action_usage_analyzer.ts [workflow-dir]\n *\n * Examples:\n *   npx tsx action_usage_analyzer.ts .github/workflows\n *\n * Dependencies: npm install yaml\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { parse } from 'yaml';\n\ninterface ActionUsage {\n  action: string;\n  version: string;\n  file: string;\n  count: number;\n}\n\ninterface UpdateSuggestion {\n  action: string;\n  currentVersion: string;\n  latestVersion: string;\n  breaking: boolean;\n  notes?: string;\n}\n\n// Known action versions (as of Jan 2024)\nconst LATEST_VERSIONS: Record<string, { version: string; breaking?: boolean; notes?: string }> = {\n  'actions/checkout': {\n    version: 'v4',\n    breaking: false,\n    notes: 'v4 uses Node.js 20'\n  },\n  'actions/setup-node': {\n    version: 'v4',\n    breaking: false,\n    notes: 'v4 uses Node.js 20'\n  },\n  'actions/setup-python': {\n    version: 'v5',\n    breaking: false\n  },\n  'actions/cache': {\n    version: 'v4',\n    breaking: false\n  },\n  'actions/upload-artifact': {\n    version: 'v4',\n    breaking: true,\n    notes: 'v4 changes artifact retention and download behavior'\n  },\n  'actions/download-artifact': {\n    version: 'v4',\n    breaking: true,\n    notes: 'v4 changes download location and naming'\n  },\n  'docker/build-push-action': {\n    version: 'v5',\n    breaking: false\n  },\n  'docker/login-action': {\n    version: 'v3',\n    breaking: false\n  },\n  'codecov/codecov-action': {\n    version: 'v4',\n    breaking: false\n  },\n  'slackapi/slack-github-action': {\n    version: 'v1.25',\n    breaking: false\n  }\n};\n\nclass ActionUsageAnalyzer {\n  private usages: Map<string, ActionUsage[]> = new Map();\n  private suggestions: UpdateSuggestion[] = [];\n\n  analyzeDirectory(dir: string): void {\n    const files = fs.readdirSync(dir);\n\n    files.forEach(file => {\n      if (file.endsWith('.yml') || file.endsWith('.yaml')) {\n        this.analyzeFile(path.join(dir, file));\n      }\n    });\n  }\n\n  analyzeFile(filePath: string): void {\n    const content = fs.readFileSync(filePath, 'utf-8');\n\n    try {\n      const workflow = parse(content);\n\n      if (!workflow?.jobs) return;\n\n      Object.entries(workflow.jobs).forEach(([_, job]: [string, any]) => {\n        job.steps?.forEach((step: any) => {\n          if (step.uses) {\n            this.recordAction(step.uses, filePath);\n          }\n        });\n      });\n    } catch (error) {\n      console.error(`Failed to parse ${filePath}:`, error);\n    }\n  }\n\n  private recordAction(usesString: string, file: string): void {\n    // Parse action@version format\n    const match = usesString.match(/^([^@]+)@(.+)$/);\n    if (!match) return;\n\n    const [, action, version] = match;\n\n    if (!this.usages.has(action)) {\n      this.usages.set(action, []);\n    }\n\n    const existing = this.usages.get(action)!.find(\n      u => u.version === version && u.file === file\n    );\n\n    if (existing) {\n      existing.count++;\n    } else {\n      this.usages.get(action)!.push({\n        action,\n        version,\n        file,\n        count: 1\n      });\n    }\n\n    // Check if update available\n    const latest = LATEST_VERSIONS[action];\n    if (latest && version !== latest.version) {\n      const existingSuggestion = this.suggestions.find(\n        s => s.action === action && s.currentVersion === version\n      );\n\n      if (!existingSuggestion) {\n        this.suggestions.push({\n          action,\n          currentVersion: version,\n          latestVersion: latest.version,\n          breaking: latest.breaking || false,\n          notes: latest.notes\n        });\n      }\n    }\n  }\n\n  report(): void {\n    console.log('\\nüìä GitHub Actions Usage Report\\n');\n    console.log('‚îÄ'.repeat(70));\n\n    // Group by action\n    const actions = Array.from(this.usages.keys()).sort();\n\n    if (actions.length === 0) {\n      console.log('No actions found in workflows.');\n      return;\n    }\n\n    console.log('\\nActions Used:\\n');\n\n    actions.forEach(action => {\n      const usages = this.usages.get(action)!;\n      const totalCount = usages.reduce((sum, u) => sum + u.count, 0);\n\n      console.log(`üì¶ ${action}`);\n\n      // Group by version\n      const versionMap = new Map<string, number>();\n      usages.forEach(u => {\n        versionMap.set(u.version, (versionMap.get(u.version) || 0) + u.count);\n      });\n\n      versionMap.forEach((count, version) => {\n        const latest = LATEST_VERSIONS[action];\n        const isLatest = latest && version === latest.version;\n        const icon = isLatest ? '‚úÖ' : '‚ö†Ô∏è ';\n        console.log(`  ${icon} ${version} (${count} usage${count > 1 ? 's' : ''})`);\n      });\n\n      console.log('');\n    });\n\n    // Update suggestions\n    if (this.suggestions.length > 0) {\n      console.log('‚îÄ'.repeat(70));\n      console.log('\\nüí° Update Suggestions:\\n');\n\n      this.suggestions.forEach(suggestion => {\n        const icon = suggestion.breaking ? 'üî¥' : 'üü¢';\n        console.log(`${icon} ${suggestion.action}`);\n        console.log(`  Current: ${suggestion.currentVersion}`);\n        console.log(`  Latest:  ${suggestion.latestVersion}`);\n\n        if (suggestion.breaking) {\n          console.log('  ‚ö†Ô∏è  Breaking changes - review migration guide');\n        }\n\n        if (suggestion.notes) {\n          console.log(`  ‚ÑπÔ∏è  ${suggestion.notes}`);\n        }\n\n        console.log('');\n      });\n\n      console.log('‚îÄ'.repeat(70));\n      console.log('\\nTo update an action:');\n      console.log('  Replace: uses: actions/checkout@v3');\n      console.log('  With:    uses: actions/checkout@v4');\n    } else {\n      console.log('‚úÖ All actions are up to date!\\n');\n    }\n\n    // Security notes\n    console.log('\\nüîí Security Best Practices:\\n');\n    console.log('  ‚Ä¢ Pin actions to specific SHA for security:');\n    console.log('    uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1');\n    console.log('  ‚Ä¢ Use Dependabot to auto-update actions:');\n    console.log('    Create .github/dependabot.yml with github-actions ecosystem');\n    console.log('');\n  }\n\n  generateDependabotConfig(): string {\n    return `# .github/dependabot.yml\n# Auto-update GitHub Actions\n\nversion: 2\nupdates:\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    open-pull-requests-limit: 10\n    labels:\n      - \"dependencies\"\n      - \"github-actions\"\n`;\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  const dir = args[0] || '.github/workflows';\n\n  if (!fs.existsSync(dir)) {\n    console.error(`‚ùå Directory not found: ${dir}`);\n    console.error('\\nUsage: npx tsx action_usage_analyzer.ts [workflow-dir]');\n    console.error('Example: npx tsx action_usage_analyzer.ts .github/workflows');\n    process.exit(1);\n  }\n\n  const analyzer = new ActionUsageAnalyzer();\n  analyzer.analyzeDirectory(dir);\n  analyzer.report();\n\n  // Offer to create Dependabot config\n  if (args.includes('--create-dependabot')) {\n    const config = analyzer.generateDependabotConfig();\n    const configPath = '.github/dependabot.yml';\n\n    fs.mkdirSync(path.dirname(configPath), { recursive: true });\n    fs.writeFileSync(configPath, config);\n\n    console.log(`‚úÖ Created ${configPath}`);\n  }\n}\n\nexport { ActionUsageAnalyzer };\n"
        },
        {
          "name": "workflow_validator.ts",
          "type": "file",
          "path": "github-actions-pipeline-builder/scripts/workflow_validator.ts",
          "size": 7345,
          "content": "#!/usr/bin/env node\n/**\n * GitHub Actions Workflow Validator\n *\n * Validates workflow YAML files for syntax errors and common issues.\n *\n * Usage: npx tsx workflow_validator.ts [workflow-file]\n *\n * Examples:\n *   npx tsx workflow_validator.ts .github/workflows/ci.yml\n *   npx tsx workflow_validator.ts .github/workflows/*.yml\n *\n * Dependencies: npm install yaml\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { parse } from 'yaml';\n\ninterface ValidationIssue {\n  file: string;\n  line?: number;\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  suggestion?: string;\n}\n\nclass WorkflowValidator {\n  private issues: ValidationIssue[] = [];\n\n  validateFile(filePath: string): void {\n    const content = fs.readFileSync(filePath, 'utf-8');\n\n    try {\n      const workflow = parse(content);\n\n      if (!workflow) {\n        this.addIssue(filePath, 'error', 'Empty or invalid YAML file');\n        return;\n      }\n\n      // Required fields\n      if (!workflow.name) {\n        this.addIssue(filePath, 'warning', 'Missing workflow name');\n      }\n\n      if (!workflow.on) {\n        this.addIssue(filePath, 'error', 'Missing trigger (on:)');\n      }\n\n      if (!workflow.jobs) {\n        this.addIssue(filePath, 'error', 'No jobs defined');\n        return;\n      }\n\n      // Check each job\n      Object.entries(workflow.jobs).forEach(([jobName, job]: [string, any]) => {\n        this.validateJob(filePath, jobName, job);\n      });\n\n      // Check for common issues\n      this.checkCommonIssues(filePath, workflow);\n\n    } catch (error: any) {\n      this.addIssue(filePath, 'error', `YAML parse error: ${error.message}`);\n    }\n  }\n\n  private validateJob(file: string, name: string, job: any): void {\n    if (!job['runs-on']) {\n      this.addIssue(file, 'error', `Job '${name}' missing runs-on`);\n    }\n\n    if (!job.steps || job.steps.length === 0) {\n      this.addIssue(file, 'error', `Job '${name}' has no steps`);\n    }\n\n    // Check each step\n    job.steps?.forEach((step: any, index: number) => {\n      if (!step.uses && !step.run) {\n        this.addIssue(\n          file,\n          'error',\n          `Job '${name}', step ${index + 1}: Must have 'uses' or 'run'`\n        );\n      }\n\n      if (!step.name) {\n        this.addIssue(\n          file,\n          'info',\n          `Job '${name}', step ${index + 1}: Consider adding a name for clarity`\n        );\n      }\n    });\n  }\n\n  private checkCommonIssues(file: string, workflow: any): void {\n    const content = JSON.stringify(workflow);\n\n    // Check for missing caching\n    if (content.includes('npm install') && !content.includes('cache')) {\n      this.addIssue(\n        file,\n        'warning',\n        'Using npm install without caching',\n        'Add cache: \"npm\" to actions/setup-node or use actions/cache'\n      );\n    }\n\n    // Check for hardcoded secrets\n    if (content.match(/['\\\"]?[A-Za-z0-9]{20,}['\\\"]?/) && !content.includes('secrets.')) {\n      this.addIssue(\n        file,\n        'warning',\n        'Possible hardcoded secret detected',\n        'Use ${{ secrets.SECRET_NAME }} instead'\n      );\n    }\n\n    // Check for npm install vs npm ci\n    if (content.includes('npm install') && !content.includes('npm ci')) {\n      this.addIssue(\n        file,\n        'info',\n        'Consider using npm ci instead of npm install',\n        'npm ci is faster and more reliable in CI environments'\n      );\n    }\n\n    // Check for checkout action version\n    if (content.includes('actions/checkout@v1') || content.includes('actions/checkout@v2')) {\n      this.addIssue(\n        file,\n        'warning',\n        'Using outdated actions/checkout version',\n        'Update to actions/checkout@v3 or later'\n      );\n    }\n\n    // Check for missing dependency on job\n    Object.entries(workflow.jobs).forEach(([jobName, job]: [string, any]) => {\n      if (job.needs && !Array.isArray(job.needs)) {\n        const dependency = job.needs as string;\n        if (!workflow.jobs[dependency]) {\n          this.addIssue(\n            file,\n            'error',\n            `Job '${jobName}' depends on non-existent job '${dependency}'`\n          );\n        }\n      }\n    });\n\n    // Check for matrix without strategy\n    if (content.includes('matrix.') && !content.includes('strategy:')) {\n      this.addIssue(\n        file,\n        'error',\n        'Using matrix variable without strategy.matrix defined'\n      );\n    }\n\n    // Check for environment secrets without environment\n    Object.entries(workflow.jobs).forEach(([jobName, job]: [string, any]) => {\n      const jobStr = JSON.stringify(job);\n      if (jobStr.includes('secrets.') && !job.environment) {\n        this.addIssue(\n          file,\n          'info',\n          `Job '${jobName}' uses secrets but no environment specified`,\n          'Consider using environment for better secret management'\n        );\n      }\n    });\n  }\n\n  private addIssue(\n    file: string,\n    severity: ValidationIssue['severity'],\n    message: string,\n    suggestion?: string\n  ): void {\n    this.issues.push({ file, severity, message, suggestion });\n  }\n\n  report(): void {\n    if (this.issues.length === 0) {\n      console.log('‚úÖ No issues found!');\n      return;\n    }\n\n    const errors = this.issues.filter(i => i.severity === 'error');\n    const warnings = this.issues.filter(i => i.severity === 'warning');\n    const info = this.issues.filter(i => i.severity === 'info');\n\n    console.log(`\\nüìã Workflow Validation Report\\n`);\n    console.log(`Found ${errors.length} errors, ${warnings.length} warnings, ${info.length} suggestions\\n`);\n\n    const printIssues = (issues: ValidationIssue[], icon: string) => {\n      if (issues.length === 0) return;\n\n      issues.forEach(issue => {\n        console.log(`${icon} ${issue.file}`);\n        console.log(`  ${issue.message}`);\n        if (issue.suggestion) {\n          console.log(`  üí° ${issue.suggestion}`);\n        }\n        console.log('');\n      });\n    };\n\n    if (errors.length > 0) {\n      console.log('üö® Errors:\\n');\n      printIssues(errors, '‚ùå');\n    }\n\n    if (warnings.length > 0) {\n      console.log('‚ö†Ô∏è  Warnings:\\n');\n      printIssues(warnings, '‚ö†Ô∏è ');\n    }\n\n    if (info.length > 0) {\n      console.log('üí° Suggestions:\\n');\n      printIssues(info, '‚ÑπÔ∏è ');\n    }\n\n    if (errors.length > 0) {\n      process.exit(1);\n    }\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0) {\n    console.log('Usage: npx tsx workflow_validator.ts <workflow-file>');\n    console.log('\\nExamples:');\n    console.log('  npx tsx workflow_validator.ts .github/workflows/ci.yml');\n    console.log('  npx tsx workflow_validator.ts .github/workflows/*.yml');\n    process.exit(1);\n  }\n\n  const validator = new WorkflowValidator();\n\n  args.forEach(pattern => {\n    // Handle glob patterns\n    if (pattern.includes('*')) {\n      const dir = path.dirname(pattern);\n      const files = fs.readdirSync(dir).filter(f => f.endsWith('.yml') || f.endsWith('.yaml'));\n      files.forEach(file => {\n        validator.validateFile(path.join(dir, file));\n      });\n    } else {\n      if (!fs.existsSync(pattern)) {\n        console.error(`‚ùå File not found: ${pattern}`);\n        process.exit(1);\n      }\n      validator.validateFile(pattern);\n    }\n  });\n\n  validator.report();\n}\n\nexport { WorkflowValidator };\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "github-actions-pipeline-builder/SKILL.md",
      "size": 10758,
      "content": "---\nname: github-actions-pipeline-builder\ndescription: Build production CI/CD pipelines with GitHub Actions. Implements matrix builds, caching, deployments, testing, security scanning. Use for automated testing, deployments, release workflows. Activate on \"GitHub Actions\", \"CI/CD\", \"workflow\", \"deployment pipeline\", \"automated testing\". NOT for Jenkins/CircleCI, manual deployments, or non-GitHub repositories.\nallowed-tools: Read,Write,Edit,Bash\n---\n\n# GitHub Actions Pipeline Builder\n\nExpert in building production-grade CI/CD pipelines with GitHub Actions that are fast, reliable, and secure.\n\n## When to Use\n\n‚úÖ **Use for**:\n- Automated testing on every commit\n- Deployment to staging/production\n- Docker image building and publishing\n- Release automation with versioning\n- Security scanning and dependency audits\n- Code quality checks (linting, type checking)\n- Multi-environment workflows\n\n‚ùå **NOT for**:\n- Non-GitHub repositories (use Jenkins, CircleCI, etc.)\n- Complex pipelines better suited for dedicated CI/CD tools\n- Self-hosted runners (covered in advanced patterns)\n\n## Quick Decision Tree\n\n```\nDoes your project need:\n‚îú‚îÄ‚îÄ Testing on every PR? ‚Üí GitHub Actions\n‚îú‚îÄ‚îÄ Automated deployments? ‚Üí GitHub Actions\n‚îú‚îÄ‚îÄ Matrix builds (Node 16, 18, 20)? ‚Üí GitHub Actions\n‚îú‚îÄ‚îÄ Secrets management? ‚Üí GitHub Actions secrets\n‚îú‚îÄ‚îÄ Multi-cloud deployments? ‚Üí GitHub Actions + OIDC\n‚îî‚îÄ‚îÄ Sub-second builds? ‚Üí Consider build caching\n```\n\n---\n\n## Technology Selection\n\n### GitHub Actions vs Alternatives\n\n**Why GitHub Actions in 2024**:\n- **Native integration**: No third-party setup\n- **Free for public repos**: 2000 minutes/month for private\n- **Matrix builds**: Test multiple versions in parallel\n- **Marketplace**: 10,000+ pre-built actions\n- **OIDC support**: Keyless cloud deployments\n\n**Timeline**:\n- 2019: GitHub Actions released\n- 2020: Became standard for OSS projects\n- 2022: OIDC support for secure cloud auth\n- 2024: De facto CI/CD for GitHub repos\n\n### When to Use Alternatives\n\n| Scenario | Use | Why |\n|----------|-----|-----|\n| Self-hosted GitLab | GitLab CI | Native integration |\n| Complex enterprise workflows | Jenkins | More flexible |\n| Bitbucket repos | Bitbucket Pipelines | Native integration |\n| Extremely large repos (&gt;10GB) | BuildKite | Better for monorepos |\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: No Dependency Caching\n\n**Novice thinking**: \"Install dependencies fresh every time for consistency\"\n\n**Problem**: Wastes 2-5 minutes per build installing unchanged dependencies.\n\n**Wrong approach**:\n```yaml\n# ‚ùå Slow: Downloads all dependencies every run\n- name: Install dependencies\n  run: npm install\n```\n\n**Correct approach**:\n```yaml\n# ‚úÖ Fast: Cache dependencies, only download changes\n- name: Cache node_modules\n  uses: actions/cache@v3\n  with:\n    path: ~/.npm\n    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n    restore-keys: |\n      ${{ runner.os }}-node-\n\n- name: Install dependencies\n  run: npm ci  # Faster than npm install\n```\n\n**Impact**: Reduces install time from 3 minutes ‚Üí 30 seconds.\n\n**Timeline**:\n- Pre-2020: Most workflows had no caching\n- 2020+: Caching became standard\n- 2024: Setup actions include built-in caching\n\n---\n\n### Anti-Pattern 2: Duplicate YAML (No Matrix Builds)\n\n**Problem**: Copy-paste workflows for different Node versions.\n\n**Wrong approach**:\n```yaml\n# ‚ùå Duplicated workflows\njobs:\n  test-node-16:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - run: npm test\n\n  test-node-18:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18\n      - run: npm test\n\n  test-node-20:\n    # ... same steps again\n```\n\n**Correct approach**:\n```yaml\n# ‚úÖ DRY: Matrix build\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16, 18, 20]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n          cache: 'npm'\n      - run: npm ci\n      - run: npm test\n```\n\n**Benefits**: 66% less YAML, tests run in parallel.\n\n---\n\n### Anti-Pattern 3: Secrets in Code\n\n**Problem**: Hardcoded API keys, tokens visible in repo.\n\n**Symptoms**: Security scanner alerts, leaked credentials.\n\n**Correct approach**:\n```yaml\n# ‚úÖ Use GitHub Secrets\n- name: Deploy to production\n  env:\n    API_KEY: ${{ secrets.PRODUCTION_API_KEY }}\n    AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }}\n  run: |\n    ./deploy.sh\n```\n\n**Setting secrets**:\n1. Repo Settings ‚Üí Secrets and variables ‚Üí Actions\n2. New repository secret\n3. Name: `PRODUCTION_API_KEY`, Value: `sk-...`\n\n**Timeline**:\n- Pre-2022: Some teams committed .env files\n- 2022+: GitHub secret scanning blocks commits with keys\n- 2024: OIDC eliminates need for long-lived credentials\n\n---\n\n### Anti-Pattern 4: No Failure Notifications\n\n**Problem**: CI fails silently, team doesn't notice for hours.\n\n**Correct approach**:\n```yaml\n# ‚úÖ Slack notification on failure\n- name: Notify on failure\n  if: failure()\n  uses: slackapi/slack-github-action@v1\n  with:\n    payload: |\n      {\n        \"text\": \"‚ùå Build failed: ${{ github.event.head_commit.message }}\",\n        \"blocks\": [\n          {\n            \"type\": \"section\",\n            \"text\": {\n              \"type\": \"mrkdwn\",\n              \"text\": \"*Build Failed*\\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View logs>\"\n            }\n          }\n        ]\n      }\n  env:\n    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}\n```\n\n---\n\n### Anti-Pattern 5: Running All Tests on Every Commit\n\n**Problem**: Slow feedback loop (10+ minute test suites).\n\n**Symptom**: Developers avoid committing frequently.\n\n**Correct approach**:\n```yaml\n# ‚úÖ Fast feedback: Run subset on PR, full suite on merge\non:\n  pull_request:\n    branches: [main]\n  push:\n    branches: [main]\n\njobs:\n  quick-tests:\n    if: github.event_name == 'pull_request'\n    runs-on: ubuntu-latest\n    steps:\n      - run: npm run test:unit  # Fast: 2 minutes\n\n  full-tests:\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    steps:\n      - run: npm run test  # Slow: 10 minutes (unit + integration + e2e)\n```\n\n**Alternative**: Use changed-files action to run only affected tests.\n\n---\n\n## Implementation Patterns\n\n### Pattern 1: Basic CI Pipeline\n\n```yaml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run linter\n        run: npm run lint\n\n      - name: Run type check\n        run: npm run typecheck\n\n      - name: Run tests\n        run: npm test\n\n      - name: Build\n        run: npm run build\n```\n\n### Pattern 2: Multi-Environment Deployment\n\n```yaml\nname: Deploy\n\non:\n  push:\n    branches:\n      - main        # ‚Üí staging\n      - production  # ‚Üí production\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: ${{ github.ref_name }}  # staging or production\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Deploy to ${{ github.ref_name }}\n        run: |\n          if [ \"${{ github.ref_name }}\" == \"production\" ]; then\n            ./deploy.sh production\n          else\n            ./deploy.sh staging\n          fi\n        env:\n          API_KEY: ${{ secrets.API_KEY }}\n          DATABASE_URL: ${{ secrets.DATABASE_URL }}\n```\n\n### Pattern 3: Release Automation\n\n```yaml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'  # Trigger on version tags (v1.0.0)\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write  # Required for creating releases\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build artifacts\n        run: npm run build\n\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            dist/**\n          body: |\n            ## What's Changed\n            See CHANGELOG.md for details.\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Publish to npm\n        run: npm publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```\n\n### Pattern 4: Docker Build & Push\n\n```yaml\nname: Docker\n\non:\n  push:\n    branches: [main]\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Login to DockerHub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: |\n            myapp:latest\n            myapp:${{ github.sha }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n```\n\n---\n\n## Production Checklist\n\n```\n‚ñ° Dependency caching configured\n‚ñ° Matrix builds for multiple versions\n‚ñ° Secrets stored in GitHub Secrets (not code)\n‚ñ° Failure notifications (Slack, email, etc.)\n‚ñ° Deploy previews for pull requests\n‚ñ° Staging ‚Üí Production promotion workflow\n‚ñ° Release automation with versioning\n‚ñ° Docker layer caching enabled\n‚ñ° CODEOWNERS file for required reviews\n‚ñ° Branch protection rules enabled\n‚ñ° Status checks required before merge\n‚ñ° Security scanning (Dependabot, CodeQL)\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Use GitHub Actions? |\n|----------|---------------------|\n| GitHub-hosted repo | ‚úÖ Yes |\n| Need matrix builds | ‚úÖ Yes |\n| Deploying to AWS/GCP/Azure | ‚úÖ Yes (with OIDC) |\n| GitLab repo | ‚ùå No - use GitLab CI |\n| Extremely large monorepo | ‚ö†Ô∏è Maybe - consider BuildKite |\n| Need GUI pipeline builder | ‚ùå No - use Jenkins/Azure DevOps |\n\n---\n\n## References\n\n- `/references/advanced-caching.md` - Cache strategies for faster builds\n- `/references/oidc-deployments.md` - Keyless cloud authentication\n- `/references/security-hardening.md` - Security best practices\n\n## Scripts\n\n- `scripts/workflow_validator.ts` - Validate YAML syntax locally\n- `scripts/action_usage_analyzer.ts` - Find outdated actions\n\n## Assets\n\n- `assets/workflows/` - Ready-to-use workflow templates\n\n---\n\n**This skill guides**: CI/CD pipelines | GitHub Actions workflows | Matrix builds | Caching | Deployments | Release automation\n\n"
    }
  ]
}