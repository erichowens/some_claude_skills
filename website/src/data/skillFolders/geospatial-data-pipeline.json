{
  "name": "geospatial-data-pipeline",
  "type": "folder",
  "path": "geospatial-data-pipeline",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "geospatial-data-pipeline/references",
      "children": [
        {
          "name": "coordinate-systems.md",
          "type": "file",
          "path": "geospatial-data-pipeline/references/coordinate-systems.md",
          "size": 9968,
          "content": "# Coordinate Systems & Transformations\n\nComplete guide to EPSG codes, coordinate systems, and transformations for geospatial data.\n\n## The Problem\n\n**Different coordinate systems measure the Earth differently.**\n\n- **WGS84 (EPSG:4326)**: Latitude/longitude on spherical Earth\n- **Web Mercator (EPSG:3857)**: Projected coordinates for web maps\n- **UTM zones**: Localized projections with minimal distortion\n\n**Mixing them causes**:\n- Incorrect distances\n- Misaligned map features\n- Wrong spatial queries\n\n---\n\n## Common Coordinate Systems\n\n### EPSG:4326 (WGS84)\n\n**What it is**: Geographic coordinates (lat/lon) on an ellipsoid\n\n**Units**: Degrees\n- Longitude: -180¬∞ to 180¬∞\n- Latitude: -90¬∞ to 90¬∞\n\n**Used for**:\n- GPS coordinates\n- GeoJSON standard\n- Database storage\n\n**Characteristics**:\n- Spherical/ellipsoidal model of Earth\n- Not equal-area (distorts at poles)\n- Not conformal (distorts shapes)\n- Global coverage\n\n**Example**:\n```json\n{\n  \"type\": \"Point\",\n  \"coordinates\": [-122.4194, 37.7749]  // [lon, lat] in degrees\n}\n```\n\n**Distance calculation**: Use great circle distance (Haversine or Vincenty)\n\n---\n\n### EPSG:3857 (Web Mercator / Pseudo-Mercator)\n\n**What it is**: Projected coordinates for web mapping\n\n**Units**: Meters (but not true meters - see note)\n- X (easting): -20,037,508 to 20,037,508\n- Y (northing): -20,037,508 to 20,037,508\n\n**Used for**:\n- Google Maps, Mapbox, OpenStreetMap\n- Map tiles (z/x/y scheme)\n- Web map rendering\n\n**Characteristics**:\n- Cylindrical projection\n- Conformal (preserves angles/shapes)\n- NOT equal-area (distorts at poles)\n- Cuts off at ~85¬∞N/S\n\n**Example**:\n```json\n{\n  \"type\": \"Point\",\n  \"coordinates\": [-13634876, 4545684]  // [x, y] in meters (projected)\n}\n```\n\n**Important**: Distances in Web Mercator are NOT accurate. Always transform to WGS84 for distance calculations.\n\n---\n\n### UTM Zones (EPSG:326xx / 327xx)\n\n**What it is**: Universal Transverse Mercator - localized projections\n\n**Coverage**: 60 zones, each 6¬∞ wide\n- Northern Hemisphere: EPSG:32601-32660\n- Southern Hemisphere: EPSG:32701-32760\n\n**Units**: Meters\n\n**Used for**:\n- Engineering projects\n- Survey data\n- High-accuracy local mapping\n\n**Characteristics**:\n- Conformal (preserves shapes)\n- Minimal distortion within zone\n- Accurate distance calculations\n- Limited coverage (one zone at a time)\n\n**Example** (San Francisco is in UTM Zone 10N):\n```sql\n-- Transform WGS84 to UTM 10N\nSELECT ST_Transform(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326),\n  32610  -- UTM 10N\n);\n-- Result: POINT(551420 4182976)\n```\n\n---\n\n## Coordinate Order\n\n**CRITICAL**: Different systems use different order!\n\n| System | Order | Example |\n|--------|-------|---------|\n| GeoJSON | [lon, lat] | [-122.4194, 37.7749] |\n| PostGIS (WGS84) | (lon, lat) | POINT(-122.4194 37.7749) |\n| PostGIS (traditional) | (lat, lon) | **VARIES** |\n| Mapbox/Leaflet | [lat, lon] | [37.7749, -122.4194] |\n\n**Rule of thumb**: GeoJSON and PostGIS use (X, Y) = (lon, lat)\n\n**Common mistake**:\n```javascript\n// ‚ùå WRONG - swapped coordinates\nconst point = {\n  type: \"Point\",\n  coordinates: [37.7749, -122.4194]  // lat, lon (WRONG!)\n};\n\n// ‚úÖ CORRECT - GeoJSON is [lon, lat]\nconst point = {\n  type: \"Point\",\n  coordinates: [-122.4194, 37.7749]  // lon, lat ‚úÖ\n};\n```\n\n---\n\n## Transformations\n\n### PostGIS Transformations\n\n**Convert between coordinate systems**:\n\n```sql\n-- WGS84 ‚Üí Web Mercator\nSELECT ST_Transform(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326),\n  3857\n);\n-- Result: POINT(-13634876 4545684)\n\n-- Web Mercator ‚Üí WGS84\nSELECT ST_Transform(\n  ST_SetSRID(ST_MakePoint(-13634876, 4545684), 3857),\n  4326\n);\n-- Result: POINT(-122.4194 37.7749)\n\n-- WGS84 ‚Üí UTM 10N\nSELECT ST_Transform(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326),\n  32610\n);\n-- Result: POINT(551420 4182976)\n```\n\n**Always specify SRID**:\n```sql\n-- ‚ùå WRONG - no SRID, PostGIS doesn't know what it is\nSELECT ST_Transform(ST_MakePoint(-122.4194, 37.7749), 3857);\n\n-- ‚úÖ CORRECT - explicit SRID\nSELECT ST_Transform(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326),\n  3857\n);\n```\n\n---\n\n### JavaScript Transformations (proj4js)\n\n**Install**:\n```bash\nnpm install proj4\n```\n\n**Usage**:\n```javascript\nimport proj4 from 'proj4';\n\n// Define projections (built-in for common ones)\nconst wgs84 = 'EPSG:4326';\nconst webMercator = 'EPSG:3857';\n\n// WGS84 ‚Üí Web Mercator\nconst [x, y] = proj4(wgs84, webMercator, [-122.4194, 37.7749]);\nconsole.log(x, y);  // -13634876, 4545684\n\n// Web Mercator ‚Üí WGS84\nconst [lon, lat] = proj4(webMercator, wgs84, [-13634876, 4545684]);\nconsole.log(lon, lat);  // -122.4194, 37.7749\n```\n\n**Custom projections**:\n```javascript\n// Define UTM 10N\nproj4.defs([\n  [\n    'EPSG:32610',\n    '+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs'\n  ]\n]);\n\n// Transform\nconst [easting, northing] = proj4('EPSG:4326', 'EPSG:32610', [-122.4194, 37.7749]);\n```\n\n---\n\n## Finding the Right UTM Zone\n\n**Formula**: `Zone = floor((longitude + 180) / 6) + 1`\n\n```javascript\nfunction getUTMZone(lon: number, lat: number): number {\n  const zone = Math.floor((lon + 180) / 6) + 1;\n\n  // Northern hemisphere: 32600 + zone\n  // Southern hemisphere: 32700 + zone\n  const epsg = lat >= 0 ? 32600 + zone : 32700 + zone;\n\n  return epsg;\n}\n\n// San Francisco (-122.4194, 37.7749)\nconst zone = getUTMZone(-122.4194, 37.7749);\n// Returns: 32610 (UTM 10N)\n```\n\n---\n\n## Distance Calculations\n\n### Wrong: Euclidean Distance in WGS84\n\n```javascript\n// ‚ùå WRONG - treats degrees as Cartesian units\nfunction badDistance(lon1, lat1, lon2, lat2) {\n  const dx = lon2 - lon1;\n  const dy = lat2 - lat1;\n  return Math.sqrt(dx * dx + dy * dy) * 111320;  // WRONG!\n}\n```\n\n### Correct: Haversine Formula\n\n```javascript\n// ‚úÖ CORRECT - great circle distance\nfunction haversineDistance(lon1, lat1, lon2, lat2) {\n  const R = 6371000; // Earth radius in meters\n\n  const dLat = toRadians(lat2 - lat1);\n  const dLon = toRadians(lon2 - lon1);\n\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return R * c;\n}\n```\n\n### Best: PostGIS with GEOGRAPHY\n\n```sql\n-- PostGIS handles everything\nSELECT ST_Distance(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  ST_SetSRID(ST_MakePoint(-74.0060, 40.7128), 4326)::geography\n) AS distance_meters;\n```\n\n**Note**: `::geography` tells PostGIS to use spheroid model\n\n---\n\n## Common Scenarios\n\n### Scenario 1: Storing User Locations\n\n**Best practice**: Store in WGS84 (EPSG:4326)\n\n```sql\nCREATE TABLE user_locations (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER,\n  location GEOGRAPHY(POINT, 4326),  -- WGS84\n  created_at TIMESTAMP\n);\n\n-- Index for spatial queries\nCREATE INDEX idx_user_locations ON user_locations USING GIST(location);\n\n-- Insert (from GPS)\nINSERT INTO user_locations (user_id, location)\nVALUES (123, ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326));\n```\n\n**Why WGS84**:\n- GPS coordinates are in WGS84\n- Database can handle distance calculations\n- Global coverage\n\n---\n\n### Scenario 2: Rendering Map Tiles\n\n**Convert to Web Mercator** for rendering:\n\n```javascript\n// Client-side: Transform WGS84 ‚Üí Web Mercator for Mapbox\nconst features = await fetch('/api/features').then(r => r.json());\n\n// Mapbox expects WGS84, but tiles are in Web Mercator\nmap.addSource('features', {\n  type: 'geojson',\n  data: features  // GeoJSON in WGS84\n});\n\n// Mapbox handles transformation internally\n```\n\n**Server-side**: Generate tiles in Web Mercator\n\n```sql\n-- Tile query (Web Mercator)\nSELECT ST_AsMVT(q, 'layer', 4096, 'geom') AS mvt\nFROM (\n  SELECT\n    id,\n    name,\n    ST_AsMVTGeom(\n      ST_Transform(location, 3857),  -- Transform to Web Mercator\n      ST_TileEnvelope(:z, :x, :y),\n      4096,\n      256\n    ) AS geom\n  FROM locations\n  WHERE ST_Intersects(\n    location,\n    ST_Transform(ST_TileEnvelope(:z, :x, :y), 4326)\n  )\n) AS q;\n```\n\n---\n\n### Scenario 3: Engineering/Survey Data\n\n**Use local UTM zone** for accuracy:\n\n```sql\n-- Survey points in UTM 10N (San Francisco area)\nCREATE TABLE survey_points (\n  id SERIAL PRIMARY KEY,\n  point_id VARCHAR(50),\n  location GEOMETRY(POINT, 32610),  -- UTM 10N\n  elevation FLOAT,\n  surveyed_at TIMESTAMP\n);\n\n-- Accurate distance calculation (within UTM zone)\nSELECT ST_Distance(\n  (SELECT location FROM survey_points WHERE point_id = 'A'),\n  (SELECT location FROM survey_points WHERE point_id = 'B')\n) AS distance_meters;\n```\n\n---\n\n## Debugging Coordinate Issues\n\n### Check SRID\n\n```sql\nSELECT ST_SRID(location) FROM locations LIMIT 1;\n-- Should return 4326 for WGS84\n```\n\n### Visualize Coordinates\n\n```javascript\n// If coordinates look huge, probably Web Mercator\nconst coords = [-13634876, 4545684];  // Web Mercator\nconsole.log('Magnitude:', Math.abs(coords[0]));  // ~13 million = Web Mercator\n\n// If coordinates are small, probably WGS84\nconst coords2 = [-122.4194, 37.7749];  // WGS84\nconsole.log('Magnitude:', Math.abs(coords2[0]));  // ~122 = WGS84\n```\n\n### Validate Bounds\n\n```javascript\n// WGS84 bounds\nconst isValidWGS84 = (lon, lat) => {\n  return lon >= -180 && lon <= 180 && lat >= -90 && lat <= 90;\n};\n\n// Web Mercator bounds\nconst isValidWebMercator = (x, y) => {\n  const limit = 20037508.34;\n  return Math.abs(x) <= limit && Math.abs(y) <= limit;\n};\n```\n\n---\n\n## Quick Reference\n\n| Task | Use This |\n|------|----------|\n| Store GPS coordinates | WGS84 (4326) |\n| Render web maps | Web Mercator (3857) |\n| Engineering/survey | Local UTM zone (326xx/327xx) |\n| Distance calculations | WGS84 with GEOGRAPHY type |\n| Tile generation | Web Mercator (3857) |\n| Global analysis | Equal-area projection (e.g., Mollweide) |\n\n---\n\n## Resources\n\n- [EPSG.io](https://epsg.io/) - Search coordinate systems\n- [Proj4](https://proj.org/) - Transformation library\n- [PostGIS Transformations](https://postgis.net/docs/ST_Transform.html)\n- [Understanding Web Mercator](https://docs.mapbox.com/help/glossary/projection/)\n"
        },
        {
          "name": "geojson-optimization.md",
          "type": "file",
          "path": "geospatial-data-pipeline/references/geojson-optimization.md",
          "size": 9544,
          "content": "# GeoJSON Optimization\n\nTechniques for optimizing GeoJSON files for web performance: simplification, chunking, precision, and vector tiles.\n\n## The Problem\n\n**Large GeoJSON files crash browsers**:\n- 50MB GeoJSON = browser freeze\n- 10,000 polygons = slow rendering\n- High precision coordinates = wasted bytes\n\n**Symptoms**:\n- Map takes 10+ seconds to load\n- Browser tab crashes\n- Laggy panning/zooming\n\n---\n\n## Optimization Strategies\n\n### 1. Coordinate Precision\n\n**Problem**: Default precision is often excessive.\n\n```json\n// ‚ùå Excessive precision (8 decimals = ~1mm accuracy)\n{\n  \"type\": \"Point\",\n  \"coordinates\": [-122.41941234, 37.77492345]\n}\n\n// ‚úÖ Appropriate precision (5 decimals = ~1m accuracy)\n{\n  \"type\": \"Point\",\n  \"coordinates\": [-122.4194, 37.7749]\n}\n```\n\n**Precision vs Accuracy**:\n| Decimals | Accuracy | Use Case |\n|----------|----------|----------|\n| 2 | ~1 km | Country-level maps |\n| 3 | ~100 m | City-level maps |\n| 4 | ~10 m | Neighborhood maps |\n| 5 | ~1 m | **Web maps (default)** |\n| 6 | ~10 cm | Engineering, surveying |\n| 7 | ~1 cm | Precision agriculture |\n| 8 | ~1 mm | Unnecessary for most apps |\n\n**Tool**: `geojson-precision`\n\n```bash\nnpm install -g @mapbox/geojson-precision\n\n# Reduce to 5 decimals\ngeojson-precision -p 5 input.geojson output.geojson\n```\n\n**Savings**: 8 decimals ‚Üí 5 decimals = ~40% file size reduction\n\n---\n\n### 2. Geometry Simplification\n\n**Problem**: Polygons with too many vertices.\n\n**Douglas-Peucker Algorithm**: Remove points that don't significantly change shape.\n\n```bash\nnpm install -g @mapbox/simplify-geojson\n\n# Tolerance: higher = more aggressive\nsimplify-geojson -t 0.001 input.geojson output.geojson\n```\n\n**Example**:\n- Before: 10,000 points\n- After (tolerance 0.001): 2,500 points\n- Reduction: 75%\n\n**Visual comparison**:\n```\nBefore: ‚ö´‚ö´‚ö´‚ö´‚ö´‚ö´‚ö´‚ö´‚ö´‚ö´ (10,000 points)\nAfter:  ‚ö´-----‚ö´-----‚ö´ (2,500 points)\n```\n\n**PostGIS**:\n```sql\n-- Simplify geometry\nSELECT ST_Simplify(geometry, 0.001) FROM polygons;\n\n-- Simplify preserving topology (prevents self-intersections)\nSELECT ST_SimplifyPreserveTopology(geometry, 0.001) FROM polygons;\n```\n\n**Tuning tolerance**:\n- `0.0001`: Subtle simplification (~10% reduction)\n- `0.001`: Moderate simplification (~40% reduction)\n- `0.01`: Aggressive simplification (~70% reduction)\n\n---\n\n### 3. Remove Unnecessary Properties\n\n**Problem**: Feature properties bloat file size.\n\n```json\n// ‚ùå Before: 500 bytes per feature\n{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"id\": 123,\n    \"name\": \"Feature 123\",\n    \"description\": \"Long description...\",\n    \"created_at\": \"2024-01-15T10:30:00Z\",\n    \"updated_at\": \"2024-01-16T14:20:00Z\",\n    \"metadata\": { /* ... */ },\n    \"tags\": [\"tag1\", \"tag2\", \"tag3\"]\n  },\n  \"geometry\": { /* ... */ }\n}\n\n// ‚úÖ After: 100 bytes per feature\n{\n  \"type\": \"Feature\",\n  \"properties\": {\n    \"id\": 123,\n    \"name\": \"Feature 123\"\n  },\n  \"geometry\": { /* ... */ }\n}\n```\n\n**Savings**: 500 bytes ‚Üí 100 bytes = 80% reduction per feature\n\n**Script**:\n```javascript\nconst geojson = require('./input.json');\n\ngeojson.features = geojson.features.map(f => ({\n  type: 'Feature',\n  properties: {\n    id: f.properties.id,\n    name: f.properties.name\n  },\n  geometry: f.geometry\n}));\n\nfs.writeFileSync('output.json', JSON.stringify(geojson));\n```\n\n---\n\n### 4. Vector Tiles\n\n**Problem**: Loading entire dataset at once.\n\n**Solution**: Split into zoom-dependent tiles.\n\n**Benefits**:\n- Only load visible area\n- Progressive loading\n- Smaller payloads\n\n**Tile Pyramid**:\n```\nz0: 1 tile (whole world)\nz5: 1,024 tiles\nz10: 1,048,576 tiles\nz14: 268,435,456 tiles\n```\n\n**Generate with Tippecanoe**:\n```bash\nnpm install -g @mapbox/tippecanoe\n\n# Generate tiles\ntippecanoe -o output.mbtiles -zg --drop-densest-as-needed input.geojson\n\n# Options:\n# -zg: Auto-detect max zoom\n# --drop-densest-as-needed: Thin out features at low zoom\n# -Z<minzoom> -z<maxzoom>: Set zoom range\n```\n\n**Serve tiles**:\n```javascript\n// Express endpoint\napp.get('/tiles/:z/:x/:y.pbf', async (req, res) => {\n  const { z, x, y } = req.params;\n\n  // Query PostGIS for tile\n  const tile = await db.query(\n    'SELECT ST_AsMVT(q, $1) FROM (...) q',\n    ['layer']\n  );\n\n  res.set('Content-Type', 'application/x-protobuf');\n  res.send(tile.rows[0].st_asmvt);\n});\n```\n\n**Client-side**:\n```javascript\n// Mapbox GL JS\nmap.addSource('tiles', {\n  type: 'vector',\n  tiles: ['https://api.example.com/tiles/{z}/{x}/{y}.pbf'],\n  minzoom: 0,\n  maxzoom: 14\n});\n```\n\n---\n\n### 5. Feature Chunking\n\n**Problem**: Single GeoJSON file with 10,000 features.\n\n**Solution**: Split into multiple files.\n\n**Strategy 1**: Spatial chunking (by bounds)\n```javascript\n// Split by bounding box grid\nconst chunks = [\n  { name: 'nw', bounds: [-180, 0, -90, 90] },\n  { name: 'ne', bounds: [-90, 0, 0, 90] },\n  { name: 'sw', bounds: [-180, -90, -90, 0] },\n  { name: 'se', bounds: [-90, -90, 0, 0] }\n];\n\nchunks.forEach(chunk => {\n  const features = allFeatures.filter(f =>\n    featureIntersectsBounds(f, chunk.bounds)\n  );\n\n  fs.writeFileSync(\n    `${chunk.name}.geojson`,\n    JSON.stringify({ type: 'FeatureCollection', features })\n  );\n});\n```\n\n**Strategy 2**: Zoom-based chunking\n```javascript\n// High-detail features for high zoom only\nconst detailedFeatures = features.filter(f => getComplexity(f) > 100);\nconst simpleFeatures = features.filter(f => getComplexity(f) <= 100);\n\n// Save separately\nfs.writeFileSync('simple.geojson', JSON.stringify({ type: 'FeatureCollection', features: simpleFeatures }));\nfs.writeFileSync('detailed.geojson', JSON.stringify({ type: 'FeatureCollection', features: detailedFeatures }));\n\n// Load conditionally\nif (map.getZoom() > 12) {\n  loadDetailed();\n} else {\n  loadSimple();\n}\n```\n\n---\n\n### 6. Compression\n\n**Gzip Compression**:\n```bash\n# Compress\ngzip -k input.geojson  # Creates input.geojson.gz\n\n# Server: nginx auto-gzip\ngzip on;\ngzip_types application/json;\n```\n\n**Brotli Compression** (better than gzip):\n```bash\n# Install\nnpm install -g brotli-cli\n\n# Compress\nbrotli input.geojson\n\n# Server: nginx brotli module\nbrotli on;\nbrotli_types application/json;\n```\n\n**Comparison**:\n| Method | 10MB GeoJSON |\n|--------|--------------|\n| Uncompressed | 10 MB |\n| Gzip | 2.5 MB (75% reduction) |\n| Brotli | 2 MB (80% reduction) |\n\n---\n\n### 7. TopoJSON\n\n**Problem**: Adjacent polygons share borders = duplicate coordinates.\n\n**Solution**: TopoJSON encodes topology once.\n\n```bash\nnpm install -g topojson\n\n# Convert GeoJSON ‚Üí TopoJSON\ngeo2topo input.geojson > output.topojson\n\n# Simplify topology\ntoposimplify -s 0.001 output.topojson > simplified.topojson\n```\n\n**Savings**: 30-80% file size reduction (depends on shared borders)\n\n**Use when**:\n- Choropleth maps (countries, states, counties)\n- Adjacent polygons with shared boundaries\n- NOT useful for scattered points\n\n**Client-side**:\n```javascript\nimport { feature } from 'topojson-client';\n\n// Load TopoJSON\nconst topology = await fetch('/data.topojson').then(r => r.json());\n\n// Convert to GeoJSON\nconst geojson = feature(topology, topology.objects.layer);\n\n// Add to map\nmap.addSource('data', { type: 'geojson', data: geojson });\n```\n\n---\n\n## Optimization Workflow\n\n### Step 1: Analyze\n\n```bash\n# Check file size\nls -lh input.geojson\n\n# Count features\njq '.features | length' input.geojson\n\n# Check coordinate precision\njq '.features[0].geometry.coordinates' input.geojson\n```\n\n### Step 2: Reduce Precision\n\n```bash\ngeojson-precision -p 5 input.geojson temp1.geojson\n```\n\n### Step 3: Simplify Geometry\n\n```bash\nnpx @mapbox/geojson-precision -t 0.001 temp1.geojson temp2.geojson\n```\n\n### Step 4: Remove Properties\n\n```javascript\nconst data = require('./temp2.geojson');\ndata.features = data.features.map(f => ({\n  type: 'Feature',\n  properties: { id: f.properties.id, name: f.properties.name },\n  geometry: f.geometry\n}));\nfs.writeFileSync('temp3.geojson', JSON.stringify(data));\n```\n\n### Step 5: Compress\n\n```bash\ngzip -k temp3.geojson\n```\n\n### Step 6: Measure\n\n```bash\nls -lh input.geojson input.geojson.gz temp3.geojson temp3.geojson.gz\n```\n\n---\n\n## Performance Benchmarks\n\n**Test**: 50MB GeoJSON with 10,000 polygons\n\n| Optimization | File Size | Load Time |\n|--------------|-----------|-----------|\n| Original | 50 MB | 12 seconds |\n| Precision (5 decimals) | 30 MB | 8 seconds |\n| + Simplify (0.001) | 10 MB | 3 seconds |\n| + Remove properties | 5 MB | 1.5 seconds |\n| + Gzip | 1.5 MB | 0.5 seconds |\n| **Vector tiles** | **50 KB per tile** | **&lt;100ms** |\n\n**Winner**: Vector tiles (100x improvement)\n\n---\n\n## When to Use Each Strategy\n\n| Strategy | Use When | Savings |\n|----------|----------|---------|\n| Reduce precision | Always | 30-40% |\n| Simplify geometry | Rendering at low zoom | 40-70% |\n| Remove properties | Properties not displayed | 20-80% |\n| Vector tiles | &gt;1000 features or &gt;5MB | 90%+ |\n| Chunking | Mixed complexity features | Varies |\n| Compression | Always (server-side) | 70-80% |\n| TopoJSON | Adjacent polygons | 30-80% |\n\n---\n\n## Checklist\n\n```\n‚ñ° Reduce coordinate precision to 5 decimals\n‚ñ° Simplify geometry for features &gt;100 points\n‚ñ° Remove unused properties from features\n‚ñ° Enable gzip/brotli compression on server\n‚ñ° Consider vector tiles for files &gt;5MB\n‚ñ° Use TopoJSON for adjacent polygons\n‚ñ° Split large files into zoom-based chunks\n‚ñ° Test load time on slow connection (3G)\n```\n\n---\n\n## Resources\n\n- [geojson-precision](https://github.com/mapbox/geojson-precision)\n- [Tippecanoe](https://github.com/mapbox/tippecanoe)\n- [TopoJSON](https://github.com/topojson/topojson)\n- [Simplify.js](https://mourner.github.io/simplify-js/)\n"
        },
        {
          "name": "postgis-guide.md",
          "type": "file",
          "path": "geospatial-data-pipeline/references/postgis-guide.md",
          "size": 11519,
          "content": "# PostGIS Guide\n\nComplete guide to setting up PostGIS, creating spatial indexes, and writing efficient spatial queries.\n\n## Installation\n\n### macOS (Homebrew)\n\n```bash\n# Install PostgreSQL with PostGIS\nbrew install postgresql postgis\n\n# Start PostgreSQL\nbrew services start postgresql\n\n# Create database\ncreatedb myapp_dev\n\n# Enable PostGIS extension\npsql myapp_dev -c \"CREATE EXTENSION postgis;\"\npsql myapp_dev -c \"CREATE EXTENSION postgis_topology;\"  # Optional\n\n# Verify\npsql myapp_dev -c \"SELECT PostGIS_version();\"\n```\n\n### Ubuntu/Debian\n\n```bash\n# Install\nsudo apt-get update\nsudo apt-get install postgresql postgresql-contrib postgis\n\n# Enable extension\nsudo -u postgres psql -d myapp_dev -c \"CREATE EXTENSION postgis;\"\n```\n\n### Docker\n\n```bash\n# Official PostGIS image\ndocker run --name postgis -e POSTGRES_PASSWORD=password -p 5432:5432 -d postgis/postgis\n\n# Connect\npsql -h localhost -U postgres\n```\n\n---\n\n## Data Types\n\n### GEOMETRY vs GEOGRAPHY\n\n| Type | Units | Use When |\n|------|-------|----------|\n| `GEOMETRY` | Cartesian (meters/degrees) | Projected data, local areas |\n| `GEOGRAPHY` | Spheroid (meters) | Global data, accurate distances |\n\n**GEOMETRY** (projected, flat Earth):\n```sql\nCREATE TABLE locations_geometry (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255),\n  location GEOMETRY(POINT, 4326)  -- Stores as degrees, treats as flat\n);\n\n-- Distance in \"degree units\" (NOT meters!)\nSELECT ST_Distance(\n  ST_MakePoint(-122.4194, 37.7749),\n  ST_MakePoint(-122.4294, 37.7849)\n);\n-- Returns: 0.0141 (degrees, meaningless for distance)\n```\n\n**GEOGRAPHY** (spherical, curved Earth):\n```sql\nCREATE TABLE locations_geography (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255),\n  location GEOGRAPHY(POINT, 4326)  -- Treats Earth as sphere\n);\n\n-- Distance in meters (accurate!)\nSELECT ST_Distance(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  ST_SetSRID(ST_MakePoint(-122.4294, 37.7849), 4326)::geography\n);\n-- Returns: 1568.5 (meters) ‚úÖ\n```\n\n**Rule of thumb**:\n- Use `GEOGRAPHY` for WGS84 data (GPS coordinates)\n- Use `GEOMETRY` for projected data (UTM, Web Mercator)\n\n---\n\n## Geometry Types\n\n```sql\n-- Point\nGEOMETRY(POINT, 4326)\n-- Example: ST_MakePoint(-122.4194, 37.7749)\n\n-- LineString\nGEOMETRY(LINESTRING, 4326)\n-- Example: ST_MakeLine(ARRAY[point1, point2, point3])\n\n-- Polygon\nGEOMETRY(POLYGON, 4326)\n-- Example: ST_MakePolygon(ST_MakeLine(ARRAY[p1, p2, p3, p4, p1]))\n\n-- MultiPoint\nGEOMETRY(MULTIPOINT, 4326)\n\n-- MultiLineString (e.g., roads network)\nGEOMETRY(MULTILINESTRING, 4326)\n\n-- MultiPolygon (e.g., islands)\nGEOMETRY(MULTIPOLYGON, 4326)\n\n-- GeometryCollection (mixed types)\nGEOMETRY(GEOMETRYCOLLECTION, 4326)\n```\n\n---\n\n## Creating Spatial Data\n\n### From Lat/Lon\n\n```sql\n-- Single point\nINSERT INTO locations (name, location)\nVALUES ('San Francisco', ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326));\n\n-- From coordinates table\nUPDATE locations\nSET location = ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)\nWHERE location IS NULL;\n```\n\n### From GeoJSON\n\n```sql\n-- Insert GeoJSON feature\nINSERT INTO locations (name, location)\nVALUES (\n  'Golden Gate Park',\n  ST_SetSRID(\n    ST_GeomFromGeoJSON('{\"type\":\"Point\",\"coordinates\":[-122.4862,37.7694]}'),\n    4326\n  )\n);\n\n-- Bulk import from GeoJSON file\n\\copy locations(name, location)\nFROM PROGRAM 'cat features.geojson | jq -r ''.features[] | [.properties.name, .geometry | tostring] | @csv'''\nWITH CSV DELIMITER ',';\n```\n\n### From WKT (Well-Known Text)\n\n```sql\nINSERT INTO locations (name, location)\nVALUES (\n  'Line',\n  ST_SetSRID(\n    ST_GeomFromText('LINESTRING(-122.4194 37.7749, -122.4294 37.7849)'),\n    4326\n  )\n);\n```\n\n---\n\n## Spatial Indexes\n\n**CRITICAL**: Without indexes, spatial queries are O(N) sequential scans.\n\n### GiST Index (Most Common)\n\n```sql\n-- Create table\nCREATE TABLE drone_images (\n  id SERIAL PRIMARY KEY,\n  image_url VARCHAR(255),\n  location GEOGRAPHY(POINT, 4326),\n  captured_at TIMESTAMP\n);\n\n-- GiST index for spatial queries\nCREATE INDEX idx_drone_images_location ON drone_images USING GIST(location);\n\n-- Analyze table (update statistics)\nANALYZE drone_images;\n```\n\n**Performance impact**:\n- 10M points, 5km radius query\n- Without index: 3.2 seconds (seq scan)\n- With GiST index: 12ms (99.6% faster)\n\n### SP-GiST Index (Space-Partitioning)\n\n```sql\n-- Better for point data with high cardinality\nCREATE INDEX idx_locations_spgist ON locations USING SPGIST(location);\n```\n\n**When to use**:\n- GiST: General-purpose, works for all geometry types\n- SP-GiST: Optimized for points, faster for kNN queries\n\n---\n\n## Common Spatial Queries\n\n### 1. Find Nearby (Within Radius)\n\n```sql\n-- Find all locations within 5km of point\nSELECT id, name, ST_AsGeoJSON(location) as geojson\nFROM locations\nWHERE ST_DWithin(\n  location,\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  5000  -- 5000 meters = 5km\n)\nORDER BY location <-> ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography\nLIMIT 10;\n```\n\n**Key functions**:\n- `ST_DWithin`: Returns true if distance &lt;= threshold\n- `<->`: Distance operator (for ORDER BY)\n\n---\n\n### 2. Calculate Distance\n\n```sql\n-- Distance between two points (meters)\nSELECT ST_Distance(\n  (SELECT location FROM locations WHERE id = 1)::geography,\n  (SELECT location FROM locations WHERE id = 2)::geography\n) AS distance_meters;\n\n-- Distance from all locations to a point\nSELECT\n  id,\n  name,\n  ST_Distance(\n    location,\n    ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography\n  ) / 1000 AS distance_km\nFROM locations\nORDER BY distance_km\nLIMIT 10;\n```\n\n---\n\n### 3. Point in Polygon\n\n```sql\n-- Check if point is inside polygon\nSELECT ST_Within(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326),\n  (SELECT boundary FROM jurisdictions WHERE name = 'San Francisco')\n) AS is_inside;\n\n-- Find all points inside a polygon\nSELECT p.id, p.name\nFROM points p\nWHERE ST_Within(\n  p.location,\n  (SELECT boundary FROM jurisdictions WHERE name = 'California')\n);\n```\n\n---\n\n### 4. Bounding Box Query\n\n```sql\n-- Find all points in bounding box\nSELECT id, name, ST_AsGeoJSON(location) as geojson\nFROM locations\nWHERE ST_Intersects(\n  location,\n  ST_MakeEnvelope(\n    -122.5194, 37.7049,  -- west, south\n    -122.3194, 37.8449,  -- east, north\n    4326\n  )\n);\n```\n\n**Optimization**: Bounding box queries use spatial index efficiently.\n\n---\n\n### 5. Nearest Neighbor (kNN)\n\n```sql\n-- Find 10 nearest locations\nSELECT id, name, ST_AsGeoJSON(location) as geojson\nFROM locations\nORDER BY location <-> ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography\nLIMIT 10;\n```\n\n**Note**: `<->` operator uses index for fast kNN search.\n\n---\n\n### 6. Clustering (Group by Proximity)\n\n```sql\n-- Group locations within 1km of each other\nSELECT\n  ST_ClusterDBSCAN(location, eps := 1000, minpoints := 2) OVER () AS cluster_id,\n  id,\n  name,\n  ST_AsGeoJSON(location) as geojson\nFROM locations;\n```\n\n---\n\n## Output Formats\n\n### GeoJSON\n\n```sql\n-- Single feature\nSELECT ST_AsGeoJSON(location) FROM locations WHERE id = 1;\n\n-- Feature with properties\nSELECT json_build_object(\n  'type', 'Feature',\n  'geometry', ST_AsGeoJSON(location)::json,\n  'properties', json_build_object('name', name, 'id', id)\n) FROM locations WHERE id = 1;\n\n-- FeatureCollection\nSELECT json_build_object(\n  'type', 'FeatureCollection',\n  'features', json_agg(\n    json_build_object(\n      'type', 'Feature',\n      'geometry', ST_AsGeoJSON(location)::json,\n      'properties', json_build_object('name', name, 'id', id)\n    )\n  )\n) FROM locations;\n```\n\n### WKT (Well-Known Text)\n\n```sql\nSELECT ST_AsText(location) FROM locations WHERE id = 1;\n-- Returns: POINT(-122.4194 37.7749)\n```\n\n### Coordinates\n\n```sql\n-- Longitude\nSELECT ST_X(location) FROM locations WHERE id = 1;\n\n-- Latitude\nSELECT ST_Y(location) FROM locations WHERE id = 1;\n```\n\n---\n\n## Performance Optimization\n\n### Use Bounding Box Before Expensive Operations\n\n```sql\n-- ‚ùå Slow: ST_Distance on all rows\nSELECT id, name\nFROM locations\nWHERE ST_Distance(\n  location,\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography\n) < 5000;\n\n-- ‚úÖ Fast: Bounding box pre-filter + ST_Distance\nSELECT id, name\nFROM locations\nWHERE ST_DWithin(\n  location,\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  5000\n)\nAND ST_Distance(\n  location,\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography\n) < 5000;\n```\n\n**Why**: `ST_DWithin` uses bounding box from index, then `ST_Distance` refines.\n\n---\n\n### Simplify Geometries\n\n```sql\n-- Simplify polygon (reduce points)\nSELECT ST_Simplify(geometry, 0.001) FROM complex_polygons;\n\n-- Simplify preserving topology\nSELECT ST_SimplifyPreserveTopology(geometry, 0.001) FROM complex_polygons;\n```\n\n**Use when**: Rendering at low zoom levels (don't need full detail).\n\n---\n\n### Avoid GEOGRAPHY for Local Queries\n\n```sql\n-- ‚ùå Slow: GEOGRAPHY on local data\nCREATE TABLE local_points (\n  location GEOGRAPHY(POINT, 4326)\n);\n\n-- ‚úÖ Fast: GEOMETRY in local UTM projection\nCREATE TABLE local_points (\n  location GEOMETRY(POINT, 32610)  -- UTM 10N\n);\n```\n\n**Why**: GEOGRAPHY calculations are slower (spheroid math). For local areas, projected coordinates are faster and accurate.\n\n---\n\n## Vector Tile Generation\n\n### Mapbox Vector Tiles (MVT)\n\n```sql\n-- Generate tile at z/x/y\nSELECT ST_AsMVT(q, 'layer', 4096, 'geom') AS mvt\nFROM (\n  SELECT\n    id,\n    name,\n    ST_AsMVTGeom(\n      ST_Transform(location, 3857),  -- Transform to Web Mercator\n      ST_TileEnvelope(:z, :x, :y),\n      4096,  -- Tile extent\n      256    -- Buffer\n    ) AS geom\n  FROM locations\n  WHERE ST_Intersects(\n    location,\n    ST_Transform(ST_TileEnvelope(:z, :x, :y), 4326)\n  )\n) AS q;\n```\n\n**Use in Express**:\n```javascript\napp.get('/tiles/:z/:x/:y.mvt', async (req, res) => {\n  const { z, x, y } = req.params;\n\n  const result = await db.query(\n    'SELECT ST_AsMVT(q, $1, 4096, $2) AS mvt FROM ...',\n    ['layer', 'geom']\n  );\n\n  res.set('Content-Type', 'application/x-protobuf');\n  res.send(result.rows[0].mvt);\n});\n```\n\n---\n\n## Common Pitfalls\n\n### 1. Forgetting to Set SRID\n\n```sql\n-- ‚ùå WRONG - no SRID\nINSERT INTO locations (location) VALUES (ST_MakePoint(-122.4194, 37.7749));\n\n-- ‚úÖ CORRECT\nINSERT INTO locations (location) VALUES (\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)\n);\n```\n\n### 2. Mixing GEOMETRY and GEOGRAPHY\n\n```sql\n-- ‚ùå WRONG - can't compare GEOMETRY with GEOGRAPHY\nSELECT ST_Distance(geometry_col, geography_col);\n\n-- ‚úÖ CORRECT - cast to same type\nSELECT ST_Distance(geometry_col::geography, geography_col);\n```\n\n### 3. Using ST_Distance Without Index\n\n```sql\n-- ‚ùå SLOW - ST_Distance doesn't use index\nSELECT * FROM locations\nWHERE ST_Distance(location, point) < 5000;\n\n-- ‚úÖ FAST - ST_DWithin uses index\nSELECT * FROM locations\nWHERE ST_DWithin(location, point, 5000);\n```\n\n---\n\n## Troubleshooting\n\n### Check if Extension is Enabled\n\n```sql\nSELECT * FROM pg_extension WHERE extname = 'postgis';\n```\n\n### Verify SRID\n\n```sql\nSELECT ST_SRID(location) FROM locations LIMIT 1;\n-- Should return 4326 for WGS84\n```\n\n### Explain Query Plan\n\n```sql\nEXPLAIN ANALYZE\nSELECT * FROM locations\nWHERE ST_DWithin(location, ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography, 5000);\n```\n\n**Look for**: \"Index Scan using idx_...\" (good) vs \"Seq Scan\" (bad)\n\n---\n\n## Resources\n\n- [PostGIS Documentation](https://postgis.net/docs/)\n- [PostGIS Cheat Sheet](https://postgis.net/docs/PostGIS_FAQ.html)\n- [Spatial Joins](https://postgis.net/workshops/postgis-intro/joins.html)\n- [Performance Tuning](https://postgis.net/workshops/postgis-intro/performance.html)\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "geospatial-data-pipeline/scripts",
      "children": [
        {
          "name": "geospatial_processor.ts",
          "type": "file",
          "path": "geospatial-data-pipeline/scripts/geospatial_processor.ts",
          "size": 17329,
          "content": "#!/usr/bin/env node\n/**\n * Geospatial Data Processor\n *\n * Process drone imagery, GPS tracks, and GeoJSON files for analysis and visualization.\n *\n * Usage:\n *   npx tsx geospatial_processor.ts validate <file.geojson>\n *   npx tsx geospatial_processor.ts simplify <input.geojson> <output.geojson> <tolerance>\n *   npx tsx geospatial_processor.ts bbox <file.geojson>\n *   npx tsx geospatial_processor.ts analyze-drone <directory>\n *   npx tsx geospatial_processor.ts gps-stats <track.geojson>\n *\n * Examples:\n *   npx tsx geospatial_processor.ts validate survey-data.geojson\n *   npx tsx geospatial_processor.ts simplify detailed.geojson simple.geojson 0.001\n *   npx tsx geospatial_processor.ts bbox survey-area.geojson\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface GeoJSONFeature {\n  type: 'Feature';\n  geometry: {\n    type: string;\n    coordinates: any;\n  };\n  properties: Record<string, any>;\n}\n\ninterface GeoJSONFeatureCollection {\n  type: 'FeatureCollection';\n  features: GeoJSONFeature[];\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n  stats: {\n    featureCount: number;\n    geometryTypes: Record<string, number>;\n    totalPoints: number;\n    boundingBox: number[];\n  };\n}\n\ninterface GPSTrackStats {\n  totalDistance: number;  // meters\n  duration: number;  // seconds\n  avgSpeed: number;  // m/s\n  maxSpeed: number;  // m/s\n  elevation: {\n    min: number;\n    max: number;\n    gain: number;\n    loss: number;\n  };\n  bounds: number[];  // [minLon, minLat, maxLon, maxLat]\n}\n\nclass GeospatialProcessor {\n  /**\n   * Validate GeoJSON structure and geometry\n   */\n  validate(filePath: string): ValidationResult {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    let geojson: GeoJSONFeatureCollection;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      geojson = JSON.parse(content);\n    } catch (e) {\n      return {\n        valid: false,\n        errors: ['Invalid JSON: ' + (e as Error).message],\n        warnings: [],\n        stats: { featureCount: 0, geometryTypes: {}, totalPoints: 0, boundingBox: [] }\n      };\n    }\n\n    // Check structure\n    if (geojson.type !== 'FeatureCollection') {\n      errors.push('Root type must be \"FeatureCollection\"');\n    }\n\n    if (!Array.isArray(geojson.features)) {\n      errors.push('Missing or invalid \"features\" array');\n      return {\n        valid: false,\n        errors,\n        warnings,\n        stats: { featureCount: 0, geometryTypes: {}, totalPoints: 0, boundingBox: [] }\n      };\n    }\n\n    // Validate features\n    const geometryTypes: Record<string, number> = {};\n    let totalPoints = 0;\n    let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;\n\n    geojson.features.forEach((feature, i) => {\n      // Check feature structure\n      if (!feature.type || feature.type !== 'Feature') {\n        errors.push(`Feature ${i}: Missing or invalid \"type\"`);\n      }\n\n      if (!feature.geometry) {\n        errors.push(`Feature ${i}: Missing \"geometry\"`);\n        return;\n      }\n\n      const geomType = feature.geometry.type;\n      geometryTypes[geomType] = (geometryTypes[geomType] || 0) + 1;\n\n      // Validate coordinates\n      const points = this.extractPoints(feature.geometry.coordinates);\n      totalPoints += points.length;\n\n      points.forEach((point, j) => {\n        const [lon, lat] = point;\n\n        // Validate coordinate ranges\n        if (lon < -180 || lon > 180) {\n          errors.push(`Feature ${i}, point ${j}: Longitude out of range: ${lon}`);\n        }\n        if (lat < -90 || lat > 90) {\n          errors.push(`Feature ${i}, point ${j}: Latitude out of range: ${lat}`);\n        }\n\n        // Update bounding box\n        minLon = Math.min(minLon, lon);\n        minLat = Math.min(minLat, lat);\n        maxLon = Math.max(maxLon, lon);\n        maxLat = Math.max(maxLat, lat);\n      });\n\n      // Warn about large features\n      if (points.length > 10000) {\n        warnings.push(`Feature ${i}: Very large feature (${points.length} points). Consider simplifying.`);\n      }\n    });\n\n    // Warn about file size\n    const fileSizeKB = fs.statSync(filePath).size / 1024;\n    if (fileSizeKB > 1000) {\n      warnings.push(`File size is ${fileSizeKB.toFixed(0)}KB. Consider splitting or serving as tiles.`);\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n      stats: {\n        featureCount: geojson.features.length,\n        geometryTypes,\n        totalPoints,\n        boundingBox: [minLon, minLat, maxLon, maxLat]\n      }\n    };\n  }\n\n  /**\n   * Simplify GeoJSON geometry using Douglas-Peucker algorithm\n   */\n  simplify(inputPath: string, outputPath: string, tolerance: number): void {\n    const content = fs.readFileSync(inputPath, 'utf-8');\n    const geojson: GeoJSONFeatureCollection = JSON.parse(content);\n\n    let totalPointsBefore = 0;\n    let totalPointsAfter = 0;\n\n    geojson.features = geojson.features.map(feature => {\n      const pointsBefore = this.countPoints(feature.geometry.coordinates);\n      totalPointsBefore += pointsBefore;\n\n      feature.geometry.coordinates = this.simplifyCoordinates(\n        feature.geometry.coordinates,\n        feature.geometry.type,\n        tolerance\n      );\n\n      const pointsAfter = this.countPoints(feature.geometry.coordinates);\n      totalPointsAfter += pointsAfter;\n\n      return feature;\n    });\n\n    fs.writeFileSync(outputPath, JSON.stringify(geojson, null, 2));\n\n    console.log(`\\n‚úÖ Simplified GeoJSON`);\n    console.log(`   Points before: ${totalPointsBefore}`);\n    console.log(`   Points after:  ${totalPointsAfter}`);\n    console.log(`   Reduction:     ${((1 - totalPointsAfter / totalPointsBefore) * 100).toFixed(1)}%\\n`);\n  }\n\n  /**\n   * Douglas-Peucker line simplification\n   */\n  private douglasPeucker(points: number[][], tolerance: number): number[][] {\n    if (points.length <= 2) return points;\n\n    const firstPoint = points[0];\n    const lastPoint = points[points.length - 1];\n\n    let maxDistance = 0;\n    let maxIndex = 0;\n\n    for (let i = 1; i < points.length - 1; i++) {\n      const distance = this.perpendicularDistance(points[i], firstPoint, lastPoint);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        maxIndex = i;\n      }\n    }\n\n    if (maxDistance > tolerance) {\n      const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n      const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n      return [...left.slice(0, -1), ...right];\n    } else {\n      return [firstPoint, lastPoint];\n    }\n  }\n\n  /**\n   * Calculate perpendicular distance from point to line\n   */\n  private perpendicularDistance(point: number[], lineStart: number[], lineEnd: number[]): number {\n    const [px, py] = point;\n    const [x1, y1] = lineStart;\n    const [x2, y2] = lineEnd;\n\n    const A = px - x1;\n    const B = py - y1;\n    const C = x2 - x1;\n    const D = y2 - y1;\n\n    const dot = A * C + B * D;\n    const lenSq = C * C + D * D;\n    let param = -1;\n\n    if (lenSq !== 0) {\n      param = dot / lenSq;\n    }\n\n    let xx, yy;\n\n    if (param < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (param > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + param * C;\n      yy = y1 + param * D;\n    }\n\n    const dx = px - xx;\n    const dy = py - yy;\n\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Simplify coordinates based on geometry type\n   */\n  private simplifyCoordinates(coords: any, geomType: string, tolerance: number): any {\n    switch (geomType) {\n      case 'LineString':\n        return this.douglasPeucker(coords, tolerance);\n\n      case 'Polygon':\n        return coords.map((ring: number[][]) => this.douglasPeucker(ring, tolerance));\n\n      case 'MultiLineString':\n        return coords.map((line: number[][]) => this.douglasPeucker(line, tolerance));\n\n      case 'MultiPolygon':\n        return coords.map((polygon: number[][][]) =>\n          polygon.map((ring: number[][]) => this.douglasPeucker(ring, tolerance))\n        );\n\n      default:\n        return coords;  // Point, MultiPoint (no simplification)\n    }\n  }\n\n  /**\n   * Calculate bounding box\n   */\n  calculateBoundingBox(filePath: string): number[] {\n    const validation = this.validate(filePath);\n    return validation.stats.boundingBox;\n  }\n\n  /**\n   * Analyze drone imagery directory\n   */\n  analyzeDroneDirectory(dirPath: string): void {\n    const files = fs.readdirSync(dirPath)\n      .filter(f => f.endsWith('.geojson') || f.endsWith('.json'));\n\n    console.log(`\\nüìÇ Analyzing drone data directory: ${dirPath}\\n`);\n    console.log(`Found ${files.length} GeoJSON files:\\n`);\n\n    let totalFeatures = 0;\n    let totalImages = 0;\n\n    files.forEach(file => {\n      const fullPath = path.join(dirPath, file);\n      const content = fs.readFileSync(fullPath, 'utf-8');\n      const geojson: GeoJSONFeatureCollection = JSON.parse(content);\n\n      const images = geojson.features.filter(f =>\n        f.properties && (f.properties.image_url || f.properties.thumbnail)\n      );\n\n      totalFeatures += geojson.features.length;\n      totalImages += images.length;\n\n      console.log(`  ${file}`);\n      console.log(`    Features: ${geojson.features.length}`);\n      console.log(`    Images:   ${images.length}`);\n\n      if (images.length > 0) {\n        const bounds = this.calculateBounds(geojson.features);\n        console.log(`    Bounds:   [${bounds.map(n => n.toFixed(4)).join(', ')}]`);\n      }\n      console.log('');\n    });\n\n    console.log(`\\nüìä Summary:`);\n    console.log(`  Total features: ${totalFeatures}`);\n    console.log(`  Total images:   ${totalImages}\\n`);\n  }\n\n  /**\n   * Analyze GPS track statistics\n   */\n  analyzeGPSTrack(filePath: string): GPSTrackStats {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const geojson: GeoJSONFeatureCollection = JSON.parse(content);\n\n    // Assume LineString geometry with coordinates as [lon, lat, elevation?, timestamp?]\n    const track = geojson.features.find(f => f.geometry.type === 'LineString');\n\n    if (!track) {\n      throw new Error('No LineString feature found in GPS track');\n    }\n\n    const coords = track.geometry.coordinates;\n\n    let totalDistance = 0;\n    let elevationGain = 0;\n    let elevationLoss = 0;\n    let minElevation = Infinity;\n    let maxElevation = -Infinity;\n    let maxSpeed = 0;\n\n    const speeds: number[] = [];\n\n    for (let i = 1; i < coords.length; i++) {\n      const [lon1, lat1, elev1, time1] = coords[i - 1];\n      const [lon2, lat2, elev2, time2] = coords[i];\n\n      // Calculate distance\n      const distance = this.haversineDistance(lat1, lon1, lat2, lon2);\n      totalDistance += distance;\n\n      // Calculate speed (if timestamps available)\n      if (time1 && time2) {\n        const timeDelta = time2 - time1;  // seconds\n        const speed = distance / timeDelta;  // m/s\n        speeds.push(speed);\n        maxSpeed = Math.max(maxSpeed, speed);\n      }\n\n      // Elevation stats\n      if (elev1 !== undefined && elev2 !== undefined) {\n        minElevation = Math.min(minElevation, elev1, elev2);\n        maxElevation = Math.max(maxElevation, elev1, elev2);\n\n        const elevChange = elev2 - elev1;\n        if (elevChange > 0) {\n          elevationGain += elevChange;\n        } else {\n          elevationLoss += Math.abs(elevChange);\n        }\n      }\n    }\n\n    const avgSpeed = speeds.length > 0\n      ? speeds.reduce((sum, s) => sum + s, 0) / speeds.length\n      : 0;\n\n    const duration = coords.length > 0 && coords[0][3] && coords[coords.length - 1][3]\n      ? coords[coords.length - 1][3] - coords[0][3]\n      : 0;\n\n    const bounds = this.calculateBounds([track]);\n\n    return {\n      totalDistance,\n      duration,\n      avgSpeed,\n      maxSpeed,\n      elevation: {\n        min: minElevation,\n        max: maxElevation,\n        gain: elevationGain,\n        loss: elevationLoss\n      },\n      bounds\n    };\n  }\n\n  /**\n   * Haversine distance in meters\n   */\n  private haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371000; // Earth radius in meters\n\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *\n      Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n\n  private toRadians(degrees: number): number {\n    return degrees * Math.PI / 180;\n  }\n\n  /**\n   * Calculate bounds for features\n   */\n  private calculateBounds(features: GeoJSONFeature[]): number[] {\n    let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;\n\n    features.forEach(feature => {\n      const points = this.extractPoints(feature.geometry.coordinates);\n      points.forEach(([lon, lat]) => {\n        minLon = Math.min(minLon, lon);\n        minLat = Math.min(minLat, lat);\n        maxLon = Math.max(maxLon, lon);\n        maxLat = Math.max(maxLat, lat);\n      });\n    });\n\n    return [minLon, minLat, maxLon, maxLat];\n  }\n\n  /**\n   * Extract all points from coordinates (recursive)\n   */\n  private extractPoints(coords: any): number[][] {\n    if (typeof coords[0] === 'number') {\n      return [coords];  // Single point\n    }\n\n    return coords.flatMap((c: any) => this.extractPoints(c));\n  }\n\n  /**\n   * Count points in coordinates\n   */\n  private countPoints(coords: any): number {\n    if (typeof coords[0] === 'number') {\n      return 1;\n    }\n\n    return coords.reduce((sum: number, c: any) => sum + this.countPoints(c), 0);\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  const command = args[0];\n\n  const processor = new GeospatialProcessor();\n\n  switch (command) {\n    case 'validate': {\n      if (args.length < 2) {\n        console.error('Usage: npx tsx geospatial_processor.ts validate <file.geojson>');\n        process.exit(1);\n      }\n\n      const result = processor.validate(args[1]);\n\n      console.log(`\\nüìç GeoJSON Validation: ${args[1]}\\n`);\n\n      if (result.valid) {\n        console.log('‚úÖ Valid GeoJSON\\n');\n      } else {\n        console.log('‚ùå Invalid GeoJSON\\n');\n        console.log('Errors:');\n        result.errors.forEach(err => console.log(`  ‚Ä¢ ${err}`));\n        console.log('');\n      }\n\n      if (result.warnings.length > 0) {\n        console.log('‚ö†Ô∏è  Warnings:');\n        result.warnings.forEach(warn => console.log(`  ‚Ä¢ ${warn}`));\n        console.log('');\n      }\n\n      console.log('üìä Statistics:');\n      console.log(`  Features:       ${result.stats.featureCount}`);\n      console.log(`  Total points:   ${result.stats.totalPoints}`);\n      console.log(`  Geometry types: ${JSON.stringify(result.stats.geometryTypes)}`);\n      console.log(`  Bounding box:   [${result.stats.boundingBox.map(n => n.toFixed(4)).join(', ')}]\\n`);\n\n      process.exit(result.valid ? 0 : 1);\n    }\n\n    case 'simplify': {\n      if (args.length < 4) {\n        console.error('Usage: npx tsx geospatial_processor.ts simplify <input.geojson> <output.geojson> <tolerance>');\n        process.exit(1);\n      }\n\n      processor.simplify(args[1], args[2], parseFloat(args[3]));\n      break;\n    }\n\n    case 'bbox': {\n      if (args.length < 2) {\n        console.error('Usage: npx tsx geospatial_processor.ts bbox <file.geojson>');\n        process.exit(1);\n      }\n\n      const bbox = processor.calculateBoundingBox(args[1]);\n      console.log(`\\nBounding Box: [${bbox.map(n => n.toFixed(6)).join(', ')}]\\n`);\n      break;\n    }\n\n    case 'analyze-drone': {\n      if (args.length < 2) {\n        console.error('Usage: npx tsx geospatial_processor.ts analyze-drone <directory>');\n        process.exit(1);\n      }\n\n      processor.analyzeDroneDirectory(args[1]);\n      break;\n    }\n\n    case 'gps-stats': {\n      if (args.length < 2) {\n        console.error('Usage: npx tsx geospatial_processor.ts gps-stats <track.geojson>');\n        process.exit(1);\n      }\n\n      const stats = processor.analyzeGPSTrack(args[1]);\n\n      console.log(`\\nüö¥ GPS Track Statistics\\n`);\n      console.log(`Distance:     ${(stats.totalDistance / 1000).toFixed(2)} km`);\n      console.log(`Duration:     ${(stats.duration / 60).toFixed(0)} minutes`);\n      console.log(`Avg Speed:    ${(stats.avgSpeed * 3.6).toFixed(1)} km/h`);\n      console.log(`Max Speed:    ${(stats.maxSpeed * 3.6).toFixed(1)} km/h`);\n      console.log(`Elevation:`);\n      console.log(`  Min:        ${stats.elevation.min.toFixed(0)} m`);\n      console.log(`  Max:        ${stats.elevation.max.toFixed(0)} m`);\n      console.log(`  Gain:       ${stats.elevation.gain.toFixed(0)} m`);\n      console.log(`  Loss:       ${stats.elevation.loss.toFixed(0)} m`);\n      console.log(`Bounds:       [${stats.bounds.map(n => n.toFixed(4)).join(', ')}]\\n`);\n      break;\n    }\n\n    default:\n      console.error('Unknown command. Available commands:');\n      console.error('  validate <file.geojson>');\n      console.error('  simplify <input.geojson> <output.geojson> <tolerance>');\n      console.error('  bbox <file.geojson>');\n      console.error('  analyze-drone <directory>');\n      console.error('  gps-stats <track.geojson>');\n      process.exit(1);\n  }\n}\n\nexport { GeospatialProcessor, ValidationResult, GPSTrackStats };\n"
        },
        {
          "name": "tile_generator.ts",
          "type": "file",
          "path": "geospatial-data-pipeline/scripts/tile_generator.ts",
          "size": 12764,
          "content": "#!/usr/bin/env node\n/**\n * Vector Tile Generator\n *\n * Convert GeoJSON files into vector tiles (MBTiles format) for efficient web/mobile map rendering.\n *\n * Usage:\n *   npx tsx tile_generator.ts generate <input.geojson> <output.mbtiles> [options]\n *   npx tsx tile_generator.ts info <tiles.mbtiles>\n *\n * Options:\n *   --minzoom <z>     Minimum zoom level (default: 0)\n *   --maxzoom <z>     Maximum zoom level (default: 14)\n *   --name <name>     Tileset name\n *   --attribution <text>  Attribution text\n *\n * Examples:\n *   npx tsx tile_generator.ts generate survey.geojson tiles.mbtiles --minzoom 10 --maxzoom 18\n *   npx tsx tile_generator.ts info tiles.mbtiles\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface Tile {\n  z: number;  // Zoom level\n  x: number;  // Tile X coordinate\n  y: number;  // Tile Y coordinate\n  features: GeoJSONFeature[];\n}\n\ninterface GeoJSONFeature {\n  type: 'Feature';\n  geometry: {\n    type: string;\n    coordinates: any;\n  };\n  properties: Record<string, any>;\n}\n\ninterface GeoJSONFeatureCollection {\n  type: 'FeatureCollection';\n  features: GeoJSONFeature[];\n}\n\ninterface TileGeneratorOptions {\n  minZoom: number;\n  maxZoom: number;\n  name?: string;\n  attribution?: string;\n  bufferSize?: number;  // Tile buffer in pixels\n}\n\ninterface TilesetMetadata {\n  name: string;\n  description?: string;\n  version: string;\n  attribution?: string;\n  type: 'overlay' | 'baselayer';\n  format: 'pbf' | 'geojson';\n  minzoom: number;\n  maxzoom: number;\n  bounds: number[];  // [west, south, east, north]\n  center: number[];  // [lon, lat, zoom]\n}\n\nclass TileGenerator {\n  private options: TileGeneratorOptions;\n\n  constructor(options: TileGeneratorOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Generate tiles from GeoJSON\n   */\n  async generate(inputPath: string, outputPath: string): Promise<void> {\n    console.log(`\\nüó∫Ô∏è  Generating vector tiles...\\n`);\n    console.log(`Input:  ${inputPath}`);\n    console.log(`Output: ${outputPath}`);\n    console.log(`Zoom:   ${this.options.minZoom} - ${this.options.maxZoom}\\n`);\n\n    // Read GeoJSON\n    const content = fs.readFileSync(inputPath, 'utf-8');\n    const geojson: GeoJSONFeatureCollection = JSON.parse(content);\n\n    console.log(`Loaded ${geojson.features.length} features\\n`);\n\n    // Calculate bounds\n    const bounds = this.calculateBounds(geojson.features);\n    console.log(`Bounds: [${bounds.map(n => n.toFixed(4)).join(', ')}]`);\n\n    // Generate tiles for each zoom level\n    const allTiles: Tile[] = [];\n\n    for (let z = this.options.minZoom; z <= this.options.maxZoom; z++) {\n      console.log(`\\nGenerating zoom level ${z}...`);\n\n      const tiles = this.generateTilesForZoom(geojson.features, z, bounds);\n      allTiles.push(...tiles);\n\n      console.log(`  Created ${tiles.length} tiles`);\n    }\n\n    console.log(`\\n‚úÖ Generated ${allTiles.length} total tiles`);\n\n    // Write to MBTiles (simplified - in production use better-sqlite3 or similar)\n    this.writeMBTiles(outputPath, allTiles, bounds);\n\n    console.log(`\\nüì¶ Tileset written to ${outputPath}\\n`);\n  }\n\n  /**\n   * Generate tiles for a specific zoom level\n   */\n  private generateTilesForZoom(\n    features: GeoJSONFeature[],\n    z: number,\n    bounds: number[]\n  ): Tile[] {\n    const tiles: Map<string, Tile> = new Map();\n\n    features.forEach(feature => {\n      // Get all tile coordinates this feature intersects\n      const tileCoords = this.getIntersectingTiles(feature, z, bounds);\n\n      tileCoords.forEach(({ x, y }) => {\n        const key = `${z}/${x}/${y}`;\n\n        if (!tiles.has(key)) {\n          tiles.set(key, { z, x, y, features: [] });\n        }\n\n        // Clip feature to tile bounds (simplified - in production use proper clipping)\n        const clipped = this.clipFeatureToTile(feature, z, x, y);\n        if (clipped) {\n          tiles.get(key)!.features.push(clipped);\n        }\n      });\n    });\n\n    return Array.from(tiles.values());\n  }\n\n  /**\n   * Get tile coordinates that intersect with feature\n   */\n  private getIntersectingTiles(\n    feature: GeoJSONFeature,\n    z: number,\n    bounds: number[]\n  ): Array<{ x: number; y: number }> {\n    const coords: Array<{ x: number; y: number }> = [];\n\n    // Get feature bounds\n    const [minLon, minLat, maxLon, maxLat] = this.getFeatureBounds(feature);\n\n    // Convert to tile coordinates\n    const minTile = this.lonLatToTile(minLon, maxLat, z);  // maxLat because Y is inverted\n    const maxTile = this.lonLatToTile(maxLon, minLat, z);\n\n    // Get all tiles in bounding box\n    for (let x = minTile.x; x <= maxTile.x; x++) {\n      for (let y = minTile.y; y <= maxTile.y; y++) {\n        coords.push({ x, y });\n      }\n    }\n\n    return coords;\n  }\n\n  /**\n   * Convert lon/lat to tile coordinates\n   */\n  private lonLatToTile(lon: number, lat: number, z: number): { x: number; y: number } {\n    const n = Math.pow(2, z);\n\n    const x = Math.floor((lon + 180) / 360 * n);\n\n    const latRad = lat * Math.PI / 180;\n    const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);\n\n    return {\n      x: Math.max(0, Math.min(n - 1, x)),\n      y: Math.max(0, Math.min(n - 1, y))\n    };\n  }\n\n  /**\n   * Convert tile coordinates to lon/lat bounds\n   */\n  private tileToBounds(z: number, x: number, y: number): number[] {\n    const n = Math.pow(2, z);\n\n    const west = x / n * 360 - 180;\n    const east = (x + 1) / n * 360 - 180;\n\n    const northLat = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;\n    const southLat = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;\n\n    return [west, southLat, east, northLat];\n  }\n\n  /**\n   * Clip feature to tile bounds (simplified)\n   */\n  private clipFeatureToTile(\n    feature: GeoJSONFeature,\n    z: number,\n    x: number,\n    y: number\n  ): GeoJSONFeature | null {\n    const tileBounds = this.tileToBounds(z, x, y);\n\n    // Check if feature intersects tile\n    const featureBounds = this.getFeatureBounds(feature);\n\n    if (!this.boundsIntersect(featureBounds, tileBounds)) {\n      return null;\n    }\n\n    // For simplicity, return entire feature\n    // In production, implement proper geometry clipping\n    return feature;\n  }\n\n  /**\n   * Check if two bounding boxes intersect\n   */\n  private boundsIntersect(bounds1: number[], bounds2: number[]): boolean {\n    const [w1, s1, e1, n1] = bounds1;\n    const [w2, s2, e2, n2] = bounds2;\n\n    return !(e1 < w2 || e2 < w1 || n1 < s2 || n2 < s1);\n  }\n\n  /**\n   * Get bounding box for a feature\n   */\n  private getFeatureBounds(feature: GeoJSONFeature): number[] {\n    const points = this.extractPoints(feature.geometry.coordinates);\n\n    let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;\n\n    points.forEach(([lon, lat]) => {\n      minLon = Math.min(minLon, lon);\n      minLat = Math.min(minLat, lat);\n      maxLon = Math.max(maxLon, lon);\n      maxLat = Math.max(maxLat, lat);\n    });\n\n    return [minLon, minLat, maxLon, maxLat];\n  }\n\n  /**\n   * Calculate bounds for all features\n   */\n  private calculateBounds(features: GeoJSONFeature[]): number[] {\n    let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;\n\n    features.forEach(feature => {\n      const [w, s, e, n] = this.getFeatureBounds(feature);\n      minLon = Math.min(minLon, w);\n      minLat = Math.min(minLat, s);\n      maxLon = Math.max(maxLon, e);\n      maxLat = Math.max(maxLat, n);\n    });\n\n    return [minLon, minLat, maxLon, maxLat];\n  }\n\n  /**\n   * Extract all points from coordinates (recursive)\n   */\n  private extractPoints(coords: any): number[][] {\n    if (typeof coords[0] === 'number') {\n      return [coords];\n    }\n\n    return coords.flatMap((c: any) => this.extractPoints(c));\n  }\n\n  /**\n   * Write tiles to MBTiles format (simplified)\n   */\n  private writeMBTiles(outputPath: string, tiles: Tile[], bounds: number[]): void {\n    const metadata: TilesetMetadata = {\n      name: this.options.name || path.basename(outputPath, '.mbtiles'),\n      version: '1.0.0',\n      attribution: this.options.attribution,\n      type: 'overlay',\n      format: 'geojson',\n      minzoom: this.options.minZoom,\n      maxzoom: this.options.maxZoom,\n      bounds,\n      center: [\n        (bounds[0] + bounds[2]) / 2,\n        (bounds[1] + bounds[3]) / 2,\n        Math.floor((this.options.minZoom + this.options.maxZoom) / 2)\n      ]\n    };\n\n    // For this example, write as directory structure\n    // In production, use SQLite database (better-sqlite3)\n    const tilesDir = outputPath.replace('.mbtiles', '_tiles');\n\n    if (!fs.existsSync(tilesDir)) {\n      fs.mkdirSync(tilesDir, { recursive: true });\n    }\n\n    // Write metadata\n    fs.writeFileSync(\n      path.join(tilesDir, 'metadata.json'),\n      JSON.stringify(metadata, null, 2)\n    );\n\n    // Write tiles\n    tiles.forEach(tile => {\n      const tileDir = path.join(tilesDir, `${tile.z}`, `${tile.x}`);\n      if (!fs.existsSync(tileDir)) {\n        fs.mkdirSync(tileDir, { recursive: true });\n      }\n\n      const tilePath = path.join(tileDir, `${tile.y}.geojson`);\n\n      const featureCollection: GeoJSONFeatureCollection = {\n        type: 'FeatureCollection',\n        features: tile.features\n      };\n\n      fs.writeFileSync(tilePath, JSON.stringify(featureCollection));\n    });\n\n    console.log(`\\nTiles written to ${tilesDir}/`);\n  }\n\n  /**\n   * Display tileset info\n   */\n  static info(mbtilesPath: string): void {\n    const tilesDir = mbtilesPath.replace('.mbtiles', '_tiles');\n\n    if (!fs.existsSync(tilesDir)) {\n      console.error(`Tileset not found: ${tilesDir}`);\n      process.exit(1);\n    }\n\n    const metadataPath = path.join(tilesDir, 'metadata.json');\n    const metadata: TilesetMetadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));\n\n    console.log(`\\nüì¶ Tileset Info\\n`);\n    console.log(`Name:        ${metadata.name}`);\n    console.log(`Version:     ${metadata.version}`);\n    console.log(`Format:      ${metadata.format}`);\n    console.log(`Zoom:        ${metadata.minzoom} - ${metadata.maxzoom}`);\n    console.log(`Bounds:      [${metadata.bounds.map(n => n.toFixed(4)).join(', ')}]`);\n    console.log(`Center:      [${metadata.center.map(n => n.toFixed(4)).join(', ')}]`);\n\n    if (metadata.attribution) {\n      console.log(`Attribution: ${metadata.attribution}`);\n    }\n\n    // Count tiles\n    let tileCount = 0;\n    for (let z = metadata.minzoom; z <= metadata.maxzoom; z++) {\n      const zoomDir = path.join(tilesDir, `${z}`);\n      if (fs.existsSync(zoomDir)) {\n        const xDirs = fs.readdirSync(zoomDir);\n        xDirs.forEach(xDir => {\n          const yFiles = fs.readdirSync(path.join(zoomDir, xDir));\n          tileCount += yFiles.length;\n        });\n      }\n    }\n\n    console.log(`Tiles:       ${tileCount}\\n`);\n  }\n}\n\n// CLI entry point\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  const command = args[0];\n\n  switch (command) {\n    case 'generate': {\n      if (args.length < 3) {\n        console.error('Usage: npx tsx tile_generator.ts generate <input.geojson> <output.mbtiles> [options]');\n        console.error('\\nOptions:');\n        console.error('  --minzoom <z>         Minimum zoom level (default: 0)');\n        console.error('  --maxzoom <z>         Maximum zoom level (default: 14)');\n        console.error('  --name <name>         Tileset name');\n        console.error('  --attribution <text>  Attribution text');\n        process.exit(1);\n      }\n\n      const inputPath = args[1];\n      const outputPath = args[2];\n\n      // Parse options\n      const options: TileGeneratorOptions = {\n        minZoom: 0,\n        maxZoom: 14\n      };\n\n      for (let i = 3; i < args.length; i += 2) {\n        const flag = args[i];\n        const value = args[i + 1];\n\n        switch (flag) {\n          case '--minzoom':\n            options.minZoom = parseInt(value);\n            break;\n          case '--maxzoom':\n            options.maxZoom = parseInt(value);\n            break;\n          case '--name':\n            options.name = value;\n            break;\n          case '--attribution':\n            options.attribution = value;\n            break;\n        }\n      }\n\n      const generator = new TileGenerator(options);\n      generator.generate(inputPath, outputPath);\n      break;\n    }\n\n    case 'info': {\n      if (args.length < 2) {\n        console.error('Usage: npx tsx tile_generator.ts info <tiles.mbtiles>');\n        process.exit(1);\n      }\n\n      TileGenerator.info(args[1]);\n      break;\n    }\n\n    default:\n      console.error('Unknown command. Available commands:');\n      console.error('  generate <input.geojson> <output.mbtiles> [options]');\n      console.error('  info <tiles.mbtiles>');\n      process.exit(1);\n  }\n}\n\nexport { TileGenerator, TileGeneratorOptions, TilesetMetadata };\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "geospatial-data-pipeline/SKILL.md",
      "size": 11264,
      "content": "---\nname: geospatial-data-pipeline\ndescription: Process, analyze, and visualize geospatial data at scale. Handles drone imagery, GPS tracks, GeoJSON optimization, coordinate transformations, and tile generation. Use for mapping apps, drone data processing, location-based services. Activate on \"geospatial\", \"GIS\", \"PostGIS\", \"GeoJSON\", \"map tiles\", \"coordinate systems\". NOT for simple address validation, basic distance calculations, or static map embeds.\nallowed-tools: Read,Write,Edit,Bash(npm:*,gdal*,postgres*)\n---\n\n# Geospatial Data Pipeline\n\nExpert in processing, optimizing, and visualizing geospatial data at scale.\n\n## When to Use\n\n‚úÖ **Use for**:\n- Drone imagery processing and annotation\n- GPS track analysis and visualization\n- Location-based search (find nearby X)\n- Map tile generation for web/mobile\n- Coordinate system transformations\n- Geofencing and spatial queries\n- GeoJSON optimization for web\n\n‚ùå **NOT for**:\n- Simple address validation (use address APIs)\n- Basic distance calculations (use Haversine formula)\n- Static map embeds (use Mapbox Static API)\n- Geocoding (use Nominatim or Google Geocoding API)\n\n---\n\n## Technology Selection\n\n### Database: PostGIS vs MongoDB Geospatial\n\n| Feature | PostGIS | MongoDB |\n|---------|---------|---------|\n| Spatial indexes | GiST, SP-GiST | 2dsphere |\n| Query language | SQL + spatial functions | Aggregation pipeline |\n| Geometry types | 20+ (full OGC support) | Basic (Point, Line, Polygon) |\n| Coordinate systems | 6000+ via EPSG | WGS84 only |\n| Performance (10M points) | &lt;100ms | &lt;200ms |\n| Best for | Complex spatial analysis | Document-centric apps |\n\n**Timeline**:\n- 2005: PostGIS 1.0 released\n- 2012: MongoDB adds geospatial indexes\n- 2020: PostGIS 3.0 with improved performance\n- 2024: PostGIS remains gold standard for GIS workloads\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: Storing Coordinates as Strings\n\n**Novice thinking**: \"I'll just store lat/lon as text, it's simple\"\n\n**Problem**: Can't use spatial indexes, queries are slow, no validation.\n\n**Wrong approach**:\n```typescript\n// ‚ùå String storage, no spatial features\ninterface Location {\n  id: string;\n  name: string;\n  latitude: string;   // \"37.7749\"\n  longitude: string;  // \"-122.4194\"\n}\n\n// Linear scan for \"nearby\" queries\nasync function findNearby(lat: string, lon: string): Promise<Location[]> {\n  const all = await db.locations.findAll();\n\n  return all.filter(loc => {\n    const distance = calculateDistance(\n      parseFloat(lat),\n      parseFloat(lon),\n      parseFloat(loc.latitude),\n      parseFloat(loc.longitude)\n    );\n    return distance < 5000; // 5km\n  });\n}\n```\n\n**Why wrong**: O(N) linear scan, no spatial index, string parsing overhead.\n\n**Correct approach**:\n```typescript\n// ‚úÖ PostGIS GEOGRAPHY type with spatial index\nCREATE TABLE locations (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255),\n  location GEOGRAPHY(POINT, 4326)  -- WGS84 coordinates\n);\n\n-- Spatial index (GiST)\nCREATE INDEX idx_locations_geography ON locations USING GIST(location);\n\n-- TypeScript query\nasync function findNearby(lat: number, lon: number, radiusMeters: number): Promise<Location[]> {\n  const query = `\n    SELECT id, name, ST_AsGeoJSON(location) as geojson\n    FROM locations\n    WHERE ST_DWithin(\n      location,\n      ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,\n      $3\n    )\n    ORDER BY location <-> ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography\n    LIMIT 100\n  `;\n\n  return db.query(query, [lon, lat, radiusMeters]);  // &lt;10ms with index\n}\n```\n\n**Timeline context**:\n- 2000s: Stored lat/lon as FLOAT columns, did math in app code\n- 2010s: PostGIS adoption, spatial indexes\n- 2024: `GEOGRAPHY` type handles Earth curvature automatically\n\n---\n\n### Anti-Pattern 2: Not Using Spatial Indexes\n\n**Problem**: Proximity queries do full table scans.\n\n**Wrong approach**:\n```sql\n-- ‚ùå No index, sequential scan\nCREATE TABLE drone_images (\n  id SERIAL PRIMARY KEY,\n  image_url VARCHAR(255),\n  location GEOGRAPHY(POINT, 4326)\n);\n\n-- This query scans ALL rows\nSELECT * FROM drone_images\nWHERE ST_DWithin(\n  location,\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  1000  -- 1km\n);\n```\n\n**EXPLAIN output**: `Seq Scan on drone_images (cost=0.00..1234.56 rows=1 width=123)`\n\n**Correct approach**:\n```sql\n-- ‚úÖ GiST index for spatial queries\nCREATE INDEX idx_drone_images_location ON drone_images USING GIST(location);\n\n-- Same query, now uses index\nSELECT * FROM drone_images\nWHERE ST_DWithin(\n  location,\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  1000\n);\n```\n\n**EXPLAIN output**: `Bitmap Index Scan on idx_drone_images_location (cost=4.30..78.30 rows=50 width=123)`\n\n**Performance impact**: 10M points, 5km radius query\n- Without index: 3.2 seconds (full scan)\n- With GiST index: 12ms (99.6% faster)\n\n---\n\n### Anti-Pattern 3: Mixing Coordinate Systems\n\n**Novice thinking**: \"Coordinates are just numbers, I can mix them\"\n\n**Problem**: Incorrect distances, misaligned map features.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Mixing EPSG:4326 (WGS84) and EPSG:3857 (Web Mercator)\nconst userLocation = {\n  lat: 37.7749,   // WGS84\n  lon: -122.4194\n};\n\nconst droneImage = {\n  x: -13634876,  // Web Mercator (EPSG:3857)\n  y: 4545684\n};\n\n// Comparing apples to oranges!\nconst distance = Math.sqrt(\n  Math.pow(userLocation.lon - droneImage.x, 2) +\n  Math.pow(userLocation.lat - droneImage.y, 2)\n);\n```\n\n**Result**: Wildly incorrect distance (millions of \"units\").\n\n**Correct approach**:\n```sql\n-- ‚úÖ Transform to common coordinate system\nSELECT ST_Distance(\n  ST_Transform(\n    ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326),  -- WGS84\n    3857  -- Transform to Web Mercator\n  ),\n  ST_SetSRID(ST_MakePoint(-13634876, 4545684), 3857)  -- Already Web Mercator\n) AS distance_meters;\n```\n\n**Or better**: Always store in one system (WGS84), transform on display only.\n\n**Timeline**:\n- 2005: Web Mercator (EPSG:3857) introduced by Google Maps\n- 2010: Confusion peaks as apps mix WGS84 data with Web Mercator tiles\n- 2024: Best practice: Store WGS84, transform to 3857 only for tile rendering\n\n---\n\n### Anti-Pattern 4: Loading Huge GeoJSON Files\n\n**Problem**: 50MB GeoJSON file crashes browser.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Load entire file into memory\nconst geoJson = await fetch('/drone-survey-data.geojson').then(r => r.json());\n\n// 50MB of GeoJSON = browser freeze\nmap.addSource('drone-data', {\n  type: 'geojson',\n  data: geoJson  // All 10,000 polygons loaded at once\n});\n```\n\n**Correct approach 1**: Vector tiles (pre-chunked)\n```typescript\n// ‚úÖ Serve as vector tiles (MBTiles or PMTiles)\nmap.addSource('drone-data', {\n  type: 'vector',\n  tiles: ['https://api.example.com/tiles/{z}/{x}/{y}.pbf'],\n  minzoom: 10,\n  maxzoom: 18\n});\n\n// Browser only loads visible tiles\n```\n\n**Correct approach 2**: GeoJSON simplification + chunking\n```bash\n# Simplify geometry (reduce points)\nnpm install -g @mapbox/geojson-precision\ngeojson-precision -p 5 input.geojson output.geojson\n\n# Split into tiles\nnpm install -g geojson-vt\n# Generate tiles programmatically (see scripts/tile_generator.ts)\n```\n\n**Correct approach 3**: Server-side filtering\n```typescript\n// ‚úÖ Only fetch visible bounds\nasync function fetchVisibleFeatures(bounds: Bounds): Promise<GeoJSON> {\n  const response = await fetch(\n    `/api/features?bbox=${bounds.west},${bounds.south},${bounds.east},${bounds.north}`\n  );\n  return response.json();\n}\n\nmap.on('moveend', async () => {\n  const bounds = map.getBounds();\n  const geojson = await fetchVisibleFeatures(bounds);\n  map.getSource('dynamic-data').setData(geojson);\n});\n```\n\n---\n\n### Anti-Pattern 5: Euclidean Distance on Spherical Earth\n\n**Novice thinking**: \"Distance is just Pythagorean theorem\"\n\n**Problem**: Incorrect at scale, worse near poles.\n\n**Wrong approach**:\n```typescript\n// ‚ùå Flat Earth distance (wrong!)\nfunction distanceKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const dx = lon2 - lon1;\n  const dy = lat2 - lat1;\n\n  return Math.sqrt(dx * dx + dy * dy) * 111.32;  // 111.32 km/degree (WRONG)\n}\n\n// Example: San Francisco to New York\nconst distance = distanceKm(37.7749, -122.4194, 40.7128, -74.0060);\n// Returns: ~55 km (WRONG! Actual: ~4,130 km)\n```\n\n**Why wrong**: Earth is a sphere, not a flat plane.\n\n**Correct approach 1**: Haversine formula (great circle distance)\n```typescript\n// ‚úÖ Haversine formula (spherical Earth)\nfunction haversineKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371; // Earth radius in km\n\n  const dLat = toRadians(lat2 - lat1);\n  const dLon = toRadians(lon2 - lon1);\n\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return R * c;\n}\n\n// San Francisco to New York\nconst distance = haversineKm(37.7749, -122.4194, 40.7128, -74.0060);\n// Returns: ~4,130 km ‚úÖ\n```\n\n**Correct approach 2**: PostGIS (handles curvature automatically)\n```sql\n-- ‚úÖ PostGIS ST_Distance with GEOGRAPHY\nSELECT ST_Distance(\n  ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography,\n  ST_SetSRID(ST_MakePoint(-74.0060, 40.7128), 4326)::geography\n) / 1000 AS distance_km;\n-- Returns: 4130.137 km ‚úÖ\n```\n\n**Accuracy comparison**:\n| Method | SF to NYC | Error |\n|--------|-----------|-------|\n| Euclidean (flat) | 55 km | 98.7% wrong |\n| Haversine (sphere) | 4,130 km | ‚úÖ Correct |\n| PostGIS (ellipsoid) | 4,135 km | Most accurate |\n\n---\n\n## Production Checklist\n\n```\n‚ñ° PostGIS extension installed and spatial indexes created\n‚ñ° All coordinates stored in consistent SRID (recommend: 4326)\n‚ñ° GeoJSON files optimized (&lt;1MB) or served as vector tiles\n‚ñ° Coordinate transformations use ST_Transform, not manual math\n‚ñ° Distance calculations use ST_Distance with GEOGRAPHY type\n‚ñ° Bounding box queries use ST_MakeEnvelope + ST_Intersects\n‚ñ° Large geometries chunked (not &gt;100KB per feature)\n‚ñ° Map tiles pre-generated for common zoom levels\n‚ñ° CORS configured for tile servers\n‚ñ° Rate limiting on geocoding/reverse geocoding endpoints\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Appropriate? |\n|----------|--------------|\n| Drone imagery annotation and search | ‚úÖ Yes - process survey data |\n| GPS track visualization | ‚úÖ Yes - optimize paths |\n| Find nearest coffee shops | ‚úÖ Yes - spatial queries |\n| Jurisdiction boundary lookups | ‚úÖ Yes - point-in-polygon |\n| Simple address autocomplete | ‚ùå No - use Mapbox/Google |\n| Embed static map on page | ‚ùå No - use Static API |\n| Geocode single address | ‚ùå No - use geocoding API |\n\n---\n\n## References\n\n- `/references/coordinate-systems.md` - EPSG codes, transformations, Web Mercator vs WGS84\n- `/references/postgis-guide.md` - PostGIS setup, spatial indexes, common queries\n- `/references/geojson-optimization.md` - Simplification, chunking, vector tiles\n\n## Scripts\n\n- `scripts/geospatial_processor.ts` - Process drone imagery, GPS tracks, GeoJSON validation\n- `scripts/tile_generator.ts` - Generate vector tiles (MBTiles/PMTiles) from GeoJSON\n\n---\n\n**This skill guides**: Geospatial data | PostGIS | GeoJSON | Map tiles | Coordinate systems | Drone data processing | Spatial queries\n"
    }
  ]
}