{
  "name": "video-processing-editing",
  "type": "folder",
  "path": "video-processing-editing",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "video-processing-editing/references",
      "children": [
        {
          "name": "export-optimization.md",
          "type": "file",
          "path": "video-processing-editing/references/export-optimization.md",
          "size": 10689,
          "content": "# Export Optimization Reference\n\nPlatform-specific export settings and optimization techniques.\n\n## Platform Specifications (2024/2025)\n\n### YouTube\n\n| Setting | Recommended | Maximum |\n|---------|-------------|---------|\n| Resolution | 1920x1080 (1080p) | 7680x4320 (8K) |\n| Frame Rate | 30 fps | 60 fps |\n| Bitrate | Auto (CRF 18) | Unlimited |\n| Max File Size | 256 GB | 256 GB |\n| Max Duration | 12 hours | 12 hours |\n| Container | MP4 | MP4, MOV, MKV |\n| Video Codec | H.264 | H.264, H.265, VP9, AV1 |\n| Audio | AAC 192kbps | AAC 384kbps |\n| Color | BT.709 SDR | BT.2020 HDR |\n\n```bash\n# YouTube 1080p (standard)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset slow -crf 18 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -color_primaries bt709 -color_trc bt709 -colorspace bt709 \\\n  -movflags +faststart \\\n  -c:a aac -b:a 192k -ar 48000 \\\n  youtube_1080p.mp4\n\n# YouTube 4K HDR\nffmpeg -i input.mp4 \\\n  -c:v libx265 -preset slow -crf 18 \\\n  -s 3840x2160 -r 60 \\\n  -pix_fmt yuv420p10le \\\n  -color_primaries bt2020 -color_trc smpte2084 -colorspace bt2020nc \\\n  -x265-params \"hdr-opt=1:repeat-headers=1:colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:master-display=G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(10000000,1):max-cll=1000,400\" \\\n  -movflags +faststart \\\n  -c:a aac -b:a 256k -ar 48000 \\\n  youtube_4k_hdr.mp4\n```\n\n### Instagram\n\n**Stories**\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1080x1920 (9:16) |\n| Frame Rate | 30 fps |\n| Max Duration | 60 seconds |\n| Max File Size | 250 MB |\n| Video Codec | H.264 |\n| Audio | AAC 128kbps |\n\n**Reels**\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1080x1920 (9:16) |\n| Frame Rate | 30 fps |\n| Max Duration | 90 seconds |\n| Max File Size | 4 GB |\n| Video Codec | H.264 |\n| Audio | AAC 128kbps |\n\n**Feed**\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1080x1080 (1:1) or 1080x1350 (4:5) |\n| Frame Rate | 30 fps |\n| Max Duration | 60 minutes |\n| Video Codec | H.264 |\n| Audio | AAC 128kbps |\n\n```bash\n# Instagram Story\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 60 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_story.mp4\n\n# Instagram Reel\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 90 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_reel.mp4\n\n# Instagram Feed (4:5 portrait)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -vf \"scale=1080:1350:force_original_aspect_ratio=decrease,pad=1080:1350:(ow-iw)/2:(oh-ih)/2\" \\\n  -r 30 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_feed.mp4\n```\n\n### TikTok\n\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1080x1920 (9:16) |\n| Frame Rate | 30 fps |\n| Max Duration | 10 minutes |\n| Max File Size | 287 MB (mobile), 1 GB (web) |\n| Video Codec | H.264 |\n| Audio | AAC 128kbps |\n| Bitrate | 3-5 Mbps recommended |\n\n```bash\n# TikTok\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 600 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  tiktok.mp4\n```\n\n### Twitter/X\n\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1920x1080 (16:9) or 1280x720 |\n| Frame Rate | 30-60 fps |\n| Max Duration | 2 minutes 20 seconds |\n| Max File Size | 512 MB |\n| Video Codec | H.264 |\n| Max Bitrate | 25 Mbps |\n| Audio | AAC, max 128kbps |\n\n```bash\n# Twitter/X\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1280x720 -r 30 -t 140 \\\n  -maxrate 5M -bufsize 10M \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  twitter.mp4\n```\n\n### LinkedIn\n\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1920x1080 (16:9) |\n| Frame Rate | 30 fps |\n| Max Duration | 10 minutes (native), 15 min (ads) |\n| Max File Size | 5 GB |\n| Video Codec | H.264 |\n| Audio | AAC 128kbps |\n\n```bash\n# LinkedIn\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1920x1080 -r 30 -t 600 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  linkedin.mp4\n```\n\n### Facebook\n\n| Setting | Requirement |\n|---------|-------------|\n| Resolution | 1920x1080 or 1080x1920 |\n| Frame Rate | 30 fps |\n| Max Duration | 240 minutes |\n| Max File Size | 10 GB |\n| Video Codec | H.264, H.265 |\n| Audio | AAC, MP3 |\n\n```bash\n# Facebook (landscape)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  facebook.mp4\n\n# Facebook Stories/Reels (vertical)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 60 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  facebook_story.mp4\n```\n\n## Web Optimization\n\n### HTML5 Video\n\n```bash\n# Maximum compatibility (works everywhere)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -profile:v baseline -level 3.0 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k -ar 48000 \\\n  web_compatible.mp4\n```\n\n### Adaptive Bitrate Streaming (HLS)\n\n```bash\n# Generate HLS with multiple quality levels\nffmpeg -i input.mp4 \\\n  -filter_complex \"[0:v]split=3[v1][v2][v3]\" \\\n  -map \"[v1]\" -c:v:0 libx264 -b:v:0 5M -s:v:0 1920x1080 -profile:v:0 high \\\n  -map \"[v2]\" -c:v:1 libx264 -b:v:1 3M -s:v:1 1280x720 -profile:v:1 main \\\n  -map \"[v3]\" -c:v:2 libx264 -b:v:2 1M -s:v:2 854x480 -profile:v:2 baseline \\\n  -map 0:a -c:a aac -b:a 128k \\\n  -var_stream_map \"v:0,a:0 v:1,a:0 v:2,a:0\" \\\n  -master_pl_name master.m3u8 \\\n  -f hls -hls_time 6 -hls_list_size 0 \\\n  -hls_segment_filename \"v%v/segment%d.ts\" \\\n  v%v/playlist.m3u8\n```\n\n### WebM (VP9)\n\n```bash\n# WebM for modern browsers (smaller file size)\nffmpeg -i input.mp4 \\\n  -c:v libvpx-vp9 -crf 30 -b:v 0 \\\n  -s 1920x1080 -r 30 \\\n  -c:a libopus -b:a 128k \\\n  output.webm\n```\n\n## Compression Optimization\n\n### Quality vs File Size\n\n| CRF Value | Quality | Use Case |\n|-----------|---------|----------|\n| 17-18 | Visually lossless | Archival, mastering |\n| 19-21 | High quality | YouTube, streaming |\n| 22-23 | Good quality | Social media |\n| 24-26 | Acceptable | Mobile, bandwidth-limited |\n| 27-28 | Lower quality | Drafts, previews |\n\n### Two-Pass Encoding (Target File Size)\n\n```bash\n# Target 50 MB file for 60s video\n# Calculate bitrate: (50 MB * 8) / 60s = 6.67 Mbps\n# Subtract audio: 6.67 - 0.128 = 6.54 Mbps video\n\n# Pass 1\nffmpeg -i input.mp4 -c:v libx264 -b:v 6500k -pass 1 -f null /dev/null\n\n# Pass 2\nffmpeg -i input.mp4 -c:v libx264 -b:v 6500k -pass 2 -c:a aac -b:a 128k output.mp4\n```\n\n### Preset Selection\n\n| Preset | Speed | Compression | Use Case |\n|--------|-------|-------------|----------|\n| ultrafast | Very fast | Poor | Drafts, testing |\n| superfast | Fast | Poor | Quick previews |\n| veryfast | Fast | OK | Streaming, live |\n| faster | Fast | OK | Quick exports |\n| fast | Medium | Good | Balance |\n| medium | Medium | Good | Default |\n| slow | Slow | Better | Final export |\n| slower | Very slow | Best | Final mastering |\n| veryslow | Extremely slow | Best | Archive quality |\n\n```bash\n# Draft (fastest)\nffmpeg -i input.mp4 -c:v libx264 -preset ultrafast -crf 28 draft.mp4\n\n# Final (best quality)\nffmpeg -i input.mp4 -c:v libx264 -preset veryslow -crf 18 final.mp4\n```\n\n## Progressive Download Optimization\n\n### faststart for Web\n\n```bash\n# CRITICAL for web playback - moves moov atom to beginning\nffmpeg -i input.mp4 -c copy -movflags +faststart output.mp4\n\n# For new encodes\nffmpeg -i input.mp4 -c:v libx264 -crf 23 -movflags +faststart output.mp4\n```\n\nWithout `-movflags +faststart`:\n1. Browser downloads entire file\n2. Finds moov atom at end\n3. Only then can start playback\n\nWith `-movflags +faststart`:\n1. Browser downloads beginning\n2. Finds moov atom immediately\n3. Playback starts instantly\n\n## Batch Export Script\n\n```bash\n#!/bin/bash\n# Export to all platforms at once\n\nINPUT=\"$1\"\nBASENAME=\"${INPUT%.*}\"\n\n# YouTube 1080p\nffmpeg -i \"$INPUT\" \\\n  -c:v libx264 -preset slow -crf 18 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 192k \\\n  \"${BASENAME}_youtube.mp4\"\n\n# Instagram Reel\nffmpeg -i \"$INPUT\" \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 90 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  \"${BASENAME}_instagram.mp4\"\n\n# Twitter\nffmpeg -i \"$INPUT\" \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1280x720 -r 30 -t 140 \\\n  -maxrate 5M -bufsize 10M \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  \"${BASENAME}_twitter.mp4\"\n\n# TikTok\nffmpeg -i \"$INPUT\" \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  \"${BASENAME}_tiktok.mp4\"\n\necho \"Exports complete!\"\n```\n\n## Hardware Acceleration\n\n### NVIDIA NVENC\n\n```bash\n# NVENC encoding (10-20x faster than CPU)\nffmpeg -hwaccel cuda -i input.mp4 \\\n  -c:v h264_nvenc -preset p7 -rc:v vbr -cq:v 19 \\\n  -b:v 0 -s 1920x1080 \\\n  -c:a aac -b:a 192k \\\n  output.mp4\n\n# Presets: p1 (fastest) to p7 (best quality)\n# cq:v: Quality level (lower = better, 19 ≈ CRF 18)\n```\n\n### Apple VideoToolbox (macOS)\n\n```bash\n# VideoToolbox encoding (uses Apple Silicon/Intel GPU)\nffmpeg -i input.mp4 \\\n  -c:v h264_videotoolbox -q:v 60 \\\n  -s 1920x1080 \\\n  -c:a aac -b:a 192k \\\n  output.mp4\n\n# q:v: Quality 1-100 (higher = better, 60 ≈ CRF 20)\n```\n\n### Intel Quick Sync\n\n```bash\n# QSV encoding\nffmpeg -hwaccel qsv -i input.mp4 \\\n  -c:v h264_qsv -preset slow -global_quality 20 \\\n  -s 1920x1080 \\\n  -c:a aac -b:a 192k \\\n  output.mp4\n```\n\n## Verification\n\n### Check Output Quality\n\n```bash\n# Get VMAF score (requires libvmaf)\nffmpeg -i original.mp4 -i encoded.mp4 \\\n  -lavfi libvmaf=\"log_fmt=json:log_path=vmaf.json\" \\\n  -f null -\n\n# VMAF interpretation:\n# 90+: Excellent (indistinguishable)\n# 80-90: Good quality\n# 70-80: Acceptable\n# <70: Noticeable quality loss\n```\n\n### Check File Metadata\n\n```bash\n# Verify encoding settings\nffprobe -v error -show_format -show_streams output.mp4\n\n# Check moov atom position (for faststart)\nffprobe -v trace output.mp4 2>&1 | grep -E \"moov|mdat\"\n# moov should appear before mdat for faststart\n```\n\n### Check Platform Compatibility\n\n```bash\n# Verify H.264 profile and level\nffprobe -v error -select_streams v:0 \\\n  -show_entries stream=profile,level \\\n  -of default=noprint_wrappers=1 output.mp4\n\n# For maximum compatibility:\n# profile: Baseline or Main\n# level: 3.0 or 3.1\n```\n\n---\n\nThis reference covers export optimization. For timeline concepts, see `timeline-editing.md`. For FFmpeg commands, see `ffmpeg-guide.md`.\n"
        },
        {
          "name": "ffmpeg-guide.md",
          "type": "file",
          "path": "video-processing-editing/references/ffmpeg-guide.md",
          "size": 14079,
          "content": "# FFmpeg Complete Reference Guide\n\nComprehensive FFmpeg command reference for video processing and editing.\n\n## Essential Commands\n\n### Basic Conversion\n\n```bash\n# Convert format (auto settings)\nffmpeg -i input.mp4 output.avi\n\n# Convert with specific codec\nffmpeg -i input.mp4 -c:v libx264 -c:a aac output.mp4\n\n# Copy streams without re-encoding (fast)\nffmpeg -i input.mp4 -c copy output.mp4\n```\n\n### Cutting and Trimming\n\n```bash\n# Cut from start time, specific duration\nffmpeg -i input.mp4 -ss 00:01:30 -t 00:00:30 output.mp4\n\n# Cut from start to end time\nffmpeg -i input.mp4 -ss 00:01:00 -to 00:05:00 output.mp4\n\n# Two-pass cutting (fast + accurate)\nffmpeg -ss 00:01:00 -i input.mp4 -ss 00:00:05 -t 00:01:30 -c:v libx264 -crf 18 output.mp4\n```\n\n### Quality Control\n\n```bash\n# CRF (Constant Rate Factor) - recommended\n# Lower = better quality, larger file\n# 18 = visually lossless, 23 = high quality, 28 = acceptable\nffmpeg -i input.mp4 -c:v libx264 -crf 18 output.mp4\n\n# Two-pass encoding (best quality for target size)\nffmpeg -i input.mp4 -c:v libx264 -b:v 2M -pass 1 -f null /dev/null\nffmpeg -i input.mp4 -c:v libx264 -b:v 2M -pass 2 output.mp4\n\n# Preset (speed vs compression)\n# ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow\nffmpeg -i input.mp4 -c:v libx264 -preset slow -crf 18 output.mp4\n```\n\n### Resolution and Scaling\n\n```bash\n# Scale to specific resolution\nffmpeg -i input.mp4 -vf scale=1920:1080 output.mp4\n\n# Scale maintaining aspect ratio\nffmpeg -i input.mp4 -vf scale=1920:-2 output.mp4  # width=1920, height=auto (even)\nffmpeg -i input.mp4 -vf scale=-2:1080 output.mp4  # height=1080, width=auto\n\n# Scale with high-quality algorithm\nffmpeg -i input.mp4 -vf scale=1920:1080:flags=lanczos output.mp4\n```\n\n### Frame Rate\n\n```bash\n# Change frame rate\nffmpeg -i input.mp4 -r 30 output.mp4\n\n# Slow motion (interpolate frames)\nffmpeg -i input.mp4 -filter:v \"minterpolate='fps=60:mi_mode=mci'\" output.mp4\n\n# Speed up video\nffmpeg -i input.mp4 -filter:v \"setpts=0.5*PTS\" output.mp4  # 2x speed\n```\n\n### Audio Operations\n\n```bash\n# Extract audio\nffmpeg -i input.mp4 -vn -c:a copy audio.aac\n\n# Remove audio\nffmpeg -i input.mp4 -an output.mp4\n\n# Replace audio\nffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac -map 0:v -map 1:a output.mp4\n\n# Mix audio (50/50)\nffmpeg -i video.mp4 -i audio.mp3 -filter_complex \"[0:a][1:a]amix=inputs=2[a]\" -map 0:v -map \"[a]\" output.mp4\n\n# Adjust audio volume\nffmpeg -i input.mp4 -af \"volume=2.0\" output.mp4  # 2x louder\nffmpeg -i input.mp4 -af \"volume=0.5\" output.mp4  # half volume\n\n# Normalize audio\nffmpeg -i input.mp4 -af \"loudnorm=I=-16:TP=-1.5:LRA=11\" output.mp4\n```\n\n### Concatenation\n\n```bash\n# Create concat file\necho \"file 'video1.mp4'\" > list.txt\necho \"file 'video2.mp4'\" >> list.txt\necho \"file 'video3.mp4'\" >> list.txt\n\n# Concatenate (must have same codec/resolution)\nffmpeg -f concat -safe 0 -i list.txt -c copy output.mp4\n\n# Concatenate with re-encoding (different formats)\nffmpeg -f concat -safe 0 -i list.txt -c:v libx264 -crf 18 output.mp4\n\n# Concatenate specific segments\nffmpeg -i input.mp4 -filter_complex \\\n  \"[0:v]trim=0:5,setpts=PTS-STARTPTS[v1]; \\\n   [0:v]trim=10:15,setpts=PTS-STARTPTS[v2]; \\\n   [v1][v2]concat=n=2:v=1[out]\" \\\n  -map \"[out]\" output.mp4\n```\n\n### Subtitles\n\n```bash\n# Burn subtitles into video\nffmpeg -i input.mp4 -vf subtitles=subs.srt output.mp4\n\n# Add soft subtitles (MP4)\nffmpeg -i input.mp4 -i subs.srt -c copy -c:s mov_text output.mp4\n\n# Add soft subtitles (MKV)\nffmpeg -i input.mp4 -i subs.srt -c copy -c:s srt output.mkv\n\n# Style burned subtitles\nffmpeg -i input.mp4 -vf \"subtitles=subs.srt:force_style='FontName=Arial,FontSize=24,PrimaryColour=&H00FFFF'\" output.mp4\n```\n\n### Cropping and Padding\n\n```bash\n# Crop video (remove edges)\nffmpeg -i input.mp4 -vf \"crop=1920:800:0:140\" output.mp4\n# Format: crop=width:height:x:y\n\n# Auto-detect crop (remove black bars)\nffmpeg -i input.mp4 -vf \"cropdetect=24:16:0\" -f null -\n# Use detected values in actual crop\n\n# Add padding (letterbox/pillarbox)\nffmpeg -i input.mp4 -vf \"pad=1920:1080:0:100:black\" output.mp4\n# Format: pad=width:height:x:y:color\n```\n\n### Filters (Video Effects)\n\n```bash\n# Brightness/Contrast\nffmpeg -i input.mp4 -vf \"eq=brightness=0.1:contrast=1.2\" output.mp4\n\n# Saturation\nffmpeg -i input.mp4 -vf \"eq=saturation=1.5\" output.mp4\n\n# Gamma correction\nffmpeg -i input.mp4 -vf \"eq=gamma=1.2\" output.mp4\n\n# Sharpen\nffmpeg -i input.mp4 -vf \"unsharp=5:5:1.0\" output.mp4\n\n# Blur\nffmpeg -i input.mp4 -vf \"boxblur=5:1\" output.mp4\n\n# Denoise\nffmpeg -i input.mp4 -vf \"hqdn3d=4:3:6:4.5\" output.mp4\n\n# Deinterlace\nffmpeg -i input.mp4 -vf \"yadif=0:-1:0\" output.mp4\n\n# Rotate\nffmpeg -i input.mp4 -vf \"rotate=45*PI/180\" output.mp4  # 45 degrees\nffmpeg -i input.mp4 -vf \"transpose=1\" output.mp4  # 90 degrees clockwise\n\n# Flip\nffmpeg -i input.mp4 -vf \"hflip\" output.mp4  # horizontal\nffmpeg -i input.mp4 -vf \"vflip\" output.mp4  # vertical\n```\n\n### Overlays and Watermarks\n\n```bash\n# Add watermark (top-left)\nffmpeg -i input.mp4 -i logo.png -filter_complex \"overlay=10:10\" output.mp4\n\n# Add watermark (bottom-right with padding)\nffmpeg -i input.mp4 -i logo.png -filter_complex \"overlay=W-w-10:H-h-10\" output.mp4\n\n# Fade in watermark\nffmpeg -i input.mp4 -i logo.png -filter_complex \\\n  \"[1:v]fade=in:st=0:d=1:alpha=1[logo]; \\\n   [0:v][logo]overlay=W-w-10:H-h-10\" output.mp4\n\n# Add text overlay\nffmpeg -i input.mp4 -vf \"drawtext=text='Hello World':fontfile=/path/to/font.ttf:fontsize=24:fontcolor=white:x=10:y=10\" output.mp4\n```\n\n### Transitions\n\n```bash\n# Crossfade between two videos\nffmpeg -i video1.mp4 -i video2.mp4 -filter_complex \\\n  \"[0:v][1:v]xfade=transition=fade:duration=1:offset=5\" output.mp4\n\n# Available transitions:\n# fade, fadeblack, fadewhite, distance, wipeleft, wiperight,\n# wipeup, wipedown, slideleft, slideright, slideup, slidedown,\n# circlecrop, rectcrop, circleclose, circleopen, dissolve\n```\n\n### Color Grading\n\n```bash\n# Convert to grayscale\nffmpeg -i input.mp4 -vf \"hue=s=0\" output.mp4\n\n# Adjust hue\nffmpeg -i input.mp4 -vf \"hue=h=90\" output.mp4  # shift hue by 90 degrees\n\n# Color temperature (warm)\nffmpeg -i input.mp4 -vf \"eq=brightness=0.02:saturation=1.1,hue=h=10\" output.mp4\n\n# Color temperature (cool)\nffmpeg -i input.mp4 -vf \"eq=brightness=-0.02:saturation=1.1,hue=h=-10\" output.mp4\n\n# Vintage/sepia look\nffmpeg -i input.mp4 -vf \"colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131\" output.mp4\n\n# High contrast B&W\nffmpeg -i input.mp4 -vf \"hue=s=0,eq=contrast=1.5:brightness=0.1\" output.mp4\n```\n\n### Color Space Conversion\n\n```bash\n# SDR to HDR (basic)\nffmpeg -i input.mp4 -vf \"zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt2020:t=smpte2084:m=bt2020nc:r=full,format=yuv420p10le\" output.mp4\n\n# HDR to SDR (tonemap)\nffmpeg -i input.mp4 -vf \"zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=hable:desat=0,zscale=t=bt709:m=bt709:r=limited,format=yuv420p\" output.mp4\n\n# BT.601 to BT.709 (SD to HD)\nffmpeg -i input.mp4 -vf \"scale=in_range=full:out_range=limited,colorspace=bt709:iall=bt601:fast=1\" \\\n  -color_primaries bt709 -color_trc bt709 -colorspace bt709 output.mp4\n```\n\n### Encoding Presets\n\n```bash\n# YouTube 1080p\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset slow -crf 18 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -color_primaries bt709 -color_trc bt709 -colorspace bt709 \\\n  -movflags +faststart \\\n  -c:a aac -b:a 192k -ar 48000 \\\n  youtube.mp4\n\n# Instagram Story (9:16)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 15 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_story.mp4\n\n# Twitter (720p, 2:20 max)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1280x720 -r 30 -t 140 \\\n  -maxrate 5000k -bufsize 10000k \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  twitter.mp4\n\n# Web (HTML5 compatible)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -profile:v baseline -level 3.0 \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k -ar 48000 \\\n  web.mp4\n```\n\n### Hardware Acceleration\n\n```bash\n# NVIDIA NVENC (GPU encoding)\nffmpeg -hwaccel cuda -i input.mp4 \\\n  -c:v h264_nvenc -preset slow -crf 18 \\\n  output.mp4\n\n# Apple VideoToolbox (Mac)\nffmpeg -i input.mp4 \\\n  -c:v h264_videotoolbox -b:v 5M \\\n  output.mp4\n\n# Intel Quick Sync (QSV)\nffmpeg -hwaccel qsv -i input.mp4 \\\n  -c:v h264_qsv -preset slow -global_quality 18 \\\n  output.mp4\n\n# AMD VCE\nffmpeg -i input.mp4 \\\n  -c:v h264_amf -quality quality -rc cqp -qp_i 18 -qp_p 18 \\\n  output.mp4\n```\n\n### Advanced Filters\n\n```bash\n# Stabilization (two-pass)\n# Pass 1: Analyze\nffmpeg -i input.mp4 -vf vidstabdetect=shakiness=10:accuracy=15 -f null -\n\n# Pass 2: Transform\nffmpeg -i input.mp4 -vf vidstabtransform=smoothing=30:input=\"transforms.trf\" output.mp4\n\n# Picture-in-picture\nffmpeg -i main.mp4 -i pip.mp4 -filter_complex \\\n  \"[1:v]scale=320:240[pip]; \\\n   [0:v][pip]overlay=W-w-10:H-h-10\" output.mp4\n\n# Side-by-side comparison\nffmpeg -i video1.mp4 -i video2.mp4 -filter_complex \\\n  \"[0:v]scale=iw/2:ih[left]; \\\n   [1:v]scale=iw/2:ih[right]; \\\n   [left][right]hstack\" output.mp4\n\n# Grid layout (2x2)\nffmpeg -i v1.mp4 -i v2.mp4 -i v3.mp4 -i v4.mp4 -filter_complex \\\n  \"[0:v][1:v]hstack[top]; \\\n   [2:v][3:v]hstack[bottom]; \\\n   [top][bottom]vstack\" output.mp4\n```\n\n### Metadata\n\n```bash\n# View metadata\nffmpeg -i input.mp4 -f ffmetadata metadata.txt\n\n# Remove all metadata\nffmpeg -i input.mp4 -map_metadata -1 -c copy output.mp4\n\n# Add metadata\nffmpeg -i input.mp4 -metadata title=\"My Video\" -metadata author=\"John Doe\" -c copy output.mp4\n\n# Rotate metadata (without re-encoding)\nffmpeg -i input.mp4 -metadata:s:v rotate=90 -c copy output.mp4\n```\n\n### Stream Mapping\n\n```bash\n# Extract specific stream\nffmpeg -i input.mp4 -map 0:0 video_only.mp4  # First stream\nffmpeg -i input.mp4 -map 0:a audio_only.aac  # All audio streams\n\n# Combine specific streams from multiple files\nffmpeg -i video.mp4 -i audio.mp3 -i subs.srt \\\n  -map 0:v -map 1:a -map 2:s \\\n  -c:v copy -c:a copy -c:s mov_text \\\n  output.mp4\n\n# Exclude specific stream\nffmpeg -i input.mp4 -map 0 -map -0:s -c copy output.mp4  # Remove subtitles\n```\n\n### Thumbnail Generation\n\n```bash\n# Extract single frame\nffmpeg -i input.mp4 -ss 00:00:05 -frames:v 1 thumbnail.jpg\n\n# Extract multiple frames (every 10 seconds)\nffmpeg -i input.mp4 -vf \"select='not(mod(n\\,300))'\" -vsync 0 frames/frame_%04d.jpg\n\n# Generate thumbnails grid\nffmpeg -i input.mp4 -vf \"select='not(mod(n\\,300))',scale=320:240,tile=4x3\" grid.jpg\n```\n\n### Analysis and Probing\n\n```bash\n# Get video info (JSON)\nffprobe -v quiet -print_format json -show_format -show_streams input.mp4\n\n# Get duration\nffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4\n\n# Get resolution\nffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 input.mp4\n\n# Get frame rate\nffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 input.mp4\n\n# Detect black frames\nffmpeg -i input.mp4 -vf \"blackdetect=d=0.5:pix_th=0.10\" -f null -\n\n# Detect scene changes\nffmpeg -i input.mp4 -vf \"select='gt(scene,0.4)',showinfo\" -f null -\n\n# Find keyframes\nffprobe -select_streams v -show_frames -show_entries frame=pkt_pts_time,key_frame -of csv input.mp4 | grep \",1$\"\n```\n\n### Performance Tips\n\n```bash\n# Use fastest settings for drafts\nffmpeg -i input.mp4 -c:v libx264 -preset ultrafast -crf 28 draft.mp4\n\n# Multi-threaded encoding\nffmpeg -i input.mp4 -c:v libx264 -threads 8 -preset medium -crf 18 output.mp4\n\n# Limit memory usage\nffmpeg -i input.mp4 -c:v libx264 -bufsize 2M -maxrate 2M output.mp4\n\n# Stream copy when possible (no re-encoding)\nffmpeg -i input.mp4 -ss 10 -t 60 -c copy output.mp4\n```\n\n## Common Codecs\n\n### Video Codecs\n\n| Codec | Library | Quality | Speed | Use Case |\n|-------|---------|---------|-------|----------|\n| H.264 | libx264 | Excellent | Fast | General purpose, web |\n| H.265 | libx265 | Excellent | Slow | 4K, high compression |\n| VP9 | libvpx-vp9 | Excellent | Slow | Web, YouTube |\n| AV1 | libaom-av1 | Best | Very Slow | Future-proof, best compression |\n| ProRes | prores | Lossless | Fast | Editing, intermediate |\n| DNxHD | dnxhd | Lossless | Fast | Editing, intermediate |\n\n### Audio Codecs\n\n| Codec | Library | Quality | Bitrate | Use Case |\n|-------|---------|---------|---------|----------|\n| AAC | aac | Excellent | 128-256k | General purpose |\n| MP3 | libmp3lame | Good | 128-320k | Universal compatibility |\n| Opus | libopus | Excellent | 64-128k | Web, low bitrate |\n| FLAC | flac | Lossless | Variable | Archival |\n| PCM | pcm_s16le | Lossless | 1411k | Editing |\n\n## Pixel Formats\n\n```bash\n# yuv420p - Most compatible (8-bit, 4:2:0)\n-pix_fmt yuv420p\n\n# yuv420p10le - 10-bit HDR\n-pix_fmt yuv420p10le\n\n# yuv444p - Full chroma resolution (4:4:4)\n-pix_fmt yuv444p\n\n# rgb24 - RGB color space\n-pix_fmt rgb24\n```\n\n## Error Handling\n\n```bash\n# Continue on errors\nffmpeg -err_detect ignore_err -i input.mp4 output.mp4\n\n# Overwrite output files without asking\nffmpeg -y -i input.mp4 output.mp4\n\n# Never overwrite\nffmpeg -n -i input.mp4 output.mp4\n\n# Verbose output for debugging\nffmpeg -v verbose -i input.mp4 output.mp4\n\n# Hide banner\nffmpeg -hide_banner -i input.mp4 output.mp4\n```\n\n## Best Practices\n\n1. **Always use `-movflags +faststart`** for web videos (enables progressive download)\n2. **Use two-pass encoding for specific file sizes**\n3. **Prefer CRF over bitrate** for quality-based encoding\n4. **Use `-preset slow`** for final exports (better compression)\n5. **Use `-preset ultrafast`** for drafts (faster encoding)\n6. **Always specify `-pix_fmt yuv420p`** for broad compatibility\n7. **Set color metadata** when converting color spaces\n8. **Use stream copy (`-c copy`)** when possible to avoid re-encoding\n9. **Align cuts to keyframes** for stream copy operations\n10. **Normalize color spaces** before concatenating clips\n\n---\n\nThis guide covers 95% of common FFmpeg use cases. For more advanced operations, refer to the official FFmpeg documentation.\n"
        },
        {
          "name": "timeline-editing.md",
          "type": "file",
          "path": "video-processing-editing/references/timeline-editing.md",
          "size": 8697,
          "content": "# Timeline Editing Reference\n\nMulti-track timeline editing concepts and FFmpeg implementation.\n\n## Timeline Concepts\n\n### Video Track Structure\n\n```\nTimeline:\n├── Video Track 1 (Primary footage)\n├── Video Track 2 (Overlay/B-roll)\n├── Video Track 3 (Graphics/Text)\n├── Audio Track 1 (Dialogue)\n├── Audio Track 2 (Music)\n└── Audio Track 3 (Sound effects)\n```\n\n### In/Out Points\n\n```bash\n# Each clip has:\n# - IN point:  Where the clip starts on timeline\n# - OUT point: Where the clip ends on timeline\n# - SRC IN:    Where to start reading from source\n# - SRC OUT:   Where to stop reading from source\n\n# Example: Place 5s of source (from 10s-15s) at timeline position 30s\nffmpeg -i source.mp4 -ss 10 -t 5 -i bg.mp4 \\\n  -filter_complex \"[1:v][0:v]overlay=enable='between(t,30,35)'[out]\" \\\n  -map \"[out]\" output.mp4\n```\n\n## Multi-Track Video Composition\n\n### Layering Videos (Overlay)\n\n```bash\n# Layer video2 over video1 (picture-in-picture)\nffmpeg -i background.mp4 -i overlay.mp4 -filter_complex \\\n  \"[1:v]scale=320:240[pip]; \\\n   [0:v][pip]overlay=W-w-10:H-h-10:enable='between(t,5,15)'[out]\" \\\n  -map \"[out]\" -map 0:a \\\n  output.mp4\n\n# enable='between(t,5,15)': Only show overlay from 5s to 15s\n```\n\n### Split Screen\n\n```bash\n# Side-by-side (2 videos)\nffmpeg -i left.mp4 -i right.mp4 -filter_complex \\\n  \"[0:v]scale=960:1080[left]; \\\n   [1:v]scale=960:1080[right]; \\\n   [left][right]hstack[out]\" \\\n  -map \"[out]\" output.mp4\n\n# Top/bottom split\nffmpeg -i top.mp4 -i bottom.mp4 -filter_complex \\\n  \"[0:v]scale=1920:540[top]; \\\n   [1:v]scale=1920:540[bottom]; \\\n   [top][bottom]vstack[out]\" \\\n  -map \"[out]\" output.mp4\n\n# 2x2 Grid\nffmpeg -i v1.mp4 -i v2.mp4 -i v3.mp4 -i v4.mp4 -filter_complex \\\n  \"[0:v]scale=960:540[v1]; \\\n   [1:v]scale=960:540[v2]; \\\n   [2:v]scale=960:540[v3]; \\\n   [3:v]scale=960:540[v4]; \\\n   [v1][v2]hstack[top]; \\\n   [v3][v4]hstack[bottom]; \\\n   [top][bottom]vstack[out]\" \\\n  -map \"[out]\" output.mp4\n```\n\n### Insert Edit (Non-destructive)\n\n```bash\n# Insert clip B into clip A at specific point\n# A: 0-60s, insert B (10s) at A's 30s mark\n# Result: A[0-30], B[0-10], A[30-60]\n\n# Step 1: Split clip A\nffmpeg -i A.mp4 -t 30 -c copy A_part1.mp4\nffmpeg -i A.mp4 -ss 30 -c copy A_part2.mp4\n\n# Step 2: Concatenate with insert\necho \"file 'A_part1.mp4'\" > list.txt\necho \"file 'B.mp4'\" >> list.txt\necho \"file 'A_part2.mp4'\" >> list.txt\n\nffmpeg -f concat -safe 0 -i list.txt -c copy output.mp4\n```\n\n### Overwrite Edit\n\n```bash\n# Replace segment of clip A with clip B\n# A: 0-60s, overwrite 20-30s with B (10s)\n# Result: A[0-20], B[0-10], A[30-60]\n\nffmpeg -i A.mp4 -i B.mp4 -filter_complex \\\n  \"[0:v]trim=0:20,setpts=PTS-STARTPTS[v1]; \\\n   [1:v]trim=0:10,setpts=PTS-STARTPTS[v2]; \\\n   [0:v]trim=30:60,setpts=PTS-STARTPTS[v3]; \\\n   [v1][v2][v3]concat=n=3:v=1[out]\" \\\n  -map \"[out]\" output.mp4\n```\n\n## Multi-Track Audio\n\n### Audio Layering\n\n```bash\n# Mix multiple audio tracks with individual volume control\nffmpeg -i video.mp4 -i dialogue.wav -i music.mp3 -i sfx.wav \\\n  -filter_complex \\\n  \"[1:a]volume=1.0[dlg]; \\\n   [2:a]volume=0.3[mus]; \\\n   [3:a]volume=0.5[sfx]; \\\n   [dlg][mus][sfx]amix=inputs=3:duration=first[aout]\" \\\n  -map 0:v -map \"[aout]\" \\\n  -c:v copy -c:a aac -b:a 256k \\\n  output.mp4\n```\n\n### Audio with Timeline Positioning\n\n```bash\n# Position audio at specific timeline points\nffmpeg -i video.mp4 -i sfx1.wav -i sfx2.wav -filter_complex \\\n  \"[1:a]adelay=5000|5000[sfx1]; \\\n   [2:a]adelay=12000|12000[sfx2]; \\\n   [0:a][sfx1][sfx2]amix=inputs=3:duration=first[aout]\" \\\n  -map 0:v -map \"[aout]\" \\\n  output.mp4\n\n# adelay values are in milliseconds\n# adelay=5000|5000 = delay 5s on left and right channels\n```\n\n### Ducking (Lower music when dialogue plays)\n\n```bash\n# Automatic ducking using sidechaincompress\nffmpeg -i video.mp4 -i music.mp3 -filter_complex \\\n  \"[0:a]asplit[voice][duck_trigger]; \\\n   [1:a][duck_trigger]sidechaincompress=threshold=0.1:ratio=10:attack=100:release=1000[ducked_music]; \\\n   [voice][ducked_music]amix=inputs=2:duration=first[aout]\" \\\n  -map 0:v -map \"[aout]\" \\\n  output.mp4\n```\n\n## Keyframe Animation\n\n### Position Animation\n\n```bash\n# Move overlay from left to right over 5 seconds\nffmpeg -i bg.mp4 -i overlay.png -filter_complex \\\n  \"[1:v]scale=200:200[ovr]; \\\n   [0:v][ovr]overlay=x='min(t*100,W-200)':y=100[out]\" \\\n  -map \"[out]\" -t 10 output.mp4\n\n# x='min(t*100,W-200)': Move 100 pixels/second until reaching right edge\n```\n\n### Opacity Animation\n\n```bash\n# Fade overlay in/out\nffmpeg -i bg.mp4 -i overlay.png -filter_complex \\\n  \"[1:v]format=rgba,fade=in:st=0:d=1:alpha=1,fade=out:st=4:d=1:alpha=1[ovr]; \\\n   [0:v][ovr]overlay=10:10[out]\" \\\n  -map \"[out]\" output.mp4\n\n# Fade in from 0-1s, fade out from 4-5s\n```\n\n### Scale Animation (Zoom)\n\n```bash\n# Zoom effect (Ken Burns)\nffmpeg -i photo.jpg -filter_complex \\\n  \"zoompan=z='min(1.5,zoom+0.001)':d=300:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':s=1920x1080\" \\\n  -c:v libx264 -t 10 output.mp4\n\n# z='min(1.5,zoom+0.001)': Slowly zoom to 1.5x\n# d=300: 300 frames duration (10s at 30fps)\n```\n\n## Time Remapping\n\n### Speed Changes\n\n```bash\n# 2x speed (fast forward)\nffmpeg -i input.mp4 -filter:v \"setpts=0.5*PTS\" -filter:a \"atempo=2.0\" output.mp4\n\n# 0.5x speed (slow motion)\nffmpeg -i input.mp4 -filter:v \"setpts=2.0*PTS\" -filter:a \"atempo=0.5\" output.mp4\n\n# Variable speed (speed ramp)\n# Slow from 0-5s, normal 5-10s, fast 10-15s\nffmpeg -i input.mp4 -filter_complex \\\n  \"[0:v]trim=0:5,setpts=2*PTS[slow]; \\\n   [0:v]trim=5:10,setpts=PTS-STARTPTS[normal]; \\\n   [0:v]trim=10:15,setpts=0.5*PTS-STARTPTS[fast]; \\\n   [slow][normal][fast]concat=n=3:v=1[out]\" \\\n  -map \"[out]\" output.mp4\n```\n\n### Reverse\n\n```bash\n# Reverse video\nffmpeg -i input.mp4 -vf reverse output.mp4\n\n# Reverse segment\nffmpeg -i input.mp4 -filter_complex \\\n  \"[0:v]trim=5:10,setpts=PTS-STARTPTS,reverse[rev]; \\\n   [0:v]trim=0:5,setpts=PTS-STARTPTS[before]; \\\n   [0:v]trim=10:20,setpts=PTS-STARTPTS[after]; \\\n   [before][rev][after]concat=n=3:v=1[out]\" \\\n  -map \"[out]\" output.mp4\n```\n\n### Frame Hold (Freeze Frame)\n\n```bash\n# Freeze at 5 seconds for 3 seconds\nffmpeg -i input.mp4 -filter_complex \\\n  \"[0:v]trim=0:5[before]; \\\n   [0:v]trim=5:5.033,loop=90:1:0[freeze]; \\\n   [0:v]trim=5:,setpts=PTS-STARTPTS+3/TB[after]; \\\n   [before][freeze][after]concat=n=3:v=1[out]\" \\\n  -map \"[out]\" output.mp4\n\n# loop=90:1:0 = 90 frames loop (3s at 30fps)\n```\n\n## Markers and Sync Points\n\n### Scene Detection for Auto-Markers\n\n```bash\n# Detect scene changes (potential cut points)\nffmpeg -i input.mp4 -filter:v \"select='gt(scene,0.3)',showinfo\" -f null - 2>&1 | grep pts_time\n\n# Output timestamps where scene changes occur (threshold 0.3)\n```\n\n### Audio Sync with Clapboard\n\n```bash\n# Find audio spike (clap) for sync\nffmpeg -i input.mp4 -af \"silencedetect=n=-30dB:d=0.5\" -f null - 2>&1 | grep silence_end\n\n# This detects when silence ends (loud sound begins)\n```\n\n### Align Two Clips by Audio\n\n```bash\n# Step 1: Generate audio fingerprints\n# (Requires external tool like sync-audio-tracks or Praat)\n\n# Step 2: Apply calculated offset\nffmpeg -i video1.mp4 -itsoffset 0.250 -i video2.mp4 \\\n  -map 0:v -map 1:a \\\n  -c:v copy -c:a aac \\\n  synced_output.mp4\n```\n\n## Complex Timeline Example\n\n```bash\n# Full multi-track edit:\n# - Background video (0-60s)\n# - B-roll insert (at 10-20s)\n# - Lower third graphic (at 5-8s)\n# - Dialogue audio (continuous)\n# - Music bed (ducked, 30% volume)\n\nffmpeg \\\n  -i main.mp4 \\\n  -i broll.mp4 \\\n  -i lowerthird.png \\\n  -i music.mp3 \\\n  -filter_complex \\\n  \"\n  [0:v]trim=0:10,setpts=PTS-STARTPTS[main1];\n  [1:v]trim=0:10,setpts=PTS-STARTPTS[broll];\n  [0:v]trim=20:60,setpts=PTS-STARTPTS[main2];\n  [main1][broll][main2]concat=n=3:v=1[base];\n\n  [2:v]format=rgba,fade=in:st=0:d=0.5:alpha=1,fade=out:st=2.5:d=0.5:alpha=1[lt];\n  [base][lt]overlay=0:H-150:enable='between(t,5,8)'[video];\n\n  [0:a]volume=1.0[dialogue];\n  [3:a]volume=0.3[music];\n  [dialogue][music]amix=inputs=2:duration=first[audio]\n  \" \\\n  -map \"[video]\" -map \"[audio]\" \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a aac -b:a 192k \\\n  final_edit.mp4\n```\n\n## Best Practices\n\n1. **Plan your timeline on paper first** - Draw out tracks, timing, transitions\n2. **Use intermediate files for complex edits** - Don't try to do everything in one command\n3. **Match frame rates before combining** - Avoid judder from mismatched FPS\n4. **Keep audio and video sync** - Always test playback at multiple points\n5. **Use setpts=PTS-STARTPTS after trim** - Reset timestamps to avoid gaps\n6. **Label your filter chains** - Use descriptive names like `[dialogue]` not `[a1]`\n\n---\n\nThis reference covers timeline editing concepts. For transitions between clips, see the main SKILL.md. For export settings, see `export-optimization.md`.\n"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "folder",
      "path": "video-processing-editing/scripts",
      "children": [
        {
          "name": "batch_processor.py",
          "type": "file",
          "path": "video-processing-editing/scripts/batch_processor.py",
          "size": 16695,
          "content": "#!/usr/bin/env python3\n\"\"\"\nbatch_processor.py - Parallel batch video processing\n\nFeatures:\n- Process multiple videos in parallel\n- Platform-specific batch exports\n- Progress tracking and logging\n- Error handling and retries\n- Resource management (CPU/GPU)\n\nUsage:\n    python batch_processor.py export youtube videos/*.mp4 -o exports/\n    python batch_processor.py cut videos/*.mp4 --start 5 --end 60 -o trimmed/\n    python batch_processor.py resize videos/*.mp4 --width 1920 --height 1080 -o resized/\n\"\"\"\n\nimport argparse\nimport json\nimport multiprocessing\nimport os\nimport subprocess\nimport sys\nimport time\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional, Callable, Dict, Any\n\n\n@dataclass\nclass ProcessingJob:\n    \"\"\"Single video processing job\"\"\"\n    input_file: Path\n    output_file: Path\n    operation: str\n    params: Dict[str, Any]\n    status: str = 'pending'  # pending, running, completed, failed\n    error: Optional[str] = None\n    start_time: Optional[float] = None\n    end_time: Optional[float] = None\n\n\n@dataclass\nclass BatchStats:\n    \"\"\"Batch processing statistics\"\"\"\n    total: int = 0\n    completed: int = 0\n    failed: int = 0\n    skipped: int = 0\n    total_time: float = 0.0\n    avg_time: float = 0.0\n\n\nclass BatchProcessor:\n    \"\"\"Parallel batch video processor\"\"\"\n\n    def __init__(\n        self,\n        max_workers: Optional[int] = None,\n        gpu_acceleration: bool = True,\n        verbose: bool = False\n    ):\n        self.max_workers = max_workers or max(1, multiprocessing.cpu_count() - 1)\n        self.gpu_acceleration = gpu_acceleration\n        self.verbose = verbose\n        self.jobs: List[ProcessingJob] = []\n        self.stats = BatchStats()\n\n    def add_job(self, job: ProcessingJob):\n        \"\"\"Add processing job to queue\"\"\"\n        self.jobs.append(job)\n        self.stats.total += 1\n\n    def process_all(self, skip_existing: bool = True) -> BatchStats:\n        \"\"\"Process all jobs in parallel\"\"\"\n        print(f\"Processing {len(self.jobs)} videos with {self.max_workers} workers...\")\n\n        start_time = time.time()\n\n        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:\n            futures = {}\n\n            for job in self.jobs:\n                if skip_existing and job.output_file.exists():\n                    job.status = 'skipped'\n                    self.stats.skipped += 1\n                    if self.verbose:\n                        print(f\"Skipping existing: {job.output_file}\")\n                    continue\n\n                future = executor.submit(self._process_job, job)\n                futures[future] = job\n\n            for future in as_completed(futures):\n                job = futures[future]\n                try:\n                    result = future.result()\n                    if result.status == 'completed':\n                        self.stats.completed += 1\n                    else:\n                        self.stats.failed += 1\n\n                    self._print_progress()\n\n                except Exception as e:\n                    job.status = 'failed'\n                    job.error = str(e)\n                    self.stats.failed += 1\n                    print(f\"Error processing {job.input_file}: {e}\")\n\n        self.stats.total_time = time.time() - start_time\n        self.stats.avg_time = self.stats.total_time / max(1, self.stats.completed)\n\n        self._print_summary()\n\n        return self.stats\n\n    def _process_job(self, job: ProcessingJob) -> ProcessingJob:\n        \"\"\"Process single video job\"\"\"\n        job.status = 'running'\n        job.start_time = time.time()\n\n        try:\n            if job.operation == 'export':\n                self._export_video(job)\n            elif job.operation == 'cut':\n                self._cut_video(job)\n            elif job.operation == 'resize':\n                self._resize_video(job)\n            elif job.operation == 'convert':\n                self._convert_video(job)\n            elif job.operation == 'audio_extract':\n                self._extract_audio(job)\n            else:\n                raise ValueError(f\"Unknown operation: {job.operation}\")\n\n            job.status = 'completed'\n\n        except Exception as e:\n            job.status = 'failed'\n            job.error = str(e)\n\n        finally:\n            job.end_time = time.time()\n\n        return job\n\n    def _export_video(self, job: ProcessingJob):\n        \"\"\"Export video for platform\"\"\"\n        platform = job.params['platform']\n        quality = job.params.get('quality', 'high')\n\n        presets = {\n            'youtube': {\n                'resolution': '1920x1080',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 18},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'slow'},\n                'audio_bitrate': '192k'\n            },\n            'instagram_story': {\n                'resolution': '1080x1920',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'max_duration': 15\n            },\n            'instagram_reel': {\n                'resolution': '1080x1920',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'max_duration': 90\n            },\n            'twitter': {\n                'resolution': '1280x720',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'maxrate': '5000k',\n                'bufsize': '10000k'\n            },\n            'tiktok': {\n                'resolution': '1080x1920',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k'\n            }\n        }\n\n        config = presets[platform]\n\n        cmd = [\n            'ffmpeg', '-y',\n            '-i', str(job.input_file),\n            '-c:v', 'libx264',\n            '-preset', config['preset'][quality],\n            '-crf', str(config['crf'][quality]),\n            '-s', config['resolution'],\n            '-r', str(config['fps']),\n            '-pix_fmt', 'yuv420p',\n            '-color_primaries', 'bt709',\n            '-color_trc', 'bt709',\n            '-colorspace', 'bt709',\n            '-movflags', '+faststart',\n            '-c:a', 'aac',\n            '-b:a', config['audio_bitrate'],\n            '-ar', '48000'\n        ]\n\n        if 'maxrate' in config:\n            cmd += ['-maxrate', config['maxrate'], '-bufsize', config['bufsize']]\n\n        if 'max_duration' in config:\n            cmd += ['-t', str(config['max_duration'])]\n\n        cmd.append(str(job.output_file))\n\n        self._run_ffmpeg(cmd)\n\n    def _cut_video(self, job: ProcessingJob):\n        \"\"\"Cut/trim video\"\"\"\n        start = job.params['start']\n        end = job.params.get('end')\n\n        cmd = [\n            'ffmpeg', '-y',\n            '-ss', str(max(0, start - 2)),\n            '-i', str(job.input_file),\n            '-ss', '2'\n        ]\n\n        if end:\n            duration = end - start\n            cmd += ['-t', str(duration)]\n\n        cmd += [\n            '-c:v', 'libx264',\n            '-crf', '18',\n            '-preset', 'medium',\n            '-c:a', 'aac',\n            '-b:a', '192k',\n            str(job.output_file)\n        ]\n\n        self._run_ffmpeg(cmd)\n\n    def _resize_video(self, job: ProcessingJob):\n        \"\"\"Resize video\"\"\"\n        width = job.params.get('width')\n        height = job.params.get('height')\n\n        if width and height:\n            scale = f\"{width}:{height}\"\n        elif width:\n            scale = f\"{width}:-2\"\n        elif height:\n            scale = f\"-2:{height}\"\n        else:\n            raise ValueError(\"Must specify width and/or height\")\n\n        cmd = [\n            'ffmpeg', '-y',\n            '-i', str(job.input_file),\n            '-vf', f\"scale={scale}\",\n            '-c:v', 'libx264',\n            '-crf', '18',\n            '-preset', 'medium',\n            '-c:a', 'copy',\n            str(job.output_file)\n        ]\n\n        self._run_ffmpeg(cmd)\n\n    def _convert_video(self, job: ProcessingJob):\n        \"\"\"Convert video format\"\"\"\n        codec = job.params.get('codec', 'libx264')\n        quality = job.params.get('quality', 18)\n\n        cmd = [\n            'ffmpeg', '-y',\n            '-i', str(job.input_file),\n            '-c:v', codec,\n            '-crf', str(quality),\n            '-preset', 'medium',\n            '-c:a', 'aac',\n            '-b:a', '192k',\n            str(job.output_file)\n        ]\n\n        self._run_ffmpeg(cmd)\n\n    def _extract_audio(self, job: ProcessingJob):\n        \"\"\"Extract audio from video\"\"\"\n        audio_format = job.params.get('format', 'mp3')\n        bitrate = job.params.get('bitrate', '192k')\n\n        cmd = [\n            'ffmpeg', '-y',\n            '-i', str(job.input_file),\n            '-vn',  # No video\n            '-c:a', 'libmp3lame' if audio_format == 'mp3' else 'aac',\n            '-b:a', bitrate,\n            str(job.output_file)\n        ]\n\n        self._run_ffmpeg(cmd)\n\n    def _run_ffmpeg(self, cmd: List[str]):\n        \"\"\"Run FFmpeg command with error handling\"\"\"\n        if self.verbose:\n            print(f\"Running: {' '.join(cmd)}\")\n\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            check=False\n        )\n\n        if result.returncode != 0:\n            raise RuntimeError(f\"FFmpeg failed: {result.stderr}\")\n\n    def _print_progress(self):\n        \"\"\"Print current progress\"\"\"\n        processed = self.stats.completed + self.stats.failed\n        total = self.stats.total - self.stats.skipped\n\n        if total > 0:\n            percent = (processed / total) * 100\n            print(f\"Progress: {processed}/{total} ({percent:.1f}%) - \"\n                  f\"Completed: {self.stats.completed}, Failed: {self.stats.failed}\")\n\n    def _print_summary(self):\n        \"\"\"Print final summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"BATCH PROCESSING COMPLETE\")\n        print(\"=\"*60)\n        print(f\"Total jobs:      {self.stats.total}\")\n        print(f\"Completed:       {self.stats.completed}\")\n        print(f\"Failed:          {self.stats.failed}\")\n        print(f\"Skipped:         {self.stats.skipped}\")\n        print(f\"Total time:      {self.stats.total_time:.1f}s\")\n        print(f\"Avg time/video:  {self.stats.avg_time:.1f}s\")\n        print(\"=\"*60)\n\n        if self.stats.failed > 0:\n            print(\"\\nFailed jobs:\")\n            for job in self.jobs:\n                if job.status == 'failed':\n                    print(f\"  - {job.input_file}: {job.error}\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Batch video processor')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')\n    parser.add_argument('-w', '--workers', type=int, help='Max parallel workers')\n    parser.add_argument('--no-gpu', action='store_true', help='Disable GPU acceleration')\n    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing files')\n\n    subparsers = parser.add_subparsers(dest='command', required=True)\n\n    # Export command\n    export_parser = subparsers.add_parser('export', help='Batch export for platform')\n    export_parser.add_argument('platform', choices=[\n        'youtube', 'instagram_story', 'instagram_reel', 'twitter', 'tiktok'\n    ])\n    export_parser.add_argument('inputs', nargs='+', help='Input video files (or glob pattern)')\n    export_parser.add_argument('-o', '--output-dir', required=True, help='Output directory')\n    export_parser.add_argument('-q', '--quality', choices=['draft', 'medium', 'high'],\n                                default='high', help='Export quality')\n\n    # Cut command\n    cut_parser = subparsers.add_parser('cut', help='Batch cut/trim')\n    cut_parser.add_argument('inputs', nargs='+', help='Input video files')\n    cut_parser.add_argument('-s', '--start', type=float, required=True, help='Start time (seconds)')\n    cut_parser.add_argument('-e', '--end', type=float, help='End time (seconds)')\n    cut_parser.add_argument('-o', '--output-dir', required=True, help='Output directory')\n\n    # Resize command\n    resize_parser = subparsers.add_parser('resize', help='Batch resize')\n    resize_parser.add_argument('inputs', nargs='+', help='Input video files')\n    resize_parser.add_argument('--width', type=int, help='Target width')\n    resize_parser.add_argument('--height', type=int, help='Target height')\n    resize_parser.add_argument('-o', '--output-dir', required=True, help='Output directory')\n\n    # Convert command\n    convert_parser = subparsers.add_parser('convert', help='Batch format conversion')\n    convert_parser.add_argument('inputs', nargs='+', help='Input video files')\n    convert_parser.add_argument('-f', '--format', default='mp4', help='Output format')\n    convert_parser.add_argument('-c', '--codec', default='libx264', help='Video codec')\n    convert_parser.add_argument('-q', '--quality', type=int, default=18, help='CRF quality')\n    convert_parser.add_argument('-o', '--output-dir', required=True, help='Output directory')\n\n    # Extract audio command\n    audio_parser = subparsers.add_parser('audio', help='Batch audio extraction')\n    audio_parser.add_argument('inputs', nargs='+', help='Input video files')\n    audio_parser.add_argument('-f', '--format', default='mp3', choices=['mp3', 'aac', 'wav'])\n    audio_parser.add_argument('-b', '--bitrate', default='192k', help='Audio bitrate')\n    audio_parser.add_argument('-o', '--output-dir', required=True, help='Output directory')\n\n    args = parser.parse_args()\n\n    # Expand glob patterns\n    input_files = []\n    for pattern in args.inputs:\n        input_files.extend(Path('.').glob(pattern))\n\n    if not input_files:\n        print(\"No input files found\", file=sys.stderr)\n        sys.exit(1)\n\n    # Create output directory\n    output_dir = Path(args.output_dir)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    # Create processor\n    processor = BatchProcessor(\n        max_workers=args.workers,\n        gpu_acceleration=not args.no_gpu,\n        verbose=args.verbose\n    )\n\n    # Create jobs\n    for input_file in input_files:\n        input_path = Path(input_file)\n\n        if args.command == 'export':\n            output_file = output_dir / f\"{input_path.stem}_{args.platform}.mp4\"\n            job = ProcessingJob(\n                input_file=input_path,\n                output_file=output_file,\n                operation='export',\n                params={'platform': args.platform, 'quality': args.quality}\n            )\n\n        elif args.command == 'cut':\n            output_file = output_dir / f\"{input_path.stem}_cut.mp4\"\n            job = ProcessingJob(\n                input_file=input_path,\n                output_file=output_file,\n                operation='cut',\n                params={'start': args.start, 'end': args.end}\n            )\n\n        elif args.command == 'resize':\n            output_file = output_dir / f\"{input_path.stem}_resized.mp4\"\n            job = ProcessingJob(\n                input_file=input_path,\n                output_file=output_file,\n                operation='resize',\n                params={'width': args.width, 'height': args.height}\n            )\n\n        elif args.command == 'convert':\n            output_file = output_dir / f\"{input_path.stem}.{args.format}\"\n            job = ProcessingJob(\n                input_file=input_path,\n                output_file=output_file,\n                operation='convert',\n                params={'codec': args.codec, 'quality': args.quality}\n            )\n\n        elif args.command == 'audio':\n            output_file = output_dir / f\"{input_path.stem}.{args.format}\"\n            job = ProcessingJob(\n                input_file=input_path,\n                output_file=output_file,\n                operation='audio_extract',\n                params={'format': args.format, 'bitrate': args.bitrate}\n            )\n\n        processor.add_job(job)\n\n    # Process all jobs\n    stats = processor.process_all(skip_existing=not args.overwrite)\n\n    # Exit with error if any jobs failed\n    if stats.failed > 0:\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "video_editor.py",
          "type": "file",
          "path": "video-processing-editing/scripts/video_editor.py",
          "size": 22890,
          "content": "#!/usr/bin/env python3\n\"\"\"\nvideo_editor.py - Professional video editing with FFmpeg\n\nFeatures:\n- Cut, trim, concatenate clips\n- Transitions (fade, dissolve, wipe)\n- Audio mixing and normalization\n- Color grading\n- Subtitle handling\n- Platform-specific exports\n\nUsage:\n    python video_editor.py cut input.mp4 --start 10 --end 60 -o output.mp4\n    python video_editor.py concat clip1.mp4 clip2.mp4 clip3.mp4 -o final.mp4\n    python video_editor.py transition fade clip1.mp4 clip2.mp4 -o output.mp4\n    python video_editor.py export youtube input.mp4 -o youtube.mp4\n\"\"\"\n\nimport argparse\nimport json\nimport os\nimport subprocess\nimport sys\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional, Tuple\n\n\n@dataclass\nclass VideoInfo:\n    \"\"\"Video metadata from ffprobe\"\"\"\n    duration: float\n    width: int\n    height: int\n    fps: float\n    codec: str\n    bitrate: int\n    color_space: str\n    color_primaries: str\n    color_transfer: str\n    pix_fmt: str\n\n\nclass VideoEditor:\n    \"\"\"Professional video editor using FFmpeg\"\"\"\n\n    def __init__(self, verbose: bool = False):\n        self.verbose = verbose\n\n    def run_ffmpeg(self, args: List[str], check: bool = True) -> subprocess.CompletedProcess:\n        \"\"\"Run ffmpeg command with error handling\"\"\"\n        cmd = ['ffmpeg', '-y'] + args\n        if self.verbose:\n            print(f\"Running: {' '.join(cmd)}\")\n\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            check=False\n        )\n\n        if check and result.returncode != 0:\n            print(f\"FFmpeg error: {result.stderr}\", file=sys.stderr)\n            sys.exit(1)\n\n        return result\n\n    def run_ffprobe(self, input_file: str) -> dict:\n        \"\"\"Get video metadata using ffprobe\"\"\"\n        cmd = [\n            'ffprobe',\n            '-v', 'quiet',\n            '-print_format', 'json',\n            '-show_format',\n            '-show_streams',\n            input_file\n        ]\n\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        return json.loads(result.stdout)\n\n    def get_video_info(self, input_file: str) -> VideoInfo:\n        \"\"\"Extract video metadata\"\"\"\n        probe = self.run_ffprobe(input_file)\n\n        video_stream = next(\n            (s for s in probe['streams'] if s['codec_type'] == 'video'),\n            None\n        )\n\n        if not video_stream:\n            raise ValueError(f\"No video stream found in {input_file}\")\n\n        return VideoInfo(\n            duration=float(probe['format']['duration']),\n            width=video_stream['width'],\n            height=video_stream['height'],\n            fps=eval(video_stream['r_frame_rate']),\n            codec=video_stream['codec_name'],\n            bitrate=int(probe['format'].get('bit_rate', 0)),\n            color_space=video_stream.get('color_space', 'unknown'),\n            color_primaries=video_stream.get('color_primaries', 'unknown'),\n            color_transfer=video_stream.get('color_transfer', 'unknown'),\n            pix_fmt=video_stream.get('pix_fmt', 'yuv420p')\n        )\n\n    def find_keyframes(self, input_file: str) -> List[float]:\n        \"\"\"Find all keyframe timestamps\"\"\"\n        cmd = [\n            'ffprobe',\n            '-v', 'error',\n            '-select_streams', 'v',\n            '-show_frames',\n            '-show_entries', 'frame=pkt_pts_time,key_frame',\n            '-of', 'csv',\n            input_file\n        ]\n\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n\n        keyframes = []\n        for line in result.stdout.strip().split('\\n'):\n            if line.endswith(',1'):\n                timestamp = float(line.split(',')[1])\n                keyframes.append(timestamp)\n\n        return keyframes\n\n    def find_nearest_keyframe(self, input_file: str, timestamp: float) -> float:\n        \"\"\"Find nearest keyframe to given timestamp\"\"\"\n        keyframes = self.find_keyframes(input_file)\n\n        if not keyframes:\n            return timestamp\n\n        return min(keyframes, key=lambda k: abs(k - timestamp))\n\n    def cut(\n        self,\n        input_file: str,\n        output_file: str,\n        start: float,\n        end: Optional[float] = None,\n        precise: bool = True,\n        reencode: bool = False\n    ):\n        \"\"\"\n        Cut/trim video clip\n\n        Args:\n            input_file: Input video path\n            output_file: Output video path\n            start: Start time in seconds\n            end: End time in seconds (None = to end of file)\n            precise: Use frame-accurate cutting (slower)\n            reencode: Force re-encoding (highest quality)\n        \"\"\"\n        info = self.get_video_info(input_file)\n\n        if end and end > info.duration:\n            end = info.duration\n\n        duration = (end - start) if end else None\n\n        if reencode or precise:\n            # Two-pass cutting: fast seek + precise cut\n            args = [\n                '-ss', str(max(0, start - 2)),  # Seek 2s before for safety\n                '-i', input_file,\n                '-ss', '2',  # Precise offset after input\n            ]\n\n            if duration:\n                args += ['-t', str(duration)]\n\n            args += [\n                '-c:v', 'libx264',\n                '-crf', '18',\n                '-preset', 'medium',\n                '-c:a', 'aac',\n                '-b:a', '192k',\n                output_file\n            ]\n        else:\n            # Fast keyframe-aligned cutting\n            start_kf = self.find_nearest_keyframe(input_file, start)\n\n            args = ['-i', input_file, '-ss', str(start_kf)]\n\n            if end:\n                end_kf = self.find_nearest_keyframe(input_file, end)\n                args += ['-to', str(end_kf)]\n\n            args += ['-c', 'copy', output_file]\n\n        self.run_ffmpeg(args)\n        print(f\"Cut complete: {output_file}\")\n\n    def concat(\n        self,\n        input_files: List[str],\n        output_file: str,\n        normalize_color: bool = True,\n        transitions: Optional[str] = None\n    ):\n        \"\"\"\n        Concatenate multiple video clips\n\n        Args:\n            input_files: List of input video paths\n            output_file: Output video path\n            normalize_color: Normalize color spaces before concat\n            transitions: Transition type ('fade', 'dissolve', 'wipe')\n        \"\"\"\n        if len(input_files) < 2:\n            raise ValueError(\"Need at least 2 input files to concatenate\")\n\n        if normalize_color:\n            # Normalize all clips to BT.709\n            normalized_files = []\n\n            for i, input_file in enumerate(input_files):\n                info = self.get_video_info(input_file)\n                normalized = f\"temp_normalized_{i}.mp4\"\n\n                if info.color_space == 'bt709':\n                    # Already normalized\n                    normalized_files.append(input_file)\n                else:\n                    # Convert to BT.709\n                    args = [\n                        '-i', input_file,\n                        '-vf', 'scale=in_range=full:out_range=limited,colorspace=bt709:iall=bt601:fast=1',\n                        '-color_primaries', 'bt709',\n                        '-color_trc', 'bt709',\n                        '-colorspace', 'bt709',\n                        '-c:v', 'libx264',\n                        '-crf', '18',\n                        '-preset', 'medium',\n                        '-c:a', 'copy',\n                        normalized\n                    ]\n\n                    self.run_ffmpeg(args)\n                    normalized_files.append(normalized)\n\n            input_files = normalized_files\n\n        if transitions:\n            # Concatenate with transitions\n            self._concat_with_transitions(input_files, output_file, transitions)\n        else:\n            # Simple concatenation using concat demuxer\n            concat_list = Path('concat_list.txt')\n\n            with concat_list.open('w') as f:\n                for input_file in input_files:\n                    f.write(f\"file '{Path(input_file).absolute()}'\\n\")\n\n            args = [\n                '-f', 'concat',\n                '-safe', '0',\n                '-i', str(concat_list),\n                '-c', 'copy',\n                output_file\n            ]\n\n            self.run_ffmpeg(args)\n            concat_list.unlink()\n\n        # Cleanup normalized files\n        if normalize_color:\n            for f in input_files:\n                if f.startswith('temp_normalized_'):\n                    Path(f).unlink()\n\n        print(f\"Concatenation complete: {output_file}\")\n\n    def _concat_with_transitions(\n        self,\n        input_files: List[str],\n        output_file: str,\n        transition: str,\n        duration: float = 1.0\n    ):\n        \"\"\"Concatenate with crossfade transitions\"\"\"\n        # Build filter_complex for xfade transitions\n        filter_parts = []\n\n        for i in range(len(input_files) - 1):\n            if i == 0:\n                filter_parts.append(f\"[0:v][1:v]xfade=transition={transition}:duration={duration}:offset=5[v01];\")\n            else:\n                filter_parts.append(f\"[v0{i}][{i+1}:v]xfade=transition={transition}:duration={duration}:offset=5[v0{i+1}];\")\n\n        filter_complex = ''.join(filter_parts)\n\n        args = []\n        for input_file in input_files:\n            args += ['-i', input_file]\n\n        args += [\n            '-filter_complex', filter_complex,\n            '-map', f\"[v0{len(input_files)-1}]\",\n            '-c:v', 'libx264',\n            '-crf', '18',\n            '-preset', 'medium',\n            output_file\n        ]\n\n        self.run_ffmpeg(args)\n\n    def add_audio(\n        self,\n        video_file: str,\n        audio_file: str,\n        output_file: str,\n        mix: bool = False,\n        volume: float = 1.0,\n        sync_offset: float = 0.0\n    ):\n        \"\"\"\n        Add or replace audio track\n\n        Args:\n            video_file: Input video path\n            audio_file: Input audio path\n            output_file: Output video path\n            mix: Mix with original audio (vs replace)\n            volume: Audio volume multiplier\n            sync_offset: Audio delay in seconds (positive = delay, negative = advance)\n        \"\"\"\n        if mix:\n            # Mix original and new audio\n            args = [\n                '-i', video_file,\n                '-itsoffset', str(sync_offset),\n                '-i', audio_file,\n                '-filter_complex', f'[0:a][1:a]amix=inputs=2:duration=first[a]',\n                '-map', '0:v',\n                '-map', '[a]',\n                '-c:v', 'copy',\n                '-c:a', 'aac',\n                '-b:a', '192k',\n                output_file\n            ]\n        else:\n            # Replace audio\n            args = [\n                '-i', video_file,\n                '-itsoffset', str(sync_offset),\n                '-i', audio_file,\n                '-map', '0:v',\n                '-map', '1:a',\n                '-c:v', 'copy',\n                '-c:a', 'aac',\n                '-b:a', '192k',\n                '-shortest',\n                output_file\n            ]\n\n        self.run_ffmpeg(args)\n        print(f\"Audio added: {output_file}\")\n\n    def add_subtitles(\n        self,\n        input_file: str,\n        subtitle_file: str,\n        output_file: str,\n        burn: bool = True\n    ):\n        \"\"\"\n        Add subtitles to video\n\n        Args:\n            input_file: Input video path\n            subtitle_file: Subtitle file (.srt, .ass)\n            output_file: Output video path\n            burn: Burn subtitles into video (vs soft subs)\n        \"\"\"\n        if burn:\n            # Burn subtitles into video\n            args = [\n                '-i', input_file,\n                '-vf', f\"subtitles={subtitle_file}\",\n                '-c:v', 'libx264',\n                '-crf', '18',\n                '-preset', 'medium',\n                '-c:a', 'copy',\n                output_file\n            ]\n        else:\n            # Add soft subtitles\n            args = [\n                '-i', input_file,\n                '-i', subtitle_file,\n                '-c:v', 'copy',\n                '-c:a', 'copy',\n                '-c:s', 'mov_text',\n                '-metadata:s:s:0', 'language=eng',\n                output_file\n            ]\n\n        self.run_ffmpeg(args)\n        print(f\"Subtitles added: {output_file}\")\n\n    def color_grade(\n        self,\n        input_file: str,\n        output_file: str,\n        brightness: float = 0.0,\n        contrast: float = 1.0,\n        saturation: float = 1.0,\n        gamma: float = 1.0\n    ):\n        \"\"\"\n        Apply color grading\n\n        Args:\n            input_file: Input video path\n            output_file: Output video path\n            brightness: Brightness adjustment (-1.0 to 1.0)\n            contrast: Contrast multiplier (0.0 to 2.0)\n            saturation: Saturation multiplier (0.0 to 3.0)\n            gamma: Gamma correction (0.1 to 10.0)\n        \"\"\"\n        filters = []\n\n        if brightness != 0.0 or contrast != 1.0:\n            filters.append(f\"eq=brightness={brightness}:contrast={contrast}\")\n\n        if saturation != 1.0:\n            filters.append(f\"eq=saturation={saturation}\")\n\n        if gamma != 1.0:\n            filters.append(f\"eq=gamma={gamma}\")\n\n        vf = ','.join(filters) if filters else 'null'\n\n        args = [\n            '-i', input_file,\n            '-vf', vf,\n            '-c:v', 'libx264',\n            '-crf', '18',\n            '-preset', 'medium',\n            '-c:a', 'copy',\n            output_file\n        ]\n\n        self.run_ffmpeg(args)\n        print(f\"Color grading complete: {output_file}\")\n\n    def export_for_platform(\n        self,\n        input_file: str,\n        output_file: str,\n        platform: str,\n        quality: str = 'high'\n    ):\n        \"\"\"\n        Export optimized for specific platform\n\n        Platforms: youtube, instagram_story, instagram_reel, instagram_feed,\n                   twitter, tiktok, linkedin, web\n        Quality: draft, medium, high\n        \"\"\"\n        presets = {\n            'youtube': {\n                'resolution': '1920x1080',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 18},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'slow'},\n                'audio_bitrate': '192k'\n            },\n            'instagram_story': {\n                'resolution': '1080x1920',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'max_duration': 15\n            },\n            'instagram_reel': {\n                'resolution': '1080x1920',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'max_duration': 90\n            },\n            'instagram_feed': {\n                'resolution': '1080x1080',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k'\n            },\n            'twitter': {\n                'resolution': '1280x720',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'maxrate': '5000k',\n                'bufsize': '10000k'\n            },\n            'tiktok': {\n                'resolution': '1080x1920',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k'\n            },\n            'web': {\n                'resolution': '1920x1080',\n                'fps': 30,\n                'crf': {'draft': 28, 'medium': 23, 'high': 20},\n                'preset': {'draft': 'ultrafast', 'medium': 'medium', 'high': 'medium'},\n                'audio_bitrate': '128k',\n                'profile': 'baseline',\n                'level': '3.0'\n            }\n        }\n\n        if platform not in presets:\n            raise ValueError(f\"Unknown platform: {platform}\")\n\n        config = presets[platform]\n\n        args = [\n            '-i', input_file,\n            '-c:v', 'libx264',\n            '-preset', config['preset'][quality],\n            '-crf', str(config['crf'][quality]),\n            '-s', config['resolution'],\n            '-r', str(config['fps']),\n            '-pix_fmt', 'yuv420p',\n            '-color_primaries', 'bt709',\n            '-color_trc', 'bt709',\n            '-colorspace', 'bt709',\n            '-movflags', '+faststart',\n            '-c:a', 'aac',\n            '-b:a', config['audio_bitrate'],\n            '-ar', '48000'\n        ]\n\n        if 'maxrate' in config:\n            args += ['-maxrate', config['maxrate'], '-bufsize', config['bufsize']]\n\n        if 'profile' in config:\n            args += ['-profile:v', config['profile']]\n\n        if 'level' in config:\n            args += ['-level', config['level']]\n\n        if 'max_duration' in config:\n            args += ['-t', str(config['max_duration'])]\n\n        args.append(output_file)\n\n        self.run_ffmpeg(args)\n        print(f\"Export complete for {platform}: {output_file}\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Professional video editor')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')\n\n    subparsers = parser.add_subparsers(dest='command', required=True)\n\n    # Cut command\n    cut_parser = subparsers.add_parser('cut', help='Cut/trim video')\n    cut_parser.add_argument('input', help='Input video file')\n    cut_parser.add_argument('-s', '--start', type=float, required=True, help='Start time (seconds)')\n    cut_parser.add_argument('-e', '--end', type=float, help='End time (seconds)')\n    cut_parser.add_argument('-o', '--output', required=True, help='Output file')\n    cut_parser.add_argument('--precise', action='store_true', help='Frame-accurate cutting')\n    cut_parser.add_argument('--reencode', action='store_true', help='Force re-encoding')\n\n    # Concat command\n    concat_parser = subparsers.add_parser('concat', help='Concatenate videos')\n    concat_parser.add_argument('inputs', nargs='+', help='Input video files')\n    concat_parser.add_argument('-o', '--output', required=True, help='Output file')\n    concat_parser.add_argument('--no-normalize', action='store_true', help='Skip color normalization')\n    concat_parser.add_argument('-t', '--transition', choices=['fade', 'dissolve', 'wipe'], help='Transition type')\n\n    # Audio command\n    audio_parser = subparsers.add_parser('audio', help='Add/replace audio')\n    audio_parser.add_argument('video', help='Input video file')\n    audio_parser.add_argument('audio', help='Input audio file')\n    audio_parser.add_argument('-o', '--output', required=True, help='Output file')\n    audio_parser.add_argument('--mix', action='store_true', help='Mix with original audio')\n    audio_parser.add_argument('--volume', type=float, default=1.0, help='Volume multiplier')\n    audio_parser.add_argument('--offset', type=float, default=0.0, help='Sync offset (seconds)')\n\n    # Subtitles command\n    subs_parser = subparsers.add_parser('subtitles', help='Add subtitles')\n    subs_parser.add_argument('video', help='Input video file')\n    subs_parser.add_argument('subtitles', help='Subtitle file (.srt, .ass)')\n    subs_parser.add_argument('-o', '--output', required=True, help='Output file')\n    subs_parser.add_argument('--soft', action='store_true', help='Soft subtitles (not burned)')\n\n    # Color grade command\n    grade_parser = subparsers.add_parser('grade', help='Color grading')\n    grade_parser.add_argument('input', help='Input video file')\n    grade_parser.add_argument('-o', '--output', required=True, help='Output file')\n    grade_parser.add_argument('--brightness', type=float, default=0.0, help='Brightness (-1 to 1)')\n    grade_parser.add_argument('--contrast', type=float, default=1.0, help='Contrast (0 to 2)')\n    grade_parser.add_argument('--saturation', type=float, default=1.0, help='Saturation (0 to 3)')\n    grade_parser.add_argument('--gamma', type=float, default=1.0, help='Gamma (0.1 to 10)')\n\n    # Export command\n    export_parser = subparsers.add_parser('export', help='Export for platform')\n    export_parser.add_argument('platform', choices=[\n        'youtube', 'instagram_story', 'instagram_reel', 'instagram_feed',\n        'twitter', 'tiktok', 'linkedin', 'web'\n    ], help='Target platform')\n    export_parser.add_argument('input', help='Input video file')\n    export_parser.add_argument('-o', '--output', required=True, help='Output file')\n    export_parser.add_argument('-q', '--quality', choices=['draft', 'medium', 'high'],\n                                default='high', help='Export quality')\n\n    args = parser.parse_args()\n\n    editor = VideoEditor(verbose=args.verbose)\n\n    try:\n        if args.command == 'cut':\n            editor.cut(\n                args.input,\n                args.output,\n                args.start,\n                args.end,\n                precise=args.precise,\n                reencode=args.reencode\n            )\n\n        elif args.command == 'concat':\n            editor.concat(\n                args.inputs,\n                args.output,\n                normalize_color=not args.no_normalize,\n                transitions=args.transition\n            )\n\n        elif args.command == 'audio':\n            editor.add_audio(\n                args.video,\n                args.audio,\n                args.output,\n                mix=args.mix,\n                volume=args.volume,\n                sync_offset=args.offset\n            )\n\n        elif args.command == 'subtitles':\n            editor.add_subtitles(\n                args.video,\n                args.subtitles,\n                args.output,\n                burn=not args.soft\n            )\n\n        elif args.command == 'grade':\n            editor.color_grade(\n                args.input,\n                args.output,\n                brightness=args.brightness,\n                contrast=args.contrast,\n                saturation=args.saturation,\n                gamma=args.gamma\n            )\n\n        elif args.command == 'export':\n            editor.export_for_platform(\n                args.input,\n                args.output,\n                args.platform,\n                quality=args.quality\n            )\n\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "video-processing-editing/SKILL.md",
      "size": 16642,
      "content": "---\nname: video-processing-editing\ndescription: FFmpeg automation for cutting, trimming, concatenating videos. Audio mixing, timeline editing, transitions, effects. Export optimization for YouTube, social media. Subtitle handling, color grading, batch processing. Use for videogen projects, content creation, automated video production. Activate on \"video editing\", \"FFmpeg\", \"trim video\", \"concatenate\", \"transitions\", \"export optimization\". NOT for real-time video editing UI, 3D compositing, or motion graphics.\nallowed-tools: Read,Write,Edit,Bash(ffmpeg*,ffprobe*,python*)\n---\n\n# Video Processing & Editing\n\nExpert in FFmpeg-based video editing, processing automation, and export optimization for modern content creation workflows.\n\n## When to Use\n\n✅ **Use for**:\n- Automated video editing pipelines (script-to-video)\n- Cutting, trimming, concatenating clips\n- Adding transitions, effects, overlays\n- Audio mixing and normalization\n- Subtitle/caption handling\n- Export optimization for platforms\n- Batch video processing\n- Color grading and correction\n\n❌ **NOT for**:\n- Real-time video editing UI (use DaVinci Resolve/Premiere)\n- 3D compositing (use After Effects/Blender)\n- Motion graphics animation (use After Effects)\n- Basic screen recording (use OBS)\n\n---\n\n## Technology Selection\n\n### Video Editing Tools\n\n| Tool | Speed | Features | Use Case |\n|------|-------|----------|----------|\n| FFmpeg | Very Fast | CLI automation | Production pipelines |\n| MoviePy | Medium | Python API | Programmatic editing |\n| PyAV | Fast | Low-level control | Custom processing |\n| DaVinci Resolve | Slow | Full NLE | Manual editing |\n\n**Decision tree**:\n```\nNeed automation? → FFmpeg\nNeed Python API? → MoviePy\nNeed frame-level control? → PyAV\nNeed manual editing? → DaVinci Resolve\n```\n\n---\n\n## Common Anti-Patterns\n\n### Anti-Pattern 1: Not Using Keyframe-Aligned Cuts\n\n**Novice thinking**: \"Just cut the video at any timestamp\"\n\n**Problem**: Causes artifacts, black frames, and playback issues.\n\n**Wrong approach**:\n```bash\n# ❌ Cut at arbitrary timestamp (not keyframe-aligned)\nffmpeg -i input.mp4 -ss 00:01:23.456 -to 00:02:45.678 -c copy output.mp4\n\n# Result: Black frames, artifacts, sync issues\n```\n\n**Why wrong**:\n- Video codecs use keyframes (I-frames) every 2-10 seconds\n- Non-keyframe cuts require re-encoding\n- Using `-c copy` (stream copy) without keyframe alignment breaks playback\n- GOP (Group of Pictures) structure depends on keyframes\n\n**Correct approach 1**: Re-encode for precise cuts\n```bash\n# ✅ Re-encode for frame-accurate cutting\nffmpeg -i input.mp4 -ss 00:01:23.456 -to 00:02:45.678 \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a aac -b:a 192k \\\n  output.mp4\n\n# Frame-accurate, but slower (re-encoding)\n```\n\n**Correct approach 2**: Keyframe-aligned stream copy\n```bash\n# ✅ Fast cutting with keyframe alignment\n# Step 1: Find keyframes near cut points\nffprobe -select_streams v -show_frames -show_entries frame=pkt_pts_time,key_frame \\\n  -of csv input.mp4 | grep \",1$\" | awk -F',' '{print $2}'\n\n# Step 2: Cut at nearest keyframes (fast, no re-encoding)\nffmpeg -i input.mp4 -ss 00:01:22.000 -to 00:02:46.000 -c copy output.mp4\n\n# Blazing fast, no quality loss, but not frame-accurate\n```\n\n**Correct approach 3**: Two-pass for best of both worlds\n```bash\n# ✅ Fast seek + precise cut\nffmpeg -ss 00:01:20.000 -i input.mp4 \\\n  -ss 00:00:03.456 -to 00:01:25.678 \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a aac -b:a 192k \\\n  output.mp4\n\n# -ss BEFORE -i: Fast seek to keyframe (no decode)\n# -ss AFTER -i: Precise trim (only decode needed portion)\n```\n\n**Performance comparison**:\n| Method | Time (1-hour video) | Accuracy | Quality |\n|--------|---------------------|----------|---------|\n| Stream copy (arbitrary) | 2s | ❌ Broken | ❌ Artifacts |\n| Stream copy (keyframe) | 2s | ±2s | ✅ Perfect |\n| Re-encode (simple) | 15min | ✅ Frame | ⚠️ Quality loss |\n| Two-pass (optimal) | 3min | ✅ Frame | ✅ Perfect |\n\n**Timeline context**:\n- 2010: FFmpeg required full re-encoding for cuts\n- 2015: `-c copy` added for stream copying\n- 2020: Two-pass cutting became best practice\n- 2024: Hardware acceleration (NVENC) makes re-encoding viable\n\n---\n\n### Anti-Pattern 2: Re-encoding Unnecessarily\n\n**Novice thinking**: \"Apply all edits in one FFmpeg command\"\n\n**Problem**: Multiple re-encodings cause cumulative quality loss.\n\n**Wrong approach**:\n```bash\n# ❌ Re-encode for each operation (quality degradation)\n# Operation 1: Trim\nffmpeg -i input.mp4 -ss 00:01:00 -to 00:05:00 \\\n  -c:v libx264 -crf 23 temp1.mp4\n\n# Operation 2: Add audio\nffmpeg -i temp1.mp4 -i audio.mp3 -c:v libx264 -crf 23 \\\n  -map 0:v -map 1:a temp2.mp4\n\n# Operation 3: Add subtitles\nffmpeg -i temp2.mp4 -vf subtitles=subs.srt \\\n  -c:v libx264 -crf 23 output.mp4\n\n# Result: 3x re-encoding = significant quality loss\n```\n\n**Why wrong**:\n- Each re-encode is lossy (even with high CRF)\n- Cumulative quality loss (generation loss)\n- 3x encoding time\n- Wasted disk I/O\n\n**Correct approach 1**: Chain operations in single command\n```bash\n# ✅ Single-pass encoding with all operations\nffmpeg -ss 00:01:00 -i input.mp4 -i audio.mp3 \\\n  -to 00:04:00 \\\n  -vf \"subtitles=subs.srt\" \\\n  -map 0:v -map 1:a \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a aac -b:a 192k \\\n  output.mp4\n\n# Single re-encode, all operations applied at once\n```\n\n**Correct approach 2**: Use stream copy when possible\n```bash\n# ✅ Lossless operations with stream copy\n# Trim (stream copy)\nffmpeg -i input.mp4 -ss 00:01:00 -to 00:05:00 -c copy temp.mp4\n\n# Add audio (stream copy video, encode audio)\nffmpeg -i temp.mp4 -i audio.mp3 \\\n  -map 0:v -map 1:a \\\n  -c:v copy -c:a aac -b:a 192k \\\n  temp2.mp4\n\n# Burn subtitles (must re-encode video)\nffmpeg -i temp2.mp4 -vf subtitles=subs.srt \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a copy \\\n  output.mp4\n\n# Only 1 video re-encode (for subtitles)\n```\n\n**Quality comparison**:\n| Method | Encoding Passes | Quality (VMAF) | Time |\n|--------|-----------------|----------------|------|\n| 3x re-encode (CRF 23) | 3 | 82/100 | 45min |\n| Single pass (CRF 23) | 1 | 91/100 | 15min |\n| Stream copy + 1 encode | 1 | 95/100 | 18min |\n| All stream copy | 0 | 100/100 | 30s |\n\n---\n\n### Anti-Pattern 3: Ignoring Color Space Conversions\n\n**Novice thinking**: \"Just concatenate videos together\"\n\n**Problem**: Color shifts, mismatched brightness, broken playback.\n\n**Wrong approach**:\n```bash\n# ❌ Concatenate videos with different color spaces\n# clip1.mp4: BT.709 (HD), yuv420p\n# clip2.mp4: BT.601 (SD), yuvj420p (full range)\n# clip3.mp4: BT.2020 (HDR), yuv420p10le\n\n# Create concat list\necho \"file 'clip1.mp4'\" > list.txt\necho \"file 'clip2.mp4'\" >> list.txt\necho \"file 'clip3.mp4'\" >> list.txt\n\n# Concatenate without color normalization\nffmpeg -f concat -safe 0 -i list.txt -c copy output.mp4\n\n# Result: Color shifts between clips, broken HDR metadata\n```\n\n**Why wrong**:\n- Different color spaces (BT.601 vs BT.709 vs BT.2020)\n- Different pixel formats (yuv420p vs yuvj420p)\n- Different color ranges (limited vs full)\n- Metadata conflicts\n\n**Correct approach**:\n```bash\n# ✅ Normalize color space before concatenation\n\n# Step 1: Analyze color space of each clip\nffprobe -v error -select_streams v:0 \\\n  -show_entries stream=color_space,color_transfer,color_primaries,pix_fmt \\\n  -of default=noprint_wrappers=1 clip1.mp4\n\n# Step 2: Normalize all clips to common color space\n# Target: BT.709 (HD), yuv420p, limited range\n\n# Normalize clip1 (already BT.709)\nffmpeg -i clip1.mp4 -c copy clip1_normalized.mp4\n\n# Normalize clip2 (BT.601 SD → BT.709 HD)\nffmpeg -i clip2.mp4 \\\n  -vf \"scale=in_range=full:out_range=limited,colorspace=bt709:iall=bt601:fast=1\" \\\n  -color_primaries bt709 \\\n  -color_trc bt709 \\\n  -colorspace bt709 \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a copy \\\n  clip2_normalized.mp4\n\n# Normalize clip3 (BT.2020 HDR → BT.709 SDR)\nffmpeg -i clip3.mp4 \\\n  -vf \"zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=hable:desat=0,zscale=t=bt709:m=bt709:r=limited,format=yuv420p\" \\\n  -color_primaries bt709 \\\n  -color_trc bt709 \\\n  -colorspace bt709 \\\n  -c:v libx264 -crf 18 -preset medium \\\n  -c:a copy \\\n  clip3_normalized.mp4\n\n# Step 3: Concatenate normalized clips\necho \"file 'clip1_normalized.mp4'\" > list.txt\necho \"file 'clip2_normalized.mp4'\" >> list.txt\necho \"file 'clip3_normalized.mp4'\" >> list.txt\n\nffmpeg -f concat -safe 0 -i list.txt -c copy output.mp4\n```\n\n**Color space guide**:\n| Standard | Color Space | Transfer | Primaries | Use Case |\n|----------|-------------|----------|-----------|----------|\n| BT.601 | SD | bt470bg | bt470bg | Old SD content |\n| BT.709 | HD | bt709 | bt709 | Modern HD/FHD |\n| BT.2020 | UHD/HDR | smpte2084 | bt2020 | 4K HDR |\n| sRGB | Web | iec61966-2-1 | bt709 | Web delivery |\n\n---\n\n### Anti-Pattern 4: Poor Audio Sync\n\n**Novice thinking**: \"Video and audio are separate, just overlay them\"\n\n**Problem**: Lip sync issues, audio drift, broken playback.\n\n**Wrong approach**:\n```bash\n# ❌ Replace audio without sync consideration\nffmpeg -i video.mp4 -i audio.mp3 \\\n  -map 0:v -map 1:a \\\n  -c:v copy -c:a copy \\\n  output.mp4\n\n# Problems:\n# - Audio duration ≠ video duration\n# - No audio stretching/compression\n# - Drift over time\n```\n\n**Why wrong**:\n- Audio and video have different durations\n- No timebase synchronization\n- No drift correction\n- Ignores original audio sync\n\n**Correct approach 1**: Stretch/compress audio to match video\n```bash\n# ✅ Adjust audio speed to match video duration\n\n# Get durations\nVIDEO_DUR=$(ffprobe -v error -show_entries format=duration \\\n  -of default=noprint_wrappers=1:nokey=1 video.mp4)\nAUDIO_DUR=$(ffprobe -v error -show_entries format=duration \\\n  -of default=noprint_wrappers=1:nokey=1 audio.mp3)\n\n# Calculate speed ratio\nRATIO=$(echo \"$VIDEO_DUR / $AUDIO_DUR\" | bc -l)\n\n# Stretch audio to match video (with pitch correction)\nffmpeg -i video.mp4 -i audio.mp3 \\\n  -filter_complex \"[1:a]atempo=${RATIO}[a]\" \\\n  -map 0:v -map \"[a]\" \\\n  -c:v copy -c:a aac -b:a 192k \\\n  output.mp4\n```\n\n**Correct approach 2**: Precise offset and trim\n```bash\n# ✅ Sync audio with offset and trim\n\n# Audio starts 0.5s late, trim to match video\nffmpeg -i video.mp4 -itsoffset 0.5 -i audio.mp3 \\\n  -map 0:v -map 1:a \\\n  -shortest \\\n  -c:v copy -c:a aac -b:a 192k \\\n  output.mp4\n\n# -itsoffset: Delay audio by 0.5s\n# -shortest: Trim to shortest stream\n```\n\n**Correct approach 3**: Mix multiple audio tracks with sync\n```bash\n# ✅ Mix dialogue, music, effects with precise timing\n\nffmpeg -i video.mp4 -i dialogue.wav -i music.mp3 -i sfx.wav \\\n  -filter_complex \"\n    [1:a]adelay=0|0[dlg];\n    [2:a]volume=0.3,adelay=500|500[mus];\n    [3:a]adelay=1200|1200[sfx];\n    [dlg][mus][sfx]amix=inputs=3:duration=first[a]\n  \" \\\n  -map 0:v -map \"[a]\" \\\n  -c:v copy -c:a aac -b:a 256k \\\n  output.mp4\n\n# adelay: Precise millisecond timing\n# amix: Mix multiple audio streams\n# volume: Normalize levels\n```\n\n**Audio sync checklist**:\n```\n□ Verify video and audio durations match\n□ Use -shortest to prevent excess audio\n□ Apply adelay for precise timing offsets\n□ Use atempo for speed adjustment (maintains pitch)\n□ Set audio bitrate appropriately (128k-256k)\n□ Test lip sync at beginning, middle, end\n```\n\n---\n\n### Anti-Pattern 5: Wrong Codec/Bitrate for Platform\n\n**Novice thinking**: \"One export settings for everything\"\n\n**Problem**: Wasted bandwidth, poor quality, rejected uploads, compatibility issues.\n\n**Wrong approach**:\n```bash\n# ❌ Export everything at 4K 50 Mbps\nffmpeg -i input.mp4 \\\n  -c:v libx264 -b:v 50M -s 3840x2160 \\\n  -c:a aac -b:a 320k \\\n  output.mp4\n\n# For Instagram story: 2 GB file, rejected (max 100 MB)\n# For YouTube: Could use 10 Mbps and look identical\n# For Twitter: Exceeds bitrate limits\n```\n\n**Why wrong**:\n- Platform-specific size/bitrate limits\n- Over-encoding wastes bandwidth\n- Wrong resolution for platform\n- Incompatible codecs\n\n**Correct approach**: Platform-optimized exports\n\n**YouTube (recommended settings)**:\n```bash\n# ✅ YouTube 1080p upload\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset slow -crf 18 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -color_primaries bt709 -color_trc bt709 -colorspace bt709 \\\n  -movflags +faststart \\\n  -c:a aac -b:a 192k -ar 48000 \\\n  youtube_1080p.mp4\n\n# YouTube 4K upload\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset slow -crf 18 \\\n  -s 3840x2160 -r 60 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 256k -ar 48000 \\\n  youtube_4k.mp4\n```\n\n**Instagram (Stories, Reels, Feed)**:\n```bash\n# ✅ Instagram Story (9:16, max 100 MB, 15s)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 15 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_story.mp4\n\n# ✅ Instagram Reel (9:16, max 90s)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 90 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_reel.mp4\n\n# ✅ Instagram Feed (1:1 or 4:5)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  instagram_feed.mp4\n```\n\n**Twitter/X**:\n```bash\n# ✅ Twitter video (max 512 MB, 2:20)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1280x720 -r 30 -t 140 \\\n  -maxrate 5000k -bufsize 10000k \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  twitter.mp4\n```\n\n**TikTok**:\n```bash\n# ✅ TikTok (9:16, max 287 MB, 10 min)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1080x1920 -r 30 -t 600 \\\n  -pix_fmt yuv420p \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k \\\n  tiktok.mp4\n```\n\n**Web (HTML5 video)**:\n```bash\n# ✅ Web optimized (fast load, broad compatibility)\nffmpeg -i input.mp4 \\\n  -c:v libx264 -preset medium -crf 23 \\\n  -s 1920x1080 -r 30 \\\n  -pix_fmt yuv420p \\\n  -profile:v baseline -level 3.0 \\\n  -movflags +faststart \\\n  -c:a aac -b:a 128k -ar 48000 \\\n  web.mp4\n```\n\n**Platform specs table**:\n| Platform | Max Size | Max Duration | Resolution | FPS | Bitrate | Codec |\n|----------|----------|--------------|------------|-----|---------|-------|\n| YouTube | Unlimited | Unlimited | 8K | 60 | Auto | H.264/VP9 |\n| Instagram Story | 100 MB | 15s | 1080x1920 | 30 | ~5 Mbps | H.264 |\n| Instagram Reel | 1 GB | 90s | 1080x1920 | 30 | ~8 Mbps | H.264 |\n| Twitter | 512 MB | 2:20 | 1920x1080 | 60 | 5 Mbps | H.264 |\n| TikTok | 287 MB | 10min | 1080x1920 | 30 | ~4 Mbps | H.264 |\n| LinkedIn | 5 GB | 10min | 1920x1080 | 30 | 5 Mbps | H.264 |\n| Web | Varies | Varies | 1920x1080 | 30 | 2-5 Mbps | H.264 |\n\n**Export optimization checklist**:\n```\n□ Use -movflags +faststart for web (progressive download)\n□ Use -pix_fmt yuv420p for broad compatibility\n□ Set -r 30 for most platforms (avoid variable framerate)\n□ Use -preset slow for final exports (better quality)\n□ Use -preset ultrafast for drafts\n□ Apply -maxrate and -bufsize for streaming\n□ Test playback on target platform before bulk export\n```\n\n---\n\n## Production Checklist\n\n```\n□ Align cuts to keyframes (or two-pass seek)\n□ Chain operations in single FFmpeg command\n□ Normalize color spaces before concatenating\n□ Verify audio/video sync (test at multiple points)\n□ Use platform-specific export presets\n□ Apply -movflags +faststart for web delivery\n□ Set proper color metadata (bt709 for HD)\n□ Test output file on target platform\n□ Keep lossless intermediate files (ProRes, FFV1)\n□ Use hardware acceleration for batch jobs (NVENC, VideoToolbox)\n```\n\n---\n\n## When to Use vs Avoid\n\n| Scenario | Appropriate? |\n|----------|--------------|\n| Automated video pipeline (script → video) | ✅ Yes - FFmpeg automation |\n| Batch process 100 videos | ✅ Yes - parallel FFmpeg jobs |\n| Trim/cut clips programmatically | ✅ Yes - precise cutting |\n| Add subtitles to videos | ✅ Yes - burn or soft subs |\n| Color grade footage | ⚠️ Limited - basic only |\n| Multi-cam editing | ❌ No - use DaVinci Resolve |\n| Motion graphics | ❌ No - use After Effects |\n| Real-time preview editing | ❌ No - use Premiere/Resolve |\n\n---\n\n## References\n\n- `/references/ffmpeg-guide.md` - Complete FFmpeg command reference\n- `/references/timeline-editing.md` - Timeline concepts, multi-track editing\n- `/references/export-optimization.md` - Platform-specific export settings\n\n## Scripts\n\n- `scripts/video_editor.py` - Cut, trim, concatenate, transitions, effects\n- `scripts/batch_processor.py` - Parallel batch video processing\n\n---\n\n**This skill guides**: Video editing | FFmpeg | Timeline editing | Transitions | Export optimization | Audio mixing | Color grading | Automated video production\n"
    }
  ]
}