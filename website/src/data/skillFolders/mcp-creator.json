{
  "name": "mcp-creator",
  "type": "folder",
  "path": "mcp-creator",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "mcp-creator/references",
      "children": [
        {
          "name": "architecture-patterns.md",
          "type": "file",
          "path": "mcp-creator/references/architecture-patterns.md",
          "size": 9441,
          "content": "# MCP Architecture Patterns\n\n## Transport Layers\n\n### Stdio Transport (Recommended for CLI)\n```typescript\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\n// Best for: CLI tools, local development, Claude Code integration\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n**Pros**: Simple, no network config, secure (process-level isolation)\n**Cons**: Single client, no remote access\n\n### SSE Transport (HTTP)\n```typescript\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\nimport express from \"express\";\n\nconst app = express();\napp.use(\"/sse\", async (req, res) => {\n  const transport = new SSEServerTransport(\"/messages\", res);\n  await server.connect(transport);\n});\napp.listen(3000);\n```\n\n**Pros**: Multiple clients, remote access, browser-compatible\n**Cons**: More complex, requires HTTP server\n\n### Custom Transport\n```typescript\nclass CustomTransport implements Transport {\n  async start(): Promise<void> { /* Initialize connection */ }\n  async close(): Promise<void> { /* Cleanup */ }\n  async send(message: JSONRPCMessage): Promise<void> { /* Send message */ }\n  onMessage?: (message: JSONRPCMessage) => void;\n  onError?: (error: Error) => void;\n  onClose?: () => void;\n}\n```\n\n## Server Lifecycle\n\n### Initialization Pattern\n```typescript\nclass MCPServer {\n  private pool: Pool | null = null;\n  private cache: Cache | null = null;\n\n  async initialize(): Promise<void> {\n    // 1. Validate configuration\n    this.validateConfig();\n\n    // 2. Initialize connections (parallel)\n    const [pool, cache] = await Promise.all([\n      this.initDatabase(),\n      this.initCache(),\n    ]);\n\n    this.pool = pool;\n    this.cache = cache;\n\n    // 3. Warm caches if needed\n    await this.warmCaches();\n\n    // 4. Register signal handlers\n    this.registerShutdownHandlers();\n  }\n\n  private registerShutdownHandlers(): void {\n    const shutdown = async () => {\n      console.error(\"Shutting down...\");\n      await this.pool?.end();\n      await this.cache?.quit();\n      process.exit(0);\n    };\n\n    process.on(\"SIGTERM\", shutdown);\n    process.on(\"SIGINT\", shutdown);\n  }\n}\n```\n\n### Health Check Pattern\n```typescript\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: [\n    {\n      name: \"health_check\",\n      description: \"Check server health and dependencies\",\n      inputSchema: { type: \"object\", properties: {} },\n    },\n    // ... other tools\n  ],\n}));\n\nasync function healthCheck(): Promise<HealthStatus> {\n  const checks = await Promise.allSettled([\n    checkDatabase(),\n    checkCache(),\n    checkExternalApi(),\n  ]);\n\n  return {\n    status: checks.every(c => c.status === \"fulfilled\") ? \"healthy\" : \"degraded\",\n    checks: {\n      database: checks[0].status === \"fulfilled\" ? \"ok\" : \"failed\",\n      cache: checks[1].status === \"fulfilled\" ? \"ok\" : \"failed\",\n      externalApi: checks[2].status === \"fulfilled\" ? \"ok\" : \"failed\",\n    },\n    timestamp: new Date().toISOString(),\n  };\n}\n```\n\n## Resource Management\n\n### Connection Pool Pattern\n```typescript\nimport { Pool, PoolConfig } from \"pg\";\n\nconst poolConfig: PoolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  max: 20,                        // Max connections\n  idleTimeoutMillis: 30000,       // Close idle connections after 30s\n  connectionTimeoutMillis: 2000,  // Fail fast if can't connect\n  statement_timeout: 30000,       // Kill queries after 30s\n};\n\nconst pool = new Pool(poolConfig);\n\n// Monitor pool health\npool.on(\"error\", (err) => {\n  console.error(\"Unexpected pool error:\", err);\n});\n\npool.on(\"connect\", () => {\n  console.error(\"New client connected to pool\");\n});\n```\n\n### Resource Cleanup Pattern\n```typescript\nclass ResourceManager {\n  private resources: Set<Disposable> = new Set();\n\n  register<T extends Disposable>(resource: T): T {\n    this.resources.add(resource);\n    return resource;\n  }\n\n  async disposeAll(): Promise<void> {\n    const errors: Error[] = [];\n\n    for (const resource of this.resources) {\n      try {\n        await resource.dispose();\n      } catch (error) {\n        errors.push(error as Error);\n      }\n    }\n\n    this.resources.clear();\n\n    if (errors.length > 0) {\n      throw new AggregateError(errors, \"Resource disposal failed\");\n    }\n  }\n}\n```\n\n## State Management\n\n### Stateless Design (Preferred)\n```typescript\n// Each request is self-contained\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  // Get state from request or external store\n  const session = await getSession(request.params.sessionId);\n\n  // Process\n  const result = await processWithSession(session, request.params);\n\n  // Persist state externally\n  await saveSession(session);\n\n  return result;\n});\n```\n\n### Stateful Design (When Necessary)\n```typescript\n// For WebSockets, long-running connections\nclass StatefulServer {\n  private sessions: Map<string, Session> = new Map();\n\n  async handleConnection(clientId: string): Promise<Session> {\n    const session = new Session(clientId);\n    this.sessions.set(clientId, session);\n\n    // Set TTL for cleanup\n    setTimeout(() => this.cleanup(clientId), 3600000); // 1 hour\n\n    return session;\n  }\n\n  private cleanup(clientId: string): void {\n    const session = this.sessions.get(clientId);\n    if (session?.isExpired()) {\n      session.dispose();\n      this.sessions.delete(clientId);\n    }\n  }\n}\n```\n\n## Capabilities Declaration\n\n### Tools Capability\n```typescript\nconst server = new Server(\n  { name: \"my-server\", version: \"1.0.0\" },\n  {\n    capabilities: {\n      tools: {},  // Enable tools\n    },\n  }\n);\n```\n\n### Resources Capability\n```typescript\nconst server = new Server(\n  { name: \"my-server\", version: \"1.0.0\" },\n  {\n    capabilities: {\n      resources: {\n        subscribe: true,  // Enable resource subscriptions\n      },\n    },\n  }\n);\n\n// Define resources\nserver.setRequestHandler(ListResourcesRequestSchema, async () => ({\n  resources: [\n    {\n      uri: \"config://settings\",\n      name: \"Server Settings\",\n      description: \"Current server configuration\",\n      mimeType: \"application/json\",\n    },\n  ],\n}));\n\n// Read resource\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  if (request.params.uri === \"config://settings\") {\n    return {\n      contents: [{\n        uri: request.params.uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(getConfig()),\n      }],\n    };\n  }\n});\n```\n\n### Prompts Capability\n```typescript\nconst server = new Server(\n  { name: \"my-server\", version: \"1.0.0\" },\n  {\n    capabilities: {\n      prompts: {},  // Enable prompts\n    },\n  }\n);\n\nserver.setRequestHandler(ListPromptsRequestSchema, async () => ({\n  prompts: [\n    {\n      name: \"analyze_code\",\n      description: \"Analyze code for issues\",\n      arguments: [\n        { name: \"code\", description: \"Code to analyze\", required: true },\n        { name: \"language\", description: \"Programming language\" },\n      ],\n    },\n  ],\n}));\n```\n\n## Multi-Server Coordination\n\n### Shared Configuration\n```typescript\n// config.ts - Shared across servers\nexport const CONFIG = {\n  database: {\n    host: process.env.DB_HOST,\n    port: parseInt(process.env.DB_PORT || \"5432\"),\n    database: process.env.DB_NAME,\n  },\n  redis: {\n    url: process.env.REDIS_URL,\n  },\n  rateLimit: {\n    requestsPerMinute: 100,\n    burstSize: 20,\n  },\n};\n```\n\n### Service Registry Pattern\n```typescript\n// For discovering other MCP servers\nclass ServiceRegistry {\n  private services: Map<string, ServiceInfo> = new Map();\n\n  register(name: string, info: ServiceInfo): void {\n    this.services.set(name, info);\n  }\n\n  discover(name: string): ServiceInfo | undefined {\n    return this.services.get(name);\n  }\n\n  async healthCheckAll(): Promise<Record<string, boolean>> {\n    const results: Record<string, boolean> = {};\n\n    for (const [name, info] of this.services) {\n      try {\n        const response = await fetch(`${info.url}/health`);\n        results[name] = response.ok;\n      } catch {\n        results[name] = false;\n      }\n    }\n\n    return results;\n  }\n}\n```\n\n## Logging Best Practices\n\n### Structured Logging\n```typescript\nimport pino from \"pino\";\n\nconst logger = pino({\n  level: process.env.LOG_LEVEL || \"info\",\n  formatters: {\n    level: (label) => ({ level: label }),\n  },\n  timestamp: pino.stdTimeFunctions.isoTime,\n});\n\n// In handlers\nlogger.info({ tool: \"my_tool\", args: sanitizedArgs }, \"Tool invoked\");\nlogger.error({ err, tool: \"my_tool\" }, \"Tool failed\");\n```\n\n### Audit Logging\n```typescript\ninterface AuditLog {\n  timestamp: string;\n  tool: string;\n  userId?: string;\n  args: Record<string, unknown>;\n  result: \"success\" | \"failure\";\n  duration: number;\n  errorCode?: string;\n}\n\nasync function auditLog(entry: AuditLog): Promise<void> {\n  // To file, database, or external service\n  await appendToAuditLog(entry);\n}\n```\n\n## Versioning Strategy\n\n### Semantic Versioning\n```typescript\nconst server = new Server(\n  {\n    name: \"my-server\",\n    version: \"2.1.0\",  // MAJOR.MINOR.PATCH\n  },\n  { capabilities: { tools: {} } }\n);\n```\n\n### Backwards Compatibility\n```typescript\n// Support old and new parameter names\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const args = request.params.arguments;\n\n  // Support both old and new field names\n  const userId = args.userId || args.user_id;  // New or legacy\n\n  // Deprecation warning\n  if (args.user_id) {\n    console.warn(\"user_id is deprecated, use userId\");\n  }\n});\n```\n"
        },
        {
          "name": "security-hardening.md",
          "type": "file",
          "path": "mcp-creator/references/security-hardening.md",
          "size": 12426,
          "content": "# MCP Security Hardening Guide\n\n## Security Checklist\n\nBefore deploying any MCP server, verify:\n\n```\nINPUT VALIDATION\n├── [ ] All inputs validated with schema (Zod/JSON Schema)\n├── [ ] String lengths limited\n├── [ ] Numeric ranges constrained\n├── [ ] Regex patterns for format validation\n├── [ ] No SQL/command injection vectors\n└── [ ] Arrays have max length limits\n\nAUTHENTICATION & AUTHORIZATION\n├── [ ] Credentials in environment variables only\n├── [ ] Secrets never logged or returned in errors\n├── [ ] API keys rotated regularly\n├── [ ] Minimum required permissions\n└── [ ] Token validation on every request\n\nRATE LIMITING\n├── [ ] Per-user rate limits\n├── [ ] Per-tool rate limits\n├── [ ] Global rate limits\n├── [ ] Graceful degradation on limit\n└── [ ] Rate limit headers in responses\n\nERROR HANDLING\n├── [ ] No stack traces in production\n├── [ ] Sensitive data sanitized from errors\n├── [ ] Generic errors for auth failures\n├── [ ] Structured error responses\n└── [ ] All errors logged securely\n\nNETWORK SECURITY\n├── [ ] HTTPS for all external calls\n├── [ ] Certificate validation enabled\n├── [ ] Timeouts on all requests\n├── [ ] No SSRF vulnerabilities\n└── [ ] IP allowlisting where appropriate\n```\n\n## Input Validation Patterns\n\n### Using Zod (Recommended)\n```typescript\nimport { z } from \"zod\";\n\n// Define strict schemas\nconst UserQuerySchema = z.object({\n  userId: z.string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9_-]+$/, \"Invalid userId format\"),\n\n  query: z.string()\n    .max(10000)\n    .refine(\n      (q) => !containsSqlInjection(q),\n      { message: \"Invalid query content\" }\n    ),\n\n  options: z.object({\n    limit: z.number().int().min(1).max(1000).default(100),\n    offset: z.number().int().min(0).default(0),\n    sortBy: z.enum([\"created\", \"updated\", \"name\"]).default(\"created\"),\n  }).optional(),\n});\n\n// Validate in handler\nasync function handleUserQuery(args: unknown) {\n  const validated = UserQuerySchema.parse(args);\n  // Safe to use validated.userId, validated.query, etc.\n}\n```\n\n### SQL Injection Prevention\n```typescript\n// ✅ Good: Parameterized queries\nconst result = await pool.query(\n  \"SELECT * FROM users WHERE id = $1 AND status = $2\",\n  [userId, status]\n);\n\n// ✅ Good: Query builder with escaping\nconst users = await knex(\"users\")\n  .where({ id: userId, status })\n  .select(\"*\");\n\n// ❌ BAD: String concatenation\nconst result = await pool.query(\n  `SELECT * FROM users WHERE id = '${userId}'`  // SQL INJECTION!\n);\n```\n\n### Command Injection Prevention\n```typescript\nimport { execFile } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execFileAsync = promisify(execFile);\n\n// ✅ Good: execFile with array arguments\nasync function runGitCommand(args: string[]) {\n  // Validate args don't contain shell metacharacters\n  for (const arg of args) {\n    if (/[;&|`$]/.test(arg)) {\n      throw new Error(\"Invalid characters in argument\");\n    }\n  }\n\n  const { stdout } = await execFileAsync(\"git\", args);\n  return stdout;\n}\n\n// ❌ BAD: exec with string\nimport { exec } from \"child_process\";\nexec(`git ${userInput}`);  // COMMAND INJECTION!\n```\n\n### Path Traversal Prevention\n```typescript\nimport path from \"path\";\n\nfunction safePath(basePath: string, userPath: string): string {\n  const resolved = path.resolve(basePath, userPath);\n\n  // Ensure resolved path is within base\n  if (!resolved.startsWith(path.resolve(basePath))) {\n    throw new Error(\"Path traversal attempt detected\");\n  }\n\n  return resolved;\n}\n\n// Usage\nconst filePath = safePath(\"/app/data\", userSuppliedPath);\nawait fs.readFile(filePath);\n```\n\n## Secret Management\n\n### Environment Variables (Minimum)\n```typescript\n// config.ts\nfunction requireEnv(name: string): string {\n  const value = process.env[name];\n  if (!value) {\n    throw new Error(`Required environment variable ${name} is not set`);\n  }\n  return value;\n}\n\nexport const CONFIG = {\n  apiKey: requireEnv(\"SERVICE_API_KEY\"),\n  dbUrl: requireEnv(\"DATABASE_URL\"),\n  jwtSecret: requireEnv(\"JWT_SECRET\"),\n};\n```\n\n### Secret Manager Integration\n```typescript\nimport { SecretManagerServiceClient } from \"@google-cloud/secret-manager\";\n\nconst client = new SecretManagerServiceClient();\n\nasync function getSecret(name: string): Promise<string> {\n  const [version] = await client.accessSecretVersion({\n    name: `projects/my-project/secrets/${name}/versions/latest`,\n  });\n\n  return version.payload?.data?.toString() || \"\";\n}\n\n// Cache secrets on startup\nlet cachedSecrets: Record<string, string> = {};\n\nasync function initializeSecrets(): Promise<void> {\n  const secretNames = [\"API_KEY\", \"DB_PASSWORD\", \"JWT_SECRET\"];\n\n  const results = await Promise.all(\n    secretNames.map(async (name) => [name, await getSecret(name)])\n  );\n\n  cachedSecrets = Object.fromEntries(results);\n}\n```\n\n### Secret Rotation\n```typescript\nclass RotatingSecret {\n  private currentSecret: string;\n  private previousSecret: string | null = null;\n  private rotationInterval: NodeJS.Timeout;\n\n  constructor(\n    private fetchSecret: () => Promise<string>,\n    rotationMs: number = 3600000  // 1 hour\n  ) {\n    this.rotationInterval = setInterval(() => this.rotate(), rotationMs);\n  }\n\n  async initialize(): Promise<void> {\n    this.currentSecret = await this.fetchSecret();\n  }\n\n  private async rotate(): Promise<void> {\n    this.previousSecret = this.currentSecret;\n    this.currentSecret = await this.fetchSecret();\n\n    // Keep previous valid for grace period\n    setTimeout(() => {\n      this.previousSecret = null;\n    }, 60000);  // 1 minute grace\n  }\n\n  validate(token: string): boolean {\n    return token === this.currentSecret ||\n           (this.previousSecret && token === this.previousSecret);\n  }\n}\n```\n\n## Rate Limiting Implementation\n\n### Token Bucket Algorithm\n```typescript\nclass TokenBucket {\n  private tokens: number;\n  private lastRefill: number;\n\n  constructor(\n    private capacity: number,\n    private refillRate: number  // tokens per second\n  ) {\n    this.tokens = capacity;\n    this.lastRefill = Date.now();\n  }\n\n  consume(tokens: number = 1): boolean {\n    this.refill();\n\n    if (this.tokens >= tokens) {\n      this.tokens -= tokens;\n      return true;\n    }\n\n    return false;\n  }\n\n  private refill(): void {\n    const now = Date.now();\n    const elapsed = (now - this.lastRefill) / 1000;\n    const newTokens = elapsed * this.refillRate;\n\n    this.tokens = Math.min(this.capacity, this.tokens + newTokens);\n    this.lastRefill = now;\n  }\n}\n\n// Per-user buckets\nconst userBuckets = new Map<string, TokenBucket>();\n\nfunction getRateLimiter(userId: string): TokenBucket {\n  if (!userBuckets.has(userId)) {\n    userBuckets.set(userId, new TokenBucket(100, 10));  // 100 capacity, 10/sec\n  }\n  return userBuckets.get(userId)!;\n}\n```\n\n### Sliding Window Counter\n```typescript\nclass SlidingWindowCounter {\n  private windows: Map<string, Map<number, number>> = new Map();\n\n  constructor(\n    private windowSizeMs: number,\n    private limit: number\n  ) {}\n\n  isAllowed(key: string): boolean {\n    const now = Date.now();\n    const windowStart = Math.floor(now / this.windowSizeMs) * this.windowSizeMs;\n    const prevWindowStart = windowStart - this.windowSizeMs;\n\n    let keyWindows = this.windows.get(key);\n    if (!keyWindows) {\n      keyWindows = new Map();\n      this.windows.set(key, keyWindows);\n    }\n\n    // Get counts\n    const currentCount = keyWindows.get(windowStart) || 0;\n    const prevCount = keyWindows.get(prevWindowStart) || 0;\n\n    // Weight previous window by overlap\n    const prevWeight = (this.windowSizeMs - (now - windowStart)) / this.windowSizeMs;\n    const totalCount = currentCount + Math.floor(prevCount * prevWeight);\n\n    if (totalCount >= this.limit) {\n      return false;\n    }\n\n    // Increment current window\n    keyWindows.set(windowStart, currentCount + 1);\n\n    // Cleanup old windows\n    for (const [windowTime] of keyWindows) {\n      if (windowTime < prevWindowStart) {\n        keyWindows.delete(windowTime);\n      }\n    }\n\n    return true;\n  }\n}\n```\n\n## OWASP Top 10 Mitigations\n\n### A01: Broken Access Control\n```typescript\n// Verify permissions on every request\nasync function checkPermission(\n  userId: string,\n  resource: string,\n  action: string\n): Promise<boolean> {\n  const permissions = await getPermissions(userId);\n  return permissions.includes(`${resource}:${action}`);\n}\n\n// In handler\nif (!await checkPermission(userId, \"documents\", \"read\")) {\n  throw new McpError(ErrorCode.InvalidRequest, \"Access denied\");\n}\n```\n\n### A02: Cryptographic Failures\n```typescript\nimport { scrypt, randomBytes, timingSafeEqual } from \"crypto\";\nimport { promisify } from \"util\";\n\nconst scryptAsync = promisify(scrypt);\n\n// ✅ Good: Use strong hashing\nasync function hashPassword(password: string): Promise<string> {\n  const salt = randomBytes(16).toString(\"hex\");\n  const hash = await scryptAsync(password, salt, 64) as Buffer;\n  return `${salt}:${hash.toString(\"hex\")}`;\n}\n\n// ✅ Good: Timing-safe comparison\nasync function verifyPassword(password: string, stored: string): Promise<boolean> {\n  const [salt, hash] = stored.split(\":\");\n  const hashBuffer = Buffer.from(hash, \"hex\");\n  const suppliedHash = await scryptAsync(password, salt, 64) as Buffer;\n  return timingSafeEqual(hashBuffer, suppliedHash);\n}\n\n// ❌ BAD: Weak algorithms\nimport { createHash } from \"crypto\";\ncreateHash(\"md5\").update(password).digest(\"hex\");  // INSECURE!\n```\n\n### A03: Injection\nSee SQL and Command Injection sections above.\n\n### A05: Security Misconfiguration\n```typescript\n// Validate all configuration\nfunction validateConfig(config: Config): void {\n  // No default credentials\n  if (config.adminPassword === \"admin\") {\n    throw new Error(\"Default admin password detected\");\n  }\n\n  // HTTPS required in production\n  if (config.nodeEnv === \"production\" && !config.apiUrl.startsWith(\"https\")) {\n    throw new Error(\"HTTPS required in production\");\n  }\n\n  // Debug mode off in production\n  if (config.nodeEnv === \"production\" && config.debug) {\n    throw new Error(\"Debug mode must be off in production\");\n  }\n}\n```\n\n### A10: Server-Side Request Forgery (SSRF)\n```typescript\nimport { URL } from \"url\";\nimport dns from \"dns/promises\";\n\nconst PRIVATE_RANGES = [\n  /^10\\./,\n  /^172\\.(1[6-9]|2[0-9]|3[01])\\./,\n  /^192\\.168\\./,\n  /^127\\./,\n  /^169\\.254\\./,\n  /^0\\./,\n];\n\nasync function safeFetch(urlString: string): Promise<Response> {\n  const url = new URL(urlString);\n\n  // Only allow HTTPS\n  if (url.protocol !== \"https:\") {\n    throw new Error(\"Only HTTPS URLs allowed\");\n  }\n\n  // Resolve hostname and check for private IPs\n  const addresses = await dns.resolve4(url.hostname);\n  for (const addr of addresses) {\n    if (PRIVATE_RANGES.some(r => r.test(addr))) {\n      throw new Error(\"Private IP addresses not allowed\");\n    }\n  }\n\n  // Allow-list domains if possible\n  const allowedDomains = [\"api.example.com\", \"service.example.org\"];\n  if (!allowedDomains.includes(url.hostname)) {\n    throw new Error(\"Domain not in allow list\");\n  }\n\n  return fetch(urlString);\n}\n```\n\n## Error Handling Security\n\n### Sanitize Error Messages\n```typescript\nclass SecureError extends Error {\n  constructor(\n    public userMessage: string,\n    public internalMessage: string,\n    public code: string\n  ) {\n    super(internalMessage);\n  }\n}\n\nfunction handleError(error: unknown): McpError {\n  // Log full error internally\n  console.error(\"Internal error:\", error);\n\n  // Return safe message to user\n  if (error instanceof SecureError) {\n    return new McpError(ErrorCode.InternalError, error.userMessage);\n  }\n\n  if (error instanceof z.ZodError) {\n    return new McpError(\n      ErrorCode.InvalidParams,\n      \"Invalid input parameters\"  // Don't expose field names\n    );\n  }\n\n  // Generic error for unexpected cases\n  return new McpError(\n    ErrorCode.InternalError,\n    \"An unexpected error occurred\"\n  );\n}\n```\n\n### Secure Logging\n```typescript\n// Redact sensitive fields\nfunction redactSensitive(obj: Record<string, unknown>): Record<string, unknown> {\n  const sensitiveFields = [\"password\", \"token\", \"apiKey\", \"secret\", \"authorization\"];\n  const redacted = { ...obj };\n\n  for (const field of sensitiveFields) {\n    if (field in redacted) {\n      redacted[field] = \"[REDACTED]\";\n    }\n  }\n\n  return redacted;\n}\n\n// Usage\nlogger.info({ args: redactSensitive(args) }, \"Tool called\");\n```\n"
        },
        {
          "name": "testing-debugging.md",
          "type": "file",
          "path": "mcp-creator/references/testing-debugging.md",
          "size": 12290,
          "content": "# MCP Testing and Debugging Guide\n\n## Testing Tools\n\n### MCP Inspector (Official)\n```bash\n# Install globally\nnpm install -g @modelcontextprotocol/inspector\n\n# Run inspector\nnpx @modelcontextprotocol/inspector\n\n# Connect to your server\n# In inspector UI: Connect to stdio server\n```\n\n**Inspector capabilities:**\n- List available tools and resources\n- Execute tool calls with custom arguments\n- View request/response JSON\n- Test error handling\n- Profile performance\n\n### Manual Testing with Node\n```typescript\n// test-client.ts\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { spawn } from \"child_process\";\n\nasync function testServer() {\n  // Spawn server process\n  const serverProcess = spawn(\"node\", [\"dist/index.js\"]);\n\n  const transport = new StdioClientTransport({\n    command: \"node\",\n    args: [\"dist/index.js\"],\n  });\n\n  const client = new Client({\n    name: \"test-client\",\n    version: \"1.0.0\",\n  }, {\n    capabilities: {},\n  });\n\n  await client.connect(transport);\n\n  // List tools\n  const tools = await client.listTools();\n  console.log(\"Available tools:\", tools);\n\n  // Call a tool\n  const result = await client.callTool({\n    name: \"my_tool\",\n    arguments: { input: \"test\" },\n  });\n  console.log(\"Result:\", result);\n\n  await client.close();\n}\n\ntestServer().catch(console.error);\n```\n\n## Unit Testing\n\n### Testing Tool Handlers\n```typescript\n// __tests__/handlers.test.ts\nimport { describe, it, expect, beforeEach, vi } from \"vitest\";\nimport { handleMyTool } from \"../src/handlers\";\n\ndescribe(\"handleMyTool\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it(\"should validate input correctly\", async () => {\n    await expect(handleMyTool({ input: \"\" }))\n      .rejects.toThrow(\"Input is required\");\n  });\n\n  it(\"should process valid input\", async () => {\n    const result = await handleMyTool({ input: \"test\" });\n\n    expect(result).toHaveProperty(\"success\", true);\n    expect(result).toHaveProperty(\"data\");\n  });\n\n  it(\"should handle options correctly\", async () => {\n    const result = await handleMyTool({\n      input: \"test\",\n      options: { format: \"text\" },\n    });\n\n    expect(typeof result).toBe(\"string\");\n  });\n});\n```\n\n### Testing Input Validation\n```typescript\n// __tests__/validation.test.ts\nimport { describe, it, expect } from \"vitest\";\nimport { z } from \"zod\";\nimport { MyToolSchema } from \"../src/schemas\";\n\ndescribe(\"MyToolSchema\", () => {\n  it(\"should accept valid input\", () => {\n    const input = { userId: \"abc123\", action: \"read\" };\n    expect(() => MyToolSchema.parse(input)).not.toThrow();\n  });\n\n  it(\"should reject missing required fields\", () => {\n    const input = { action: \"read\" };\n    expect(() => MyToolSchema.parse(input)).toThrow();\n  });\n\n  it(\"should reject invalid userId format\", () => {\n    const input = { userId: \"invalid!!!\", action: \"read\" };\n    expect(() => MyToolSchema.parse(input)).toThrow();\n  });\n\n  it(\"should reject invalid enum values\", () => {\n    const input = { userId: \"abc123\", action: \"invalid\" };\n    expect(() => MyToolSchema.parse(input)).toThrow();\n  });\n\n  it(\"should apply defaults\", () => {\n    const input = { userId: \"abc123\", action: \"read\" };\n    const result = MyToolSchema.parse(input);\n    expect(result.options?.limit).toBe(10);\n  });\n});\n```\n\n### Testing Rate Limiter\n```typescript\n// __tests__/rate-limiter.test.ts\nimport { describe, it, expect, beforeEach, vi } from \"vitest\";\nimport { RateLimiter } from \"../src/rate-limiter\";\n\ndescribe(\"RateLimiter\", () => {\n  let limiter: RateLimiter;\n\n  beforeEach(() => {\n    vi.useFakeTimers();\n    limiter = new RateLimiter(10, 60000); // 10 per minute\n  });\n\n  it(\"should allow requests under limit\", () => {\n    for (let i = 0; i < 10; i++) {\n      expect(limiter.canProceed(\"user1\")).toBe(true);\n    }\n  });\n\n  it(\"should block requests over limit\", () => {\n    for (let i = 0; i < 10; i++) {\n      limiter.canProceed(\"user1\");\n    }\n    expect(limiter.canProceed(\"user1\")).toBe(false);\n  });\n\n  it(\"should reset after window expires\", () => {\n    for (let i = 0; i < 10; i++) {\n      limiter.canProceed(\"user1\");\n    }\n\n    // Advance time by 1 minute\n    vi.advanceTimersByTime(60000);\n\n    expect(limiter.canProceed(\"user1\")).toBe(true);\n  });\n\n  it(\"should track users independently\", () => {\n    for (let i = 0; i < 10; i++) {\n      limiter.canProceed(\"user1\");\n    }\n\n    expect(limiter.canProceed(\"user1\")).toBe(false);\n    expect(limiter.canProceed(\"user2\")).toBe(true);\n  });\n});\n```\n\n### Testing API Client\n```typescript\n// __tests__/api-client.test.ts\nimport { describe, it, expect, beforeEach, vi } from \"vitest\";\nimport { apiRequest } from \"../src/api-client\";\n\n// Mock fetch\nglobal.fetch = vi.fn();\n\ndescribe(\"apiRequest\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it(\"should make successful request\", async () => {\n    (fetch as any).mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({ data: \"test\" }),\n    });\n\n    const result = await apiRequest(\"/endpoint\");\n    expect(result).toEqual({ data: \"test\" });\n  });\n\n  it(\"should retry on 5xx errors\", async () => {\n    (fetch as any)\n      .mockResolvedValueOnce({ ok: false, status: 500, text: async () => \"Error\" })\n      .mockResolvedValueOnce({ ok: true, json: async () => ({ data: \"success\" }) });\n\n    const result = await apiRequest(\"/endpoint\");\n    expect(result).toEqual({ data: \"success\" });\n    expect(fetch).toHaveBeenCalledTimes(2);\n  });\n\n  it(\"should not retry on 4xx errors\", async () => {\n    (fetch as any).mockResolvedValueOnce({\n      ok: false,\n      status: 400,\n      text: async () => \"Bad request\",\n    });\n\n    await expect(apiRequest(\"/endpoint\")).rejects.toThrow();\n    expect(fetch).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should handle timeout\", async () => {\n    vi.useFakeTimers();\n\n    (fetch as any).mockImplementationOnce(() => new Promise(() => {})); // Never resolves\n\n    const promise = apiRequest(\"/endpoint\", { timeout: 1000 });\n\n    vi.advanceTimersByTime(1000);\n\n    await expect(promise).rejects.toThrow(\"timeout\");\n  });\n});\n```\n\n## Integration Testing\n\n### Full Server Test\n```typescript\n// __tests__/integration.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from \"vitest\";\nimport { spawn, ChildProcess } from \"child_process\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\n\ndescribe(\"MCP Server Integration\", () => {\n  let client: Client;\n  let serverProcess: ChildProcess;\n\n  beforeAll(async () => {\n    const transport = new StdioClientTransport({\n      command: \"node\",\n      args: [\"dist/index.js\"],\n      env: {\n        ...process.env,\n        API_KEY: \"test-key\",\n        API_BASE_URL: \"http://localhost:3000\",\n      },\n    });\n\n    client = new Client({ name: \"test\", version: \"1.0.0\" }, { capabilities: {} });\n    await client.connect(transport);\n  });\n\n  afterAll(async () => {\n    await client.close();\n  });\n\n  it(\"should list tools\", async () => {\n    const { tools } = await client.listTools();\n\n    expect(tools).toBeInstanceOf(Array);\n    expect(tools.length).toBeGreaterThan(0);\n    expect(tools[0]).toHaveProperty(\"name\");\n    expect(tools[0]).toHaveProperty(\"inputSchema\");\n  });\n\n  it(\"should execute tool successfully\", async () => {\n    const result = await client.callTool({\n      name: \"example_tool\",\n      arguments: { input: \"test\" },\n    });\n\n    expect(result.content).toBeInstanceOf(Array);\n    expect(result.content[0].type).toBe(\"text\");\n  });\n\n  it(\"should handle invalid arguments\", async () => {\n    await expect(\n      client.callTool({\n        name: \"example_tool\",\n        arguments: { input: \"\" },\n      })\n    ).rejects.toThrow();\n  });\n});\n```\n\n## Debugging Techniques\n\n### Structured Logging\n```typescript\n// Add to your server\nconst DEBUG = process.env.DEBUG === \"true\";\n\nfunction debug(message: string, data?: unknown) {\n  if (DEBUG) {\n    console.error(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      level: \"debug\",\n      message,\n      data,\n    }));\n  }\n}\n\n// In handlers\ndebug(\"Tool called\", { name, args });\ndebug(\"API response\", { status, body });\n```\n\n### Request Tracing\n```typescript\nimport { randomUUID } from \"crypto\";\n\ninterface RequestContext {\n  requestId: string;\n  startTime: number;\n  tool: string;\n}\n\nconst activeRequests = new Map<string, RequestContext>();\n\nfunction startRequest(tool: string): string {\n  const requestId = randomUUID();\n  activeRequests.set(requestId, {\n    requestId,\n    startTime: Date.now(),\n    tool,\n  });\n  console.error(`[${requestId}] START ${tool}`);\n  return requestId;\n}\n\nfunction endRequest(requestId: string, success: boolean) {\n  const ctx = activeRequests.get(requestId);\n  if (ctx) {\n    const duration = Date.now() - ctx.startTime;\n    console.error(`[${requestId}] END ${ctx.tool} ${success ? \"OK\" : \"FAIL\"} ${duration}ms`);\n    activeRequests.delete(requestId);\n  }\n}\n```\n\n### Error Debugging\n```typescript\n// Detailed error logging\nfunction logError(error: unknown, context: Record<string, unknown>) {\n  const errorInfo = {\n    timestamp: new Date().toISOString(),\n    type: error instanceof Error ? error.constructor.name : typeof error,\n    message: error instanceof Error ? error.message : String(error),\n    stack: error instanceof Error ? error.stack : undefined,\n    context,\n  };\n\n  console.error(\"ERROR:\", JSON.stringify(errorInfo, null, 2));\n}\n\n// Usage in handlers\ntry {\n  // ... handler code\n} catch (error) {\n  logError(error, { tool: name, args: sanitizedArgs });\n  throw error;\n}\n```\n\n## Performance Profiling\n\n### Simple Timing\n```typescript\nfunction withTiming<T>(\n  name: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  const start = process.hrtime.bigint();\n\n  return fn().finally(() => {\n    const end = process.hrtime.bigint();\n    const durationMs = Number(end - start) / 1_000_000;\n    console.error(`TIMING ${name}: ${durationMs.toFixed(2)}ms`);\n  });\n}\n\n// Usage\nconst result = await withTiming(\"api_call\", () => apiRequest(\"/endpoint\"));\n```\n\n### Memory Monitoring\n```typescript\nfunction logMemory() {\n  const usage = process.memoryUsage();\n  console.error(\"MEMORY:\", {\n    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,\n    heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,\n    external: `${Math.round(usage.external / 1024 / 1024)}MB`,\n  });\n}\n\n// Log periodically\nsetInterval(logMemory, 60000);\n```\n\n## Common Issues and Solutions\n\n### Issue: Server Hangs on Startup\n**Cause**: Blocking initialization (missing await, sync I/O)\n**Solution**: Ensure all initialization is async\n```typescript\n// ❌ Bad\nconst config = fs.readFileSync(\"config.json\");  // Blocks\n\n// ✅ Good\nconst config = await fs.promises.readFile(\"config.json\");\n```\n\n### Issue: Memory Leaks\n**Cause**: Unbounded caches, event listener accumulation\n**Solution**: Set limits, cleanup old entries\n```typescript\n// Add TTL and max size to caches\nclass BoundedCache<T> {\n  private store = new Map<string, { value: T; expires: number }>();\n  private maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  set(key: string, value: T, ttlMs: number) {\n    // Evict oldest if at capacity\n    if (this.store.size >= this.maxSize) {\n      const oldest = this.store.keys().next().value;\n      this.store.delete(oldest);\n    }\n    this.store.set(key, { value, expires: Date.now() + ttlMs });\n  }\n}\n```\n\n### Issue: Rate Limit Errors from API\n**Cause**: Not respecting Retry-After header\n**Solution**: Parse and respect rate limit headers\n```typescript\nif (response.status === 429) {\n  const retryAfter = response.headers.get(\"Retry-After\");\n  const waitMs = retryAfter\n    ? parseInt(retryAfter) * 1000\n    : 60000;  // Default 1 minute\n\n  console.error(`Rate limited, waiting ${waitMs}ms`);\n  await new Promise(r => setTimeout(r, waitMs));\n  // Retry...\n}\n```\n\n### Issue: Timeout Errors\n**Cause**: No timeout on external requests\n**Solution**: Always set timeouts\n```typescript\nconst controller = new AbortController();\nconst timeout = setTimeout(() => controller.abort(), 30000);\n\ntry {\n  const response = await fetch(url, { signal: controller.signal });\n} finally {\n  clearTimeout(timeout);\n}\n```\n"
        },
        {
          "name": "tool-design.md",
          "type": "file",
          "path": "mcp-creator/references/tool-design.md",
          "size": 9990,
          "content": "# MCP Tool Design Patterns\n\n## Tool Naming Conventions\n\n### Action-Oriented Names\n```typescript\n// ✅ Good: verb_noun format\n\"get_user\"           // Read operation\n\"create_document\"    // Create operation\n\"update_settings\"    // Update operation\n\"delete_item\"        // Delete operation\n\"search_products\"    // Search operation\n\"analyze_sentiment\"  // Analysis operation\n\"validate_schema\"    // Validation operation\n\n// ❌ Bad: Vague or generic\n\"process\"            // What does it process?\n\"handle\"             // Handle what?\n\"data\"               // Not a verb\n\"user_stuff\"         // Informal\n```\n\n### Consistent Prefixes\n```typescript\n// CRUD operations\n\"create_*\", \"get_*\", \"list_*\", \"update_*\", \"delete_*\"\n\n// Bulk operations\n\"batch_create_*\", \"bulk_update_*\"\n\n// Search/filter\n\"search_*\", \"find_*\", \"filter_*\"\n\n// Analysis\n\"analyze_*\", \"compute_*\", \"calculate_*\"\n\n// Validation\n\"validate_*\", \"check_*\", \"verify_*\"\n```\n\n## Input Schema Patterns\n\n### Basic Types with Constraints\n```typescript\n{\n  type: \"object\",\n  properties: {\n    // String with length and pattern\n    username: {\n      type: \"string\",\n      minLength: 3,\n      maxLength: 50,\n      pattern: \"^[a-zA-Z0-9_-]+$\",\n      description: \"Username (alphanumeric, underscore, hyphen)\"\n    },\n\n    // Number with range\n    age: {\n      type: \"integer\",\n      minimum: 0,\n      maximum: 150,\n      description: \"User age in years\"\n    },\n\n    // Enum for fixed options\n    status: {\n      type: \"string\",\n      enum: [\"active\", \"inactive\", \"pending\"],\n      description: \"Account status\"\n    },\n\n    // Array with item constraints\n    tags: {\n      type: \"array\",\n      items: { type: \"string\", maxLength: 50 },\n      maxItems: 10,\n      uniqueItems: true,\n      description: \"Tags for categorization\"\n    },\n\n    // Boolean with default\n    sendNotification: {\n      type: \"boolean\",\n      default: true,\n      description: \"Whether to send notification\"\n    }\n  },\n  required: [\"username\"],\n  additionalProperties: false\n}\n```\n\n### Complex Object Schemas\n```typescript\n{\n  type: \"object\",\n  properties: {\n    filter: {\n      type: \"object\",\n      properties: {\n        dateRange: {\n          type: \"object\",\n          properties: {\n            start: { type: \"string\", format: \"date-time\" },\n            end: { type: \"string\", format: \"date-time\" }\n          },\n          required: [\"start\", \"end\"]\n        },\n        status: {\n          type: \"array\",\n          items: { type: \"string\", enum: [\"open\", \"closed\", \"pending\"] }\n        },\n        assignee: { type: \"string\" }\n      }\n    },\n    pagination: {\n      type: \"object\",\n      properties: {\n        page: { type: \"integer\", minimum: 1, default: 1 },\n        pageSize: { type: \"integer\", minimum: 1, maximum: 100, default: 20 }\n      }\n    },\n    sort: {\n      type: \"object\",\n      properties: {\n        field: { type: \"string\", enum: [\"created\", \"updated\", \"priority\"] },\n        direction: { type: \"string\", enum: [\"asc\", \"desc\"], default: \"desc\" }\n      }\n    }\n  }\n}\n```\n\n### Optional vs Required Fields\n```typescript\n// Make required fields explicit\n{\n  required: [\"userId\", \"action\"],  // Must be provided\n  properties: {\n    userId: { type: \"string\" },      // Required\n    action: { type: \"string\" },      // Required\n    reason: { type: \"string\" },      // Optional\n    notify: { type: \"boolean\", default: false }  // Optional with default\n  }\n}\n```\n\n## Output Format Patterns\n\n### Consistent Success Response\n```typescript\ninterface SuccessResponse<T> {\n  success: true;\n  data: T;\n  metadata?: {\n    requestId: string;\n    timestamp: string;\n    duration: number;\n  };\n}\n\n// Example\n{\n  success: true,\n  data: {\n    user: {\n      id: \"123\",\n      name: \"John\",\n      email: \"john@example.com\"\n    }\n  },\n  metadata: {\n    requestId: \"req-abc123\",\n    timestamp: \"2024-01-15T10:30:00Z\",\n    duration: 45\n  }\n}\n```\n\n### Consistent Error Response\n```typescript\ninterface ErrorResponse {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: Record<string, unknown>;\n  };\n  metadata?: {\n    requestId: string;\n    timestamp: string;\n  };\n}\n\n// Example\n{\n  success: false,\n  error: {\n    code: \"VALIDATION_ERROR\",\n    message: \"Invalid input parameters\",\n    details: {\n      field: \"email\",\n      issue: \"Invalid email format\"\n    }\n  },\n  metadata: {\n    requestId: \"req-xyz789\",\n    timestamp: \"2024-01-15T10:30:00Z\"\n  }\n}\n```\n\n### List Response with Pagination\n```typescript\ninterface ListResponse<T> {\n  success: true;\n  data: T[];\n  pagination: {\n    page: number;\n    pageSize: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrevious: boolean;\n  };\n}\n\n// Example\n{\n  success: true,\n  data: [\n    { id: \"1\", name: \"Item 1\" },\n    { id: \"2\", name: \"Item 2\" }\n  ],\n  pagination: {\n    page: 1,\n    pageSize: 20,\n    total: 157,\n    totalPages: 8,\n    hasNext: true,\n    hasPrevious: false\n  }\n}\n```\n\n## Tool Description Best Practices\n\n### Good Descriptions\n```typescript\n{\n  name: \"search_documents\",\n  description: `Search documents by content, metadata, or full-text query.\n\nSupports:\n- Full-text search across document content\n- Filtering by date range, author, tags\n- Pagination and sorting\n\nReturns matching documents with relevance scores.\n\nExample: Search for \"quarterly report\" in finance documents from 2024.`,\n\n  inputSchema: { /* ... */ }\n}\n```\n\n### Document Edge Cases\n```typescript\n{\n  name: \"delete_user\",\n  description: `Permanently delete a user and all associated data.\n\nWARNING: This action is irreversible.\n\nWhat gets deleted:\n- User profile\n- All user documents\n- Activity history\n- Preferences\n\nWhat is preserved:\n- Audit logs (for compliance)\n- Shared documents owned by others\n\nRequires: admin role or user deleting own account.`,\n\n  inputSchema: { /* ... */ }\n}\n```\n\n## Tool Grouping Strategies\n\n### By Domain\n```typescript\n// User management tools\n\"user_create\", \"user_get\", \"user_update\", \"user_delete\", \"user_list\"\n\n// Document tools\n\"document_create\", \"document_get\", \"document_search\", \"document_delete\"\n\n// Analytics tools\n\"analytics_get_summary\", \"analytics_get_trends\", \"analytics_export\"\n```\n\n### By Operation Type\n```typescript\n// Read-only tools (safe)\n\"get_*\", \"list_*\", \"search_*\", \"count_*\"\n\n// Write tools (mutating)\n\"create_*\", \"update_*\", \"delete_*\"\n\n// Dangerous tools (require extra confirmation)\n\"admin_*\", \"bulk_delete_*\", \"purge_*\"\n```\n\n## Idempotency Patterns\n\n### Idempotent Operations\n```typescript\n// GET operations are naturally idempotent\nasync function getUser(userId: string) {\n  return db.users.findById(userId);\n}\n\n// PUT/UPDATE can be idempotent with version checks\nasync function updateUser(userId: string, data: UserData, version: number) {\n  const result = await db.users.updateOne(\n    { _id: userId, version },\n    { $set: { ...data, version: version + 1 } }\n  );\n\n  if (result.modifiedCount === 0) {\n    throw new Error(\"Version conflict - retry with latest version\");\n  }\n}\n\n// DELETE is idempotent (deleting non-existent is OK)\nasync function deleteUser(userId: string) {\n  await db.users.deleteOne({ _id: userId });\n  return { deleted: true };  // Same result even if already deleted\n}\n```\n\n### Idempotency Keys for POST\n```typescript\nconst processedRequests = new Map<string, unknown>();\n\nasync function createOrder(\n  idempotencyKey: string,\n  orderData: OrderData\n): Promise<Order> {\n  // Check if already processed\n  if (processedRequests.has(idempotencyKey)) {\n    return processedRequests.get(idempotencyKey) as Order;\n  }\n\n  // Process the order\n  const order = await db.orders.create(orderData);\n\n  // Cache result\n  processedRequests.set(idempotencyKey, order);\n\n  // Cleanup old keys after 24 hours\n  setTimeout(() => processedRequests.delete(idempotencyKey), 86400000);\n\n  return order;\n}\n```\n\n## Batch Operation Patterns\n\n### Batch with Individual Results\n```typescript\ninterface BatchResult<T> {\n  success: true;\n  results: Array<{\n    id: string;\n    status: \"success\" | \"error\";\n    data?: T;\n    error?: string;\n  }>;\n  summary: {\n    total: number;\n    succeeded: number;\n    failed: number;\n  };\n}\n\n// Example response\n{\n  success: true,\n  results: [\n    { id: \"1\", status: \"success\", data: { /* ... */ } },\n    { id: \"2\", status: \"error\", error: \"Not found\" },\n    { id: \"3\", status: \"success\", data: { /* ... */ } }\n  ],\n  summary: {\n    total: 3,\n    succeeded: 2,\n    failed: 1\n  }\n}\n```\n\n### Batch with Atomic Rollback\n```typescript\nasync function batchCreateWithRollback(items: Item[]): Promise<BatchResult> {\n  const session = await db.startSession();\n  session.startTransaction();\n\n  try {\n    const results = [];\n    for (const item of items) {\n      const created = await db.items.create([item], { session });\n      results.push(created[0]);\n    }\n\n    await session.commitTransaction();\n    return { success: true, data: results };\n  } catch (error) {\n    await session.abortTransaction();\n    throw error;\n  } finally {\n    session.endSession();\n  }\n}\n```\n\n## Progress Reporting for Long Operations\n\n### Streaming Progress\n```typescript\n{\n  name: \"process_large_file\",\n  description: \"Process a large file with progress updates\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      fileId: { type: \"string\" },\n      includeProgress: { type: \"boolean\", default: true }\n    }\n  }\n}\n\n// Response with progress\n{\n  success: true,\n  data: {\n    status: \"processing\",\n    progress: {\n      current: 45000,\n      total: 100000,\n      percentage: 45,\n      estimatedTimeRemaining: \"2 minutes\"\n    }\n  }\n}\n```\n\n### Job-Based Pattern\n```typescript\n// Start job\n{\n  name: \"start_export_job\",\n  description: \"Start an async export job\",\n}\n// Returns: { jobId: \"job-123\" }\n\n// Check status\n{\n  name: \"get_job_status\",\n  description: \"Check status of an async job\",\n}\n// Returns: { jobId: \"job-123\", status: \"running\", progress: 75 }\n\n// Get result\n{\n  name: \"get_job_result\",\n  description: \"Get result of completed job\",\n}\n// Returns: { jobId: \"job-123\", status: \"completed\", result: { ... } }\n```\n"
        }
      ]
    },
    {
      "name": "templates",
      "type": "folder",
      "path": "mcp-creator/templates",
      "children": [
        {
          "name": "authenticated-api.ts",
          "type": "file",
          "path": "mcp-creator/templates/authenticated-api.ts",
          "size": 12063,
          "content": "#!/usr/bin/env node\n/**\n * Authenticated API MCP Server Template\n *\n * Production-ready MCP server for external API integration with:\n * - Secure credential management\n * - Rate limiting\n * - Retry with exponential backoff\n * - Response caching\n * - Comprehensive error handling\n *\n * Usage:\n * 1. Set environment variables (API_KEY, API_BASE_URL)\n * 2. Customize the API client methods\n * 3. Add your tool definitions\n */\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  ErrorCode,\n  McpError,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { z } from \"zod\";\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\ninterface Config {\n  name: string;\n  version: string;\n  apiBaseUrl: string;\n  apiKey: string;\n  rateLimitPerMinute: number;\n  cacheTtlMs: number;\n  maxRetries: number;\n  timeoutMs: number;\n}\n\nfunction loadConfig(): Config {\n  const apiKey = process.env.API_KEY;\n  const apiBaseUrl = process.env.API_BASE_URL;\n\n  if (!apiKey) {\n    throw new Error(\"API_KEY environment variable is required\");\n  }\n\n  if (!apiBaseUrl) {\n    throw new Error(\"API_BASE_URL environment variable is required\");\n  }\n\n  return {\n    name: \"authenticated-api-mcp\",\n    version: \"1.0.0\",\n    apiBaseUrl,\n    apiKey,\n    rateLimitPerMinute: parseInt(process.env.RATE_LIMIT || \"60\"),\n    cacheTtlMs: parseInt(process.env.CACHE_TTL_MS || \"300000\"), // 5 min\n    maxRetries: parseInt(process.env.MAX_RETRIES || \"3\"),\n    timeoutMs: parseInt(process.env.TIMEOUT_MS || \"30000\"), // 30 sec\n  };\n}\n\nconst CONFIG = loadConfig();\n\n// =============================================================================\n// Rate Limiter\n// =============================================================================\n\nclass RateLimiter {\n  private requests: number[] = [];\n\n  canProceed(): boolean {\n    const now = Date.now();\n    const windowStart = now - 60000; // 1 minute window\n\n    // Remove old requests\n    this.requests = this.requests.filter(t => t > windowStart);\n\n    if (this.requests.length >= CONFIG.rateLimitPerMinute) {\n      return false;\n    }\n\n    this.requests.push(now);\n    return true;\n  }\n\n  getWaitTime(): number {\n    if (this.requests.length === 0) return 0;\n\n    const oldestInWindow = Math.min(...this.requests);\n    const windowEnd = oldestInWindow + 60000;\n    return Math.max(0, windowEnd - Date.now());\n  }\n}\n\nconst rateLimiter = new RateLimiter();\n\n// =============================================================================\n// Cache\n// =============================================================================\n\ninterface CacheEntry<T> {\n  value: T;\n  expires: number;\n}\n\nclass Cache<T> {\n  private store = new Map<string, CacheEntry<T>>();\n\n  get(key: string): T | undefined {\n    const entry = this.store.get(key);\n    if (!entry) return undefined;\n\n    if (Date.now() > entry.expires) {\n      this.store.delete(key);\n      return undefined;\n    }\n\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttlMs: number = CONFIG.cacheTtlMs): void {\n    this.store.set(key, {\n      value,\n      expires: Date.now() + ttlMs,\n    });\n  }\n\n  clear(): void {\n    this.store.clear();\n  }\n}\n\nconst responseCache = new Cache<unknown>();\n\n// =============================================================================\n// API Client\n// =============================================================================\n\ninterface ApiError {\n  status: number;\n  message: string;\n  retryable: boolean;\n}\n\nasync function apiRequest<T>(\n  endpoint: string,\n  options: {\n    method?: string;\n    body?: unknown;\n    useCache?: boolean;\n    cacheKey?: string;\n  } = {}\n): Promise<T> {\n  const { method = \"GET\", body, useCache = true, cacheKey } = options;\n\n  // Check cache for GET requests\n  const cacheKeyFinal = cacheKey || `${method}:${endpoint}`;\n  if (useCache && method === \"GET\") {\n    const cached = responseCache.get(cacheKeyFinal);\n    if (cached) {\n      console.error(`Cache hit: ${cacheKeyFinal}`);\n      return cached as T;\n    }\n  }\n\n  // Check rate limit\n  if (!rateLimiter.canProceed()) {\n    const waitTime = rateLimiter.getWaitTime();\n    throw new McpError(\n      ErrorCode.InvalidRequest,\n      `Rate limit exceeded. Retry after ${Math.ceil(waitTime / 1000)} seconds.`\n    );\n  }\n\n  // Retry logic\n  let lastError: ApiError | null = null;\n\n  for (let attempt = 0; attempt <= CONFIG.maxRetries; attempt++) {\n    try {\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), CONFIG.timeoutMs);\n\n      const response = await fetch(`${CONFIG.apiBaseUrl}${endpoint}`, {\n        method,\n        headers: {\n          \"Authorization\": `Bearer ${CONFIG.apiKey}`,\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `${CONFIG.name}/${CONFIG.version}`,\n        },\n        body: body ? JSON.stringify(body) : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeout);\n\n      if (!response.ok) {\n        const errorBody = await response.text();\n        lastError = {\n          status: response.status,\n          message: errorBody,\n          retryable: response.status >= 500 || response.status === 429,\n        };\n\n        if (!lastError.retryable) {\n          break; // Don't retry client errors\n        }\n\n        // Handle rate limit from API\n        if (response.status === 429) {\n          const retryAfter = response.headers.get(\"Retry-After\");\n          const waitMs = retryAfter\n            ? parseInt(retryAfter) * 1000\n            : Math.min(1000 * Math.pow(2, attempt), 30000);\n\n          console.error(`Rate limited by API, waiting ${waitMs}ms...`);\n          await new Promise(r => setTimeout(r, waitMs));\n          continue;\n        }\n\n        // Exponential backoff for server errors\n        const backoffMs = Math.min(1000 * Math.pow(2, attempt), 30000);\n        console.error(`Request failed (attempt ${attempt + 1}), retrying in ${backoffMs}ms...`);\n        await new Promise(r => setTimeout(r, backoffMs));\n        continue;\n      }\n\n      const data = await response.json();\n\n      // Cache successful GET responses\n      if (useCache && method === \"GET\") {\n        responseCache.set(cacheKeyFinal, data);\n      }\n\n      return data as T;\n    } catch (error) {\n      if (error instanceof Error && error.name === \"AbortError\") {\n        lastError = {\n          status: 0,\n          message: \"Request timeout\",\n          retryable: true,\n        };\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  // All retries exhausted\n  throw new McpError(\n    lastError?.status === 401 || lastError?.status === 403\n      ? ErrorCode.InvalidRequest\n      : ErrorCode.InternalError,\n    `API request failed: ${lastError?.message || \"Unknown error\"}`\n  );\n}\n\n// =============================================================================\n// Input Schemas\n// =============================================================================\n\nconst GetResourceSchema = z.object({\n  resourceId: z.string().min(1).max(100),\n  includeDetails: z.boolean().default(false),\n});\n\nconst SearchResourcesSchema = z.object({\n  query: z.string().min(1).max(500),\n  limit: z.number().int().min(1).max(100).default(20),\n  offset: z.number().int().min(0).default(0),\n});\n\nconst CreateResourceSchema = z.object({\n  name: z.string().min(1).max(200),\n  data: z.record(z.unknown()),\n});\n\n// =============================================================================\n// Tool Implementations\n// =============================================================================\n\ninterface Resource {\n  id: string;\n  name: string;\n  data: Record<string, unknown>;\n}\n\ninterface SearchResult {\n  items: Resource[];\n  total: number;\n}\n\nasync function getResource(args: z.infer<typeof GetResourceSchema>): Promise<Resource> {\n  return apiRequest<Resource>(`/resources/${args.resourceId}`);\n}\n\nasync function searchResources(args: z.infer<typeof SearchResourcesSchema>): Promise<SearchResult> {\n  const params = new URLSearchParams({\n    q: args.query,\n    limit: args.limit.toString(),\n    offset: args.offset.toString(),\n  });\n\n  return apiRequest<SearchResult>(`/resources/search?${params}`);\n}\n\nasync function createResource(args: z.infer<typeof CreateResourceSchema>): Promise<Resource> {\n  return apiRequest<Resource>(\"/resources\", {\n    method: \"POST\",\n    body: args,\n    useCache: false,\n  });\n}\n\n// =============================================================================\n// Tool Definitions\n// =============================================================================\n\nconst TOOLS = [\n  {\n    name: \"get_resource\",\n    description: \"Get a resource by ID\",\n    inputSchema: {\n      type: \"object\" as const,\n      properties: {\n        resourceId: { type: \"string\", description: \"Resource ID\" },\n        includeDetails: { type: \"boolean\", default: false },\n      },\n      required: [\"resourceId\"],\n    },\n  },\n  {\n    name: \"search_resources\",\n    description: \"Search resources by query\",\n    inputSchema: {\n      type: \"object\" as const,\n      properties: {\n        query: { type: \"string\", description: \"Search query\" },\n        limit: { type: \"integer\", minimum: 1, maximum: 100, default: 20 },\n        offset: { type: \"integer\", minimum: 0, default: 0 },\n      },\n      required: [\"query\"],\n    },\n  },\n  {\n    name: \"create_resource\",\n    description: \"Create a new resource\",\n    inputSchema: {\n      type: \"object\" as const,\n      properties: {\n        name: { type: \"string\", description: \"Resource name\" },\n        data: { type: \"object\", description: \"Resource data\" },\n      },\n      required: [\"name\", \"data\"],\n    },\n  },\n  {\n    name: \"clear_cache\",\n    description: \"Clear the response cache\",\n    inputSchema: { type: \"object\" as const, properties: {} },\n  },\n];\n\n// =============================================================================\n// Server Setup\n// =============================================================================\n\nconst server = new Server(\n  { name: CONFIG.name, version: CONFIG.version },\n  { capabilities: { tools: {} } }\n);\n\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: TOOLS,\n}));\n\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n\n  try {\n    let result: unknown;\n\n    switch (name) {\n      case \"get_resource\":\n        result = await getResource(GetResourceSchema.parse(args));\n        break;\n\n      case \"search_resources\":\n        result = await searchResources(SearchResourcesSchema.parse(args));\n        break;\n\n      case \"create_resource\":\n        result = await createResource(CreateResourceSchema.parse(args));\n        break;\n\n      case \"clear_cache\":\n        responseCache.clear();\n        result = { success: true, message: \"Cache cleared\" };\n        break;\n\n      default:\n        throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: JSON.stringify(result, null, 2) }],\n    };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new McpError(\n        ErrorCode.InvalidParams,\n        `Validation error: ${error.errors.map(e => `${e.path}: ${e.message}`).join(\", \")}`\n      );\n    }\n    throw error;\n  }\n});\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\nasync function main() {\n  console.error(`Starting ${CONFIG.name} v${CONFIG.version}`);\n  console.error(`API: ${CONFIG.apiBaseUrl}`);\n  console.error(`Rate limit: ${CONFIG.rateLimitPerMinute}/min`);\n\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n\n  console.error(\"Server running on stdio\");\n}\n\nmain().catch((error) => {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n"
        },
        {
          "name": "basic-server.ts",
          "type": "file",
          "path": "mcp-creator/templates/basic-server.ts",
          "size": 7157,
          "content": "#!/usr/bin/env node\n/**\n * Basic MCP Server Template\n *\n * A minimal, production-ready MCP server with:\n * - Proper error handling\n * - Input validation\n * - Structured logging\n * - Graceful shutdown\n *\n * Usage:\n * 1. Copy this template\n * 2. Add your tools in the tools array\n * 3. Implement tool handlers in the switch statement\n * 4. Run with: node dist/index.js\n */\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ErrorCode,\n  McpError,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { z } from \"zod\";\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nconst CONFIG = {\n  name: \"my-mcp-server\",\n  version: \"1.0.0\",\n  description: \"Description of your MCP server\",\n};\n\n// =============================================================================\n// Input Schemas (Zod)\n// =============================================================================\n\nconst ExampleToolSchema = z.object({\n  input: z.string().min(1).max(10000),\n  options: z.object({\n    format: z.enum([\"json\", \"text\"]).default(\"json\"),\n    verbose: z.boolean().default(false),\n  }).optional(),\n});\n\n// =============================================================================\n// Tool Definitions\n// =============================================================================\n\nconst TOOLS = [\n  {\n    name: \"example_tool\",\n    description: `Example tool that processes input.\n\nFeatures:\n- Validates input\n- Returns structured output\n- Supports JSON and text formats`,\n    inputSchema: {\n      type: \"object\" as const,\n      properties: {\n        input: {\n          type: \"string\",\n          description: \"Input to process\",\n        },\n        options: {\n          type: \"object\",\n          properties: {\n            format: {\n              type: \"string\",\n              enum: [\"json\", \"text\"],\n              default: \"json\",\n            },\n            verbose: {\n              type: \"boolean\",\n              default: false,\n            },\n          },\n        },\n      },\n      required: [\"input\"],\n    },\n  },\n  {\n    name: \"health_check\",\n    description: \"Check server health and status\",\n    inputSchema: {\n      type: \"object\" as const,\n      properties: {},\n    },\n  },\n];\n\n// =============================================================================\n// Tool Implementations\n// =============================================================================\n\nasync function handleExampleTool(args: z.infer<typeof ExampleToolSchema>) {\n  // Your implementation here\n  const result = {\n    processed: args.input.toUpperCase(),\n    length: args.input.length,\n    timestamp: new Date().toISOString(),\n  };\n\n  if (args.options?.format === \"text\") {\n    return `Processed: ${result.processed} (${result.length} chars)`;\n  }\n\n  return result;\n}\n\nasync function handleHealthCheck() {\n  return {\n    status: \"healthy\",\n    version: CONFIG.version,\n    uptime: process.uptime(),\n    timestamp: new Date().toISOString(),\n  };\n}\n\n// =============================================================================\n// Server Setup\n// =============================================================================\n\nconst server = new Server(\n  {\n    name: CONFIG.name,\n    version: CONFIG.version,\n  },\n  {\n    capabilities: {\n      tools: {},\n      resources: {},\n    },\n  }\n);\n\n// =============================================================================\n// Request Handlers\n// =============================================================================\n\n// List available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: TOOLS,\n}));\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n  const startTime = Date.now();\n\n  try {\n    let result: unknown;\n\n    switch (name) {\n      case \"example_tool\": {\n        const validated = ExampleToolSchema.parse(args);\n        result = await handleExampleTool(validated);\n        break;\n      }\n\n      case \"health_check\": {\n        result = await handleHealthCheck();\n        break;\n      }\n\n      default:\n        throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n    }\n\n    const duration = Date.now() - startTime;\n    console.error(`Tool ${name} completed in ${duration}ms`);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: typeof result === \"string\"\n            ? result\n            : JSON.stringify(result, null, 2),\n        },\n      ],\n    };\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    console.error(`Tool ${name} failed after ${duration}ms:`, error);\n\n    if (error instanceof z.ZodError) {\n      throw new McpError(\n        ErrorCode.InvalidParams,\n        `Validation error: ${error.errors.map(e => e.message).join(\", \")}`\n      );\n    }\n\n    if (error instanceof McpError) {\n      throw error;\n    }\n\n    throw new McpError(\n      ErrorCode.InternalError,\n      error instanceof Error ? error.message : \"Unknown error\"\n    );\n  }\n});\n\n// List resources (optional)\nserver.setRequestHandler(ListResourcesRequestSchema, async () => ({\n  resources: [\n    {\n      uri: `${CONFIG.name}://status`,\n      name: \"Server Status\",\n      description: \"Current server status and configuration\",\n      mimeType: \"application/json\",\n    },\n  ],\n}));\n\n// Read resources (optional)\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  const { uri } = request.params;\n\n  if (uri === `${CONFIG.name}://status`) {\n    return {\n      contents: [\n        {\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({\n            name: CONFIG.name,\n            version: CONFIG.version,\n            status: \"running\",\n            uptime: process.uptime(),\n          }, null, 2),\n        },\n      ],\n    };\n  }\n\n  throw new McpError(ErrorCode.InvalidRequest, `Unknown resource: ${uri}`);\n});\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nfunction shutdown(signal: string) {\n  console.error(`Received ${signal}, shutting down...`);\n  // Add cleanup logic here (close connections, etc.)\n  process.exit(0);\n}\n\nprocess.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\nasync function main() {\n  console.error(`Starting ${CONFIG.name} v${CONFIG.version}...`);\n\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n\n  console.error(`${CONFIG.name} running on stdio`);\n}\n\nmain().catch((error) => {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "mcp-creator/CHANGELOG.md",
      "size": 1103,
      "content": "# Changelog\n\nAll notable changes to the MCP Creator skill will be documented in this file.\n\n## [1.0.0] - 2024-12-15\n\n### Added\n- Initial release of MCP Creator skill\n- Core SKILL.md with MCP architecture overview, tool design patterns, and security hardening\n- Reference documentation:\n  - `architecture-patterns.md` - Transport layers, lifecycle, resource management\n  - `security-hardening.md` - OWASP-aligned security checklist, input validation, rate limiting\n  - `tool-design.md` - Naming conventions, schema patterns, output formats\n  - `testing-debugging.md` - Testing strategies, debugging techniques, common issues\n- Production-ready templates:\n  - `basic-server.ts` - Minimal server with proper structure\n  - `authenticated-api.ts` - Full API integration with auth, caching, rate limiting\n\n### Security\n- Comprehensive input validation patterns using Zod\n- Secret management best practices\n- Rate limiting implementation examples\n- OWASP Top 10 mitigations\n\n### Documentation\n- Decision tree for when to use MCP vs Script vs Agent\n- Anti-patterns section with examples\n- Success metrics table\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "mcp-creator/SKILL.md",
      "size": 14974,
      "content": "---\nname: mcp-creator\ndescription: Expert MCP (Model Context Protocol) server developer creating safe, performant, production-ready servers with proper security, error handling, and developer experience. Activate on 'create MCP', 'MCP server', 'build MCP', 'custom tool server', 'MCP development', 'Model Context Protocol'. NOT for using existing MCPs (just invoke them), general API development (use backend-architect), or skills/agents without external state (use skill-coach/agent-creator).\nallowed-tools: Read,Write,Edit,Bash,Grep,Glob,WebSearch,WebFetch\ncategory: Productivity & Meta\ntags:\n  - mcp\n  - model-context-protocol\n  - tools\n  - integration\n  - servers\npairs-with:\n  - skill: agent-creator\n    reason: Skills that use the MCP tools\n  - skill: security-auditor\n    reason: Secure MCP server development\n---\n\n# MCP Creator\n\nExpert in building production-ready Model Context Protocol servers. Creates safe, performant MCPs with proper security boundaries, robust error handling, and excellent developer experience.\n\n## When to Use This Skill\n\n**Use MCP when you need:**\n- External API integration with authentication\n- Stateful connections (databases, WebSockets, sessions)\n- Multiple related tools sharing configuration\n- Security boundaries between Claude and external services\n- Connection pooling and resource management\n\n**Do NOT use MCP for:**\n- Pure domain expertise (use Skill)\n- Multi-step orchestration (use Agent)\n- Local stateless operations (use Script)\n- Simple file processing (use Claude's built-in tools)\n\n## Quick Start\n\n```bash\n# Scaffold new MCP server\nnpx @modelcontextprotocol/create-server my-mcp-server\n\n# Install SDK\nnpm install @modelcontextprotocol/sdk\n\n# Test with inspector\nnpx @modelcontextprotocol/inspector\n```\n\n## MCP Architecture Overview\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                        Claude                               │\n└─────────────────────────┬───────────────────────────────────┘\n                          │ MCP Protocol (JSON-RPC)\n┌─────────────────────────┴───────────────────────────────────┐\n│                    MCP Server                               │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │\n│  │   Tools     │  │  Resources  │  │     Prompts         │ │\n│  │ (actions)   │  │ (read-only) │  │ (templates)         │ │\n│  └─────────────┘  └─────────────┘  └─────────────────────┘ │\n│                          │                                  │\n│  ┌───────────────────────┴──────────────────────────────┐  │\n│  │           Auth / Rate Limiting / Caching              │  │\n│  └───────────────────────┬──────────────────────────────┘  │\n└──────────────────────────┼──────────────────────────────────┘\n                           │\n┌──────────────────────────┴──────────────────────────────────┐\n│                    External Services                         │\n│         APIs │ Databases │ File Systems │ WebSockets         │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Core MCP Server Template\n\n```typescript\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  ErrorCode,\n  McpError,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nconst server = new Server(\n  { name: \"my-mcp-server\", version: \"1.0.0\" },\n  { capabilities: { tools: {} } }\n);\n\n// Tool definitions\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: [\n    {\n      name: \"my_tool\",\n      description: \"Clear description of what this tool does\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          input: { type: \"string\", description: \"Input description\" },\n        },\n        required: [\"input\"],\n      },\n    },\n  ],\n}));\n\n// Tool implementation\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"my_tool\") {\n    try {\n      const result = await processInput(args.input);\n      return { content: [{ type: \"text\", text: JSON.stringify(result) }] };\n    } catch (error) {\n      throw new McpError(ErrorCode.InternalError, error.message);\n    }\n  }\n\n  throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n});\n\n// Start server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n## Tool Design Principles\n\n### 1. Clear Naming\n```typescript\n// ✅ Good: Action-oriented, specific\n\"get_user_profile\"\n\"create_issue\"\n\"analyze_sentiment\"\n\n// ❌ Bad: Vague, generic\n\"process\"\n\"do_thing\"\n\"handle\"\n```\n\n### 2. Precise Input Schemas\n```typescript\n// ✅ Good: Typed, constrained, documented\n{\n  type: \"object\",\n  properties: {\n    userId: { type: \"string\", pattern: \"^[a-f0-9]{24}$\" },\n    action: { type: \"string\", enum: [\"read\", \"write\", \"delete\"] },\n    limit: { type: \"integer\", minimum: 1, maximum: 100, default: 10 }\n  },\n  required: [\"userId\", \"action\"],\n  additionalProperties: false\n}\n\n// ❌ Bad: Untyped, unconstrained\n{ type: \"object\" }\n```\n\n### 3. Structured Outputs\n```typescript\n// ✅ Good: Consistent structure\nreturn {\n  content: [{\n    type: \"text\",\n    text: JSON.stringify({\n      success: true,\n      data: result,\n      metadata: { requestId, timestamp }\n    }, null, 2)\n  }]\n};\n\n// ❌ Bad: Inconsistent, unstructured\nreturn { content: [{ type: \"text\", text: \"done\" }] };\n```\n\n## Security Hardening (CRITICAL)\n\n### Input Validation\n```typescript\nimport { z } from \"zod\";\n\nconst UserInputSchema = z.object({\n  userId: z.string().regex(/^[a-f0-9]{24}$/),\n  email: z.string().email(),\n  query: z.string().max(1000).refine(\n    (q) => !q.includes(\"--\") && !q.includes(\";\"),\n    { message: \"Invalid characters in query\" }\n  ),\n});\n\nasync function handleTool(args: unknown) {\n  const validated = UserInputSchema.parse(args); // Throws on invalid\n  // Safe to use validated data\n}\n```\n\n### Secret Management\n```typescript\n// ✅ Good: Environment variables\nconst API_KEY = process.env.SERVICE_API_KEY;\nif (!API_KEY) throw new Error(\"SERVICE_API_KEY required\");\n\n// ✅ Good: Secret manager integration\nconst secret = await secretManager.getSecret(\"service-api-key\");\n\n// ❌ NEVER: Hardcoded secrets\nconst API_KEY = \"sk-abc123...\"; // SECURITY VULNERABILITY\n```\n\n### Rate Limiting\n```typescript\nclass RateLimiter {\n  private requests: Map<string, number[]> = new Map();\n\n  canProceed(key: string, limit: number, windowMs: number): boolean {\n    const now = Date.now();\n    const timestamps = this.requests.get(key) || [];\n    const recent = timestamps.filter(t => now - t < windowMs);\n\n    if (recent.length >= limit) return false;\n\n    recent.push(now);\n    this.requests.set(key, recent);\n    return true;\n  }\n}\n\nconst limiter = new RateLimiter();\n\n// In tool handler\nif (!limiter.canProceed(userId, 100, 60000)) {\n  throw new McpError(ErrorCode.InvalidRequest, \"Rate limit exceeded\");\n}\n```\n\n### Authentication Boundaries\n```typescript\n// Validate credentials before any operation\nasync function withAuth<T>(\n  credentials: Credentials,\n  operation: () => Promise<T>\n): Promise<T> {\n  if (!await validateCredentials(credentials)) {\n    throw new McpError(ErrorCode.InvalidRequest, \"Invalid credentials\");\n  }\n  return operation();\n}\n```\n\n## Error Handling Patterns\n\n### Structured Error Responses\n```typescript\n// Define error types\nenum ServiceError {\n  NOT_FOUND = \"NOT_FOUND\",\n  UNAUTHORIZED = \"UNAUTHORIZED\",\n  RATE_LIMITED = \"RATE_LIMITED\",\n  VALIDATION_ERROR = \"VALIDATION_ERROR\",\n  EXTERNAL_SERVICE_ERROR = \"EXTERNAL_SERVICE_ERROR\",\n}\n\n// Map to MCP errors\nfunction toMcpError(error: unknown): McpError {\n  if (error instanceof z.ZodError) {\n    return new McpError(\n      ErrorCode.InvalidParams,\n      `Validation error: ${error.errors.map(e => e.message).join(\", \")}`\n    );\n  }\n\n  if (error instanceof ServiceError) {\n    return new McpError(ErrorCode.InternalError, error.message);\n  }\n\n  return new McpError(ErrorCode.InternalError, \"Unknown error occurred\");\n}\n```\n\n### Graceful Degradation\n```typescript\nasync function fetchWithFallback<T>(\n  primary: () => Promise<T>,\n  fallback: () => Promise<T>,\n  options: { retries?: number; timeout?: number } = {}\n): Promise<T> {\n  const { retries = 3, timeout = 5000 } = options;\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await Promise.race([\n        primary(),\n        new Promise<never>((_, reject) =>\n          setTimeout(() => reject(new Error(\"Timeout\")), timeout)\n        ),\n      ]);\n    } catch (error) {\n      if (i === retries - 1) {\n        console.error(\"Primary failed, trying fallback:\", error);\n        return fallback();\n      }\n      await new Promise(r => setTimeout(r, 1000 * (i + 1))); // Backoff\n    }\n  }\n  throw new Error(\"All retries exhausted\");\n}\n```\n\n## Performance Optimization\n\n### Connection Pooling\n```typescript\n// PostgreSQL pool\nimport { Pool } from \"pg\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n});\n\n// Reuse connections\nasync function query(sql: string, params: unknown[]) {\n  const client = await pool.connect();\n  try {\n    return await client.query(sql, params);\n  } finally {\n    client.release();\n  }\n}\n```\n\n### Caching Layer\n```typescript\nclass Cache<T> {\n  private store: Map<string, { value: T; expires: number }> = new Map();\n\n  get(key: string): T | undefined {\n    const entry = this.store.get(key);\n    if (!entry) return undefined;\n    if (Date.now() > entry.expires) {\n      this.store.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttlMs: number): void {\n    this.store.set(key, { value, expires: Date.now() + ttlMs });\n  }\n}\n\nconst cache = new Cache<ApiResponse>();\n\nasync function fetchWithCache(url: string): Promise<ApiResponse> {\n  const cached = cache.get(url);\n  if (cached) return cached;\n\n  const response = await fetch(url);\n  const data = await response.json();\n  cache.set(url, data, 300000); // 5 min TTL\n  return data;\n}\n```\n\n## Anti-Patterns\n\n### Anti-Pattern: No Input Validation\n**What it looks like**: Passing user input directly to APIs/databases\n**Why wrong**: SQL injection, command injection, data corruption\n**Instead**: Validate with Zod, sanitize inputs, use parameterized queries\n\n### Anti-Pattern: Secrets in Code\n**What it looks like**: Hardcoded API keys, tokens in source\n**Why wrong**: Secrets leak via git, logs, error messages\n**Instead**: Environment variables, secret managers, encrypted config\n\n### Anti-Pattern: No Rate Limiting\n**What it looks like**: Unlimited API calls to external services\n**Why wrong**: Cost explosion, API bans, resource exhaustion\n**Instead**: Token bucket, sliding window, or adaptive rate limiting\n\n### Anti-Pattern: Synchronous Blocking\n**What it looks like**: `sleep()`, blocking I/O in async handlers\n**Why wrong**: Blocks all requests, causes timeouts\n**Instead**: Proper async/await, non-blocking patterns\n\n### Anti-Pattern: Silent Failures\n**What it looks like**: Empty catch blocks, swallowed errors\n**Why wrong**: Debugging impossible, data corruption undetected\n**Instead**: Structured error handling, logging, proper propagation\n\n### Anti-Pattern: No Timeouts\n**What it looks like**: Waiting indefinitely for external services\n**Why wrong**: Hung connections, resource leaks\n**Instead**: Explicit timeouts on all external calls, circuit breakers\n\n## Testing Your MCP\n\n### Using MCP Inspector\n```bash\n# Start inspector\nnpx @modelcontextprotocol/inspector\n\n# In another terminal, start your server\nnode dist/index.js\n\n# Connect inspector to your server\n# Test tool invocations manually\n```\n\n### Unit Testing\n```typescript\nimport { describe, it, expect } from \"vitest\";\n\ndescribe(\"my_tool\", () => {\n  it(\"should validate input\", async () => {\n    await expect(\n      handleTool({ userId: \"invalid\" })\n    ).rejects.toThrow(\"Invalid userId format\");\n  });\n\n  it(\"should return structured output\", async () => {\n    const result = await handleTool({ userId: \"507f1f77bcf86cd799439011\" });\n    expect(result).toHaveProperty(\"success\", true);\n    expect(result).toHaveProperty(\"data\");\n  });\n});\n```\n\n## Decision Tree: When to Add to MCP\n\n```\nDoes this tool need...\n├── External API with auth? → Add to MCP\n├── Persistent state/connection? → Add to MCP\n├── Rate limiting for external service? → Add to MCP\n├── Shared credentials with other tools? → Add to MCP\n├── Security boundary from Claude? → Add to MCP\n└── None of the above? → Consider Script instead\n```\n\n## Success Metrics\n\n| Metric | Target |\n|--------|--------|\n| Tool latency P95 | &lt; 500ms |\n| Error rate | &lt; 1% |\n| Input validation coverage | 100% |\n| Secret exposure | 0 |\n| Rate limit violations | 0 |\n\n## Reference Files\n\n| File | Contents |\n|------|----------|\n| `references/architecture-patterns.md` | Transport layers, server lifecycle, resource management |\n| `references/tool-design.md` | Schema patterns, naming conventions, output formats |\n| `references/security-hardening.md` | Complete OWASP-aligned security checklist |\n| `references/error-handling.md` | Error types, recovery strategies, logging |\n| `references/testing-debugging.md` | Inspector usage, unit/integration tests |\n| `references/performance.md` | Caching, pooling, async patterns |\n| `templates/` | Production-ready server templates |\n\n---\n\n**Creates**: Safe, performant MCP servers | Robust tool interfaces | Security-hardened integrations\n\n**Use with**: security-auditor (security review) | site-reliability-engineer (deployment) | agent-creator (when MCP supports agents)\n"
    }
  ]
}