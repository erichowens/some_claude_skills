{
  "name": "bot-developer",
  "type": "folder",
  "path": "bot-developer",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "bot-developer/references",
      "children": [
        {
          "name": "architecture-patterns.md",
          "type": "file",
          "path": "bot-developer/references/architecture-patterns.md",
          "size": 7261,
          "content": "# Architecture Patterns\n\nEvent-driven architecture and state machine patterns for production bots.\n\n## Event-Driven Bot Architecture\n\n```\n                         ┌─────────────────────────────────┐\n                         │         Message Broker          │\n                         │   (Redis Streams / RabbitMQ)    │\n                         └──────────────┬──────────────────┘\n                                        │\n        ┌───────────────────────────────┼───────────────────────────────┐\n        │                               │                               │\n        ▼                               ▼                               ▼\n┌───────────────┐              ┌───────────────┐              ┌───────────────┐\n│  Command      │              │   Event       │              │  Scheduled    │\n│  Processor    │              │   Handler     │              │  Task Runner  │\n│               │              │               │              │               │\n│ /cmd parsing  │              │ on_message    │              │ cron jobs     │\n│ validation    │              │ on_reaction   │              │ reminders     │\n│ permissions   │              │ on_join       │              │ cleanups      │\n└───────┬───────┘              └───────┬───────┘              └───────┬───────┘\n        │                               │                               │\n        └───────────────────────────────┼───────────────────────────────┘\n                                        │\n                                        ▼\n                         ┌─────────────────────────────────┐\n                         │        Service Layer            │\n                         │                                 │\n                         │  ┌─────────┐  ┌─────────────┐  │\n                         │  │ User    │  │ Moderation  │  │\n                         │  │ Service │  │ Service     │  │\n                         │  └─────────┘  └─────────────┘  │\n                         │  ┌─────────┐  ┌─────────────┐  │\n                         │  │ Economy │  │ Integration │  │\n                         │  │ Service │  │ Service     │  │\n                         │  └─────────┘  └─────────────┘  │\n                         └──────────────┬──────────────────┘\n                                        │\n                                        ▼\n                         ┌─────────────────────────────────┐\n                         │        Data Layer               │\n                         │  PostgreSQL + Redis + S3        │\n                         └─────────────────────────────────┘\n```\n\n## State Machine for Conversations\n\n```python\nfrom enum import Enum, auto\nfrom typing import Callable, Optional\nimport asyncio\n\nclass State(Enum):\n    IDLE = auto()\n    AWAITING_CONFIRMATION = auto()\n    COLLECTING_INPUT = auto()\n    PROCESSING = auto()\n    ERROR = auto()\n\nclass ConversationStateMachine:\n    \"\"\"\n    Finite state machine for managing multi-turn conversations.\n    Prevents race conditions and ensures clean state transitions.\n    \"\"\"\n\n    def __init__(self, user_id: str, timeout: float = 300):\n        self.user_id = user_id\n        self.state = State.IDLE\n        self.context: dict = {}\n        self.timeout = timeout\n        self._timeout_task: Optional[asyncio.Task] = None\n        self._transitions: dict[tuple[State, str], tuple[State, Callable]] = {}\n\n    def register_transition(self, from_state: State, event: str,\n                           to_state: State, handler: Callable):\n        \"\"\"Register a valid state transition.\"\"\"\n        self._transitions[(from_state, event)] = (to_state, handler)\n\n    async def handle_event(self, event: str, data: dict) -> Optional[str]:\n        \"\"\"Process event and execute transition if valid.\"\"\"\n        key = (self.state, event)\n\n        if key not in self._transitions:\n            return f\"Cannot {event} from state {self.state.name}\"\n\n        to_state, handler = self._transitions[key]\n\n        # Cancel existing timeout\n        if self._timeout_task:\n            self._timeout_task.cancel()\n\n        # Execute handler\n        try:\n            result = await handler(self.context, data)\n            self.state = to_state\n\n            # Set new timeout if not idle\n            if to_state != State.IDLE:\n                self._timeout_task = asyncio.create_task(\n                    self._handle_timeout()\n                )\n\n            return result\n        except Exception as e:\n            self.state = State.ERROR\n            raise\n\n    async def _handle_timeout(self):\n        \"\"\"Reset to IDLE after timeout.\"\"\"\n        await asyncio.sleep(self.timeout)\n        self.state = State.IDLE\n        self.context = {}\n\n\n# Usage example: Moderation flow\nasync def setup_ban_flow(machine: ConversationStateMachine):\n    async def start_ban(ctx, data):\n        ctx['target_user'] = data['target']\n        ctx['reason'] = data.get('reason', 'No reason provided')\n        return f\"Confirm ban of {ctx['target_user']}? (yes/no)\"\n\n    async def confirm_ban(ctx, data):\n        if data['response'].lower() == 'yes':\n            await ban_user(ctx['target_user'], ctx['reason'])\n            return f\"Banned {ctx['target_user']}\"\n        return \"Ban cancelled\"\n\n    async def cancel(ctx, data):\n        return \"Operation cancelled\"\n\n    machine.register_transition(State.IDLE, 'ban', State.AWAITING_CONFIRMATION, start_ban)\n    machine.register_transition(State.AWAITING_CONFIRMATION, 'confirm', State.IDLE, confirm_ban)\n    machine.register_transition(State.AWAITING_CONFIRMATION, 'cancel', State.IDLE, cancel)\n```\n\n## Key Principles\n\n1. **Separation of concerns**: Commands, events, and scheduled tasks in separate processors\n2. **Service layer**: Business logic isolated from platform-specific code\n3. **State management**: Explicit states prevent race conditions in multi-turn interactions\n4. **Timeout handling**: Auto-reset prevents stuck conversations\n5. **Data layer abstraction**: PostgreSQL for persistence, Redis for caching/rate limits\n"
        },
        {
          "name": "moderation-system.md",
          "type": "file",
          "path": "bot-developer/references/moderation-system.md",
          "size": 6646,
          "content": "# Moderation System\n\nProduction moderation with escalation, decay, and auto-mod.\n\n## Point-Based Moderation Service\n\n```python\nfrom datetime import datetime, timedelta\nfrom enum import IntEnum\nfrom typing import Optional\nimport asyncpg\n\nclass ActionSeverity(IntEnum):\n    NOTE = 0        # Just a record, no action\n    WARNING = 1     # Formal warning\n    MUTE = 2        # Temporary mute\n    KICK = 3        # Remove from server\n    TEMP_BAN = 4    # Temporary ban\n    BAN = 5         # Permanent ban\n\nclass ModerationService:\n    \"\"\"\n    Production moderation system with:\n    - Point-based escalation\n    - Automatic decay\n    - Appeal system\n    - Audit logging\n    \"\"\"\n\n    POINT_CONFIG = {\n        ActionSeverity.NOTE: 0,\n        ActionSeverity.WARNING: 1,\n        ActionSeverity.MUTE: 2,\n        ActionSeverity.KICK: 3,\n        ActionSeverity.TEMP_BAN: 5,\n        ActionSeverity.BAN: 10,\n    }\n\n    DECAY_RATE = 0.1  # Points per day\n\n    def __init__(self, db: asyncpg.Pool):\n        self.db = db\n\n    async def add_infraction(\n        self,\n        guild_id: int,\n        user_id: int,\n        moderator_id: int,\n        action: ActionSeverity,\n        reason: str,\n        duration: Optional[timedelta] = None\n    ) -> dict:\n        \"\"\"Record an infraction and return recommended action.\"\"\"\n\n        # Get current points (with decay applied)\n        current_points = await self._get_user_points(guild_id, user_id)\n        new_points = current_points + self.POINT_CONFIG[action]\n\n        # Record infraction\n        infraction_id = await self.db.fetchval(\"\"\"\n            INSERT INTO infractions (guild_id, user_id, moderator_id, action, reason, duration, points)\n            VALUES ($1, $2, $3, $4, $5, $6, $7)\n            RETURNING id\n        \"\"\", guild_id, user_id, moderator_id, action.value, reason, duration, self.POINT_CONFIG[action])\n\n        # Check escalation thresholds\n        recommended_action = self._get_recommended_action(new_points)\n\n        # Log to audit\n        await self._audit_log(guild_id, {\n            'type': 'INFRACTION_ADDED',\n            'infraction_id': infraction_id,\n            'user_id': user_id,\n            'action': action.name,\n            'new_total_points': new_points,\n            'recommended_escalation': recommended_action.name if recommended_action else None\n        })\n\n        return {\n            'infraction_id': infraction_id,\n            'current_points': new_points,\n            'recommended_action': recommended_action,\n            'history_count': await self._get_infraction_count(guild_id, user_id)\n        }\n\n    async def _get_user_points(self, guild_id: int, user_id: int) -> float:\n        \"\"\"Get current points with time decay applied.\"\"\"\n        rows = await self.db.fetch(\"\"\"\n            SELECT points, created_at FROM infractions\n            WHERE guild_id = $1 AND user_id = $2 AND pardoned = FALSE\n        \"\"\", guild_id, user_id)\n\n        total = 0.0\n        now = datetime.utcnow()\n\n        for row in rows:\n            age_days = (now - row['created_at']).days\n            decayed_points = max(0, row['points'] - (age_days * self.DECAY_RATE))\n            total += decayed_points\n\n        return total\n\n    def _get_recommended_action(self, points: float) -> Optional[ActionSeverity]:\n        \"\"\"Get recommended escalation based on point total.\"\"\"\n        if points >= 15:\n            return ActionSeverity.BAN\n        elif points >= 10:\n            return ActionSeverity.TEMP_BAN\n        elif points >= 6:\n            return ActionSeverity.KICK\n        elif points >= 3:\n            return ActionSeverity.MUTE\n        return None\n```\n\n## Escalation Thresholds\n\n| Points | Recommended Action |\n|--------|-------------------|\n| 0-2 | No action |\n| 3-5 | Mute |\n| 6-9 | Kick |\n| 10-14 | Temp Ban |\n| 15+ | Permanent Ban |\n\n## Auto-Mod Rules\n\n```python\nclass AutoMod:\n    \"\"\"Automatic moderation with configurable rules.\"\"\"\n\n    def __init__(self, config: dict):\n        self.rules = config.get('rules', {})\n\n    async def check_message(self, message) -> list[dict]:\n        \"\"\"Check message against all rules, return violations.\"\"\"\n        violations = []\n\n        # Spam detection (message frequency)\n        if self.rules.get('spam_enabled'):\n            if await self._check_spam(message):\n                violations.append({\n                    'rule': 'spam',\n                    'action': self.rules['spam_action'],\n                    'reason': 'Message spam detected'\n                })\n\n        # Caps lock abuse\n        if self.rules.get('caps_enabled'):\n            caps_ratio = sum(1 for c in message.content if c.isupper()) / max(len(message.content), 1)\n            if caps_ratio > self.rules.get('caps_threshold', 0.7) and len(message.content) > 10:\n                violations.append({\n                    'rule': 'caps',\n                    'action': self.rules['caps_action'],\n                    'reason': 'Excessive caps lock'\n                })\n\n        # Link filtering\n        if self.rules.get('links_enabled'):\n            import re\n            urls = re.findall(r'https?://\\S+', message.content)\n            for url in urls:\n                if not any(allowed in url for allowed in self.rules.get('link_whitelist', [])):\n                    violations.append({\n                        'rule': 'links',\n                        'action': self.rules['links_action'],\n                        'reason': f'Unauthorized link: {url}'\n                    })\n\n        # Word filter (with Levenshtein for bypass attempts)\n        if self.rules.get('words_enabled'):\n            from rapidfuzz import fuzz\n            words = message.content.lower().split()\n            for word in words:\n                for banned in self.rules.get('banned_words', []):\n                    if fuzz.ratio(word, banned) > 85:  # Catches l33t speak, typos\n                        violations.append({\n                            'rule': 'banned_word',\n                            'action': self.rules['words_action'],\n                            'reason': 'Banned word detected'\n                        })\n                        break\n\n        return violations\n```\n\n## Auto-Mod Rule Types\n\n| Rule | Detection | Bypass Prevention |\n|------|-----------|-------------------|\n| **Spam** | Message frequency tracking | Per-user sliding window |\n| **Caps** | Character ratio analysis | Minimum length threshold |\n| **Links** | URL regex extraction | Whitelist approved domains |\n| **Words** | Dictionary matching | Levenshtein fuzzy matching (85%) |\n| **Mentions** | @mention counting | Role/user/everyone variants |\n| **Invites** | Discord invite regex | Shortened URL expansion |\n"
        },
        {
          "name": "platform-templates.md",
          "type": "file",
          "path": "bot-developer/references/platform-templates.md",
          "size": 5608,
          "content": "# Platform Templates\n\nProduction templates for Discord and Telegram bots.\n\n## Discord.py Production Template\n\n```python\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands, tasks\nimport asyncpg\nimport redis.asyncio as redis\nimport logging\nimport sys\nfrom typing import Optional\n\n# Proper logging setup\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s | %(levelname)s | %(name)s | %(message)s',\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        logging.FileHandler('bot.log')\n    ]\n)\nlogger = logging.getLogger('bot')\n\nclass ProductionBot(commands.Bot):\n    \"\"\"Production-ready Discord bot with proper resource management.\"\"\"\n\n    def __init__(self):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        intents.members = True\n\n        super().__init__(\n            command_prefix=commands.when_mentioned_or('!'),\n            intents=intents,\n            activity=discord.Activity(\n                type=discord.ActivityType.watching,\n                name=\"for /help\"\n            )\n        )\n\n        self.db: Optional[asyncpg.Pool] = None\n        self.redis: Optional[redis.Redis] = None\n\n    async def setup_hook(self) -> None:\n        \"\"\"Called when bot is starting up.\"\"\"\n        # Database connection pool\n        self.db = await asyncpg.create_pool(\n            'postgresql://user:pass@localhost/botdb',\n            min_size=5,\n            max_size=20,\n            command_timeout=60\n        )\n        logger.info(\"Database pool created\")\n\n        # Redis connection\n        self.redis = redis.Redis.from_url(\n            'redis://localhost:6379',\n            decode_responses=True\n        )\n        logger.info(\"Redis connected\")\n\n        # Load cogs\n        for cog in ['moderation', 'economy', 'fun', 'admin']:\n            try:\n                await self.load_extension(f'cogs.{cog}')\n                logger.info(f\"Loaded cog: {cog}\")\n            except Exception as e:\n                logger.error(f\"Failed to load cog {cog}: {e}\")\n\n        # Sync commands\n        await self.tree.sync()\n        logger.info(\"Commands synced\")\n\n        # Start background tasks\n        self.cleanup_task.start()\n\n    async def close(self) -> None:\n        \"\"\"Cleanup on shutdown.\"\"\"\n        logger.info(\"Shutting down...\")\n\n        self.cleanup_task.cancel()\n\n        if self.db:\n            await self.db.close()\n        if self.redis:\n            await self.redis.close()\n\n        await super().close()\n\n    @tasks.loop(hours=1)\n    async def cleanup_task(self):\n        \"\"\"Periodic cleanup of expired data.\"\"\"\n        async with self.db.acquire() as conn:\n            await conn.execute(\"DELETE FROM mutes WHERE expires_at < NOW()\")\n            await conn.execute(\"DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '90 days'\")\n\n    async def on_error(self, event: str, *args, **kwargs):\n        \"\"\"Global error handler.\"\"\"\n        logger.exception(f\"Error in {event}\")\n        if self.redis:\n            await self.redis.publish('bot_errors', f\"Error in {event}\")\n```\n\n## Telegram Bot with Webhooks\n\n```python\nfrom fastapi import FastAPI, Request\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters\n\napp = FastAPI()\n\n# Telegram app (don't use polling in production!)\ntelegram_app = Application.builder().token(BOT_TOKEN).build()\n\n@app.post(\"/webhook/{token}\")\nasync def telegram_webhook(token: str, request: Request):\n    \"\"\"Receive Telegram updates via webhook.\"\"\"\n\n    # Verify token matches (simple security)\n    if token != WEBHOOK_TOKEN:\n        return {\"error\": \"Invalid token\"}\n\n    # Verify Telegram signature if using secret_token\n    secret_token = request.headers.get(\"X-Telegram-Bot-Api-Secret-Token\")\n    if secret_token != TELEGRAM_SECRET:\n        return {\"error\": \"Invalid signature\"}\n\n    data = await request.json()\n    update = Update.de_json(data, telegram_app.bot)\n\n    await telegram_app.process_update(update)\n\n    return {\"ok\": True}\n\n# Set webhook on startup\n@app.on_event(\"startup\")\nasync def setup_webhook():\n    await telegram_app.bot.set_webhook(\n        url=f\"https://mybot.com/webhook/{WEBHOOK_TOKEN}\",\n        secret_token=TELEGRAM_SECRET,\n        allowed_updates=[\"message\", \"callback_query\"],\n        drop_pending_updates=True\n    )\n```\n\n## Security Checklist\n\n```\nTOKEN SECURITY\n├── Never commit tokens to git\n├── Use environment variables or secret manager\n├── Rotate tokens if exposed\n└── Use separate tokens for dev/staging/prod\n\nPERMISSION CHECKS\n├── Always verify user has permission before action\n├── Use Discord's permission system, don't roll your own\n├── Check bot's permissions before attempting actions\n└── Fail safely if permissions missing\n\nINPUT VALIDATION\n├── Sanitize all user input\n├── Validate command arguments\n├── Use parameterized queries (no SQL injection)\n└── Rate limit user-triggered actions\n\nAUDIT LOGGING\n├── Log all moderation actions\n├── Log permission changes\n├── Log configuration changes\n└── Retain logs for compliance period\n```\n\n## Platform Comparison\n\n| Feature | Discord | Telegram | Slack |\n|---------|---------|----------|-------|\n| **Connection** | Gateway (WebSocket) | Webhook or Polling | Socket Mode or Webhook |\n| **Rate Limits** | Complex per-bucket | Simple global | Per-method |\n| **Rich Messages** | Embeds | Markdown + Inline buttons | Blocks |\n| **Slash Commands** | Built-in | BotFather menu | Manifest |\n| **Media** | Attachments, CDN | Inline file ID | Files API |\n"
        },
        {
          "name": "rate-limiting.md",
          "type": "file",
          "path": "bot-developer/references/rate-limiting.md",
          "size": 4476,
          "content": "# Rate Limiting (Production-Grade)\n\nDistributed and adaptive rate limiting implementations.\n\n## Distributed Rate Limiter (Redis)\n\n```python\nimport asyncio\nimport time\nfrom dataclasses import dataclass\nfrom collections import defaultdict\nimport redis.asyncio as redis\n\n@dataclass\nclass RateLimitConfig:\n    requests: int      # Number of requests\n    window: int        # Time window in seconds\n    burst: int = 0     # Additional burst allowance\n\nclass DistributedRateLimiter:\n    \"\"\"\n    Token bucket rate limiter with Redis backend.\n    Handles distributed deployments and provides consistent limiting\n    across multiple bot instances.\n    \"\"\"\n\n    def __init__(self, redis_client: redis.Redis, prefix: str = \"ratelimit\"):\n        self.redis = redis_client\n        self.prefix = prefix\n\n    async def is_allowed(self, key: str, config: RateLimitConfig) -> tuple[bool, float]:\n        \"\"\"\n        Check if request is allowed under rate limit.\n        Returns: (allowed: bool, retry_after: float)\n        Uses sliding window log algorithm for accuracy.\n        \"\"\"\n        full_key = f\"{self.prefix}:{key}\"\n        now = time.time()\n        window_start = now - config.window\n\n        async with self.redis.pipeline(transaction=True) as pipe:\n            # Remove old entries\n            await pipe.zremrangebyscore(full_key, 0, window_start)\n            # Count current entries\n            await pipe.zcard(full_key)\n            # Add new entry\n            await pipe.zadd(full_key, {str(now): now})\n            # Set expiry\n            await pipe.expire(full_key, config.window + 1)\n\n            results = await pipe.execute()\n\n        current_count = results[1]\n        max_allowed = config.requests + config.burst\n\n        if current_count < max_allowed:\n            return True, 0\n\n        # Calculate retry time\n        oldest = await self.redis.zrange(full_key, 0, 0, withscores=True)\n        if oldest:\n            retry_after = oldest[0][1] + config.window - now\n            return False, max(0, retry_after)\n\n        return False, config.window\n```\n\n## Adaptive Rate Limiter (API Response-Based)\n\n```python\nclass AdaptiveRateLimiter:\n    \"\"\"\n    Rate limiter that adapts to API responses.\n    Handles Discord's dynamic rate limits, 429s, and global limits.\n    \"\"\"\n\n    def __init__(self):\n        self.buckets: dict[str, dict] = defaultdict(lambda: {\n            'remaining': float('inf'),\n            'reset_at': 0,\n            'limit': float('inf')\n        })\n        self.global_lock = asyncio.Lock()\n        self.global_reset_at = 0\n\n    async def acquire(self, bucket: str) -> None:\n        \"\"\"Wait until we can make a request to this bucket.\"\"\"\n        # Check global limit first\n        if self.global_reset_at > time.time():\n            await asyncio.sleep(self.global_reset_at - time.time())\n\n        bucket_info = self.buckets[bucket]\n\n        if bucket_info['remaining'] <= 0:\n            wait_time = bucket_info['reset_at'] - time.time()\n            if wait_time > 0:\n                await asyncio.sleep(wait_time)\n\n        bucket_info['remaining'] -= 1\n\n    def update_from_headers(self, bucket: str, headers: dict) -> None:\n        \"\"\"Update rate limit info from API response headers.\"\"\"\n        if 'X-RateLimit-Remaining' in headers:\n            self.buckets[bucket]['remaining'] = int(headers['X-RateLimit-Remaining'])\n        if 'X-RateLimit-Reset' in headers:\n            self.buckets[bucket]['reset_at'] = float(headers['X-RateLimit-Reset'])\n        if 'X-RateLimit-Limit' in headers:\n            self.buckets[bucket]['limit'] = int(headers['X-RateLimit-Limit'])\n\n        # Handle global rate limit\n        if headers.get('X-RateLimit-Global'):\n            retry_after = float(headers.get('Retry-After', 1))\n            self.global_reset_at = time.time() + retry_after\n```\n\n## Common Rate Limit Configurations\n\n| Context | Requests | Window | Burst |\n|---------|----------|--------|-------|\n| User commands | 10 | 60s | 3 |\n| API calls per user | 30 | 60s | 5 |\n| Guild-wide actions | 100 | 60s | 10 |\n| Message spam | 5 | 10s | 2 |\n| DM operations | 5 | 30s | 1 |\n\n## Best Practices\n\n1. **Use distributed limiter** for multi-instance deployments\n2. **Implement adaptive limits** that respect API response headers\n3. **Separate buckets** for different action types (commands, API calls, moderation)\n4. **Allow small burst** for bursty but legitimate use patterns\n5. **Graceful degradation**: Inform users of retry time instead of silent failure\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "bot-developer/CHANGELOG.md",
      "size": 1339,
      "content": "# Changelog\n\n## [2.0.0] - 2024-01-XX\n\n### Changed\n- **BREAKING**: Restructured from monolithic 624-line file to progressive disclosure architecture\n- Fixed frontmatter format: `tools:` → `allowed-tools:` (comma-separated)\n- Added NOT clause to description for precise activation boundaries\n- Reduced SKILL.md from 624 lines to 154 lines (75% reduction)\n\n### Added\n- `references/architecture-patterns.md` - Event-driven architecture, state machines\n- `references/rate-limiting.md` - Distributed rate limiters, adaptive strategies\n- `references/moderation-system.md` - Point-based moderation, AutoMod rules\n- `references/platform-templates.md` - Discord.py, Telegram FastAPI, security checklist\n- Anti-patterns section with \"What it looks like / Why wrong / Instead\" format\n- Platform comparison table (Discord, Telegram, Slack)\n\n### Removed\n- Inline Python class implementations (moved to references)\n- Verbose rate limiting explanations (condensed to quick reference)\n- Redundant platform-specific examples\n\n### Migration Guide\nReference files are now in `/references/` directory. Import patterns:\n- Architecture patterns → `references/architecture-patterns.md`\n- Rate limiting code → `references/rate-limiting.md`\n- Moderation system → `references/moderation-system.md`\n- Platform templates → `references/platform-templates.md`\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "bot-developer/SKILL.md",
      "size": 5428,
      "content": "---\nname: bot-developer\ndescription: \"Expert bot developer specializing in Discord, Telegram, Slack automation with deep knowledge of rate limiting, state machines, event sourcing, moderation systems, and conversational AI integration. Activate on 'Discord bot', 'Telegram bot', 'Slack bot', 'chat automation', 'moderation system'. NOT for web APIs (use backend-architect), general automation scripts (use python-pro), or frontend chat widgets (use frontend-developer).\"\nallowed-tools: Read,Write,Edit,Bash,WebSearch,WebFetch\n---\n\n# Bot Developer\n\nExpert in building production-grade bots with proper architecture, state management, and scalability.\n\n## Quick Start\n\n```\nUser: \"Build a Discord moderation bot with auto-mod\"\n\nBot Developer:\n1. Set up event-driven architecture (message broker + service layer)\n2. Implement state machine for multi-turn mod flows\n3. Add distributed rate limiting (Redis)\n4. Create point-based moderation with decay\n5. Configure auto-mod rules (spam, caps, links, words)\n6. Deploy with proper logging and error handling\n```\n\n**Key principle**: Production bots need rate limiting, state management, and graceful degradation—not just command handlers.\n\n## Core Capabilities\n\n### 1. Platform Expertise\n\n| Platform | Connection | Best For |\n|----------|------------|----------|\n| Discord | Gateway (WebSocket) | Gaming communities, large servers |\n| Telegram | Webhook (production) | International, groups/channels |\n| Slack | Socket Mode/Webhook | Workplace, integrations |\n\n### 2. Production Architecture\n- Event-driven design with message broker (Redis Streams / RabbitMQ)\n- Service layer separation (User, Moderation, Economy, Integration)\n- PostgreSQL + Redis + S3 data layer\n- Cog-based modular structure\n\n### 3. State Management\n- Finite state machines for multi-turn conversations\n- Timeout handling (auto-reset after inactivity)\n- Race condition prevention\n- Context preservation across turns\n\n### 4. Rate Limiting\n- Distributed limiter with Redis backend\n- Adaptive limiter responding to API headers\n- Per-user, per-guild, and global buckets\n- Graceful degradation with retry-after info\n\n### 5. Moderation System\n- Point-based escalation (configurable thresholds)\n- Automatic decay over time\n- Auto-mod rules (spam, caps, links, banned words)\n- Fuzzy matching to catch bypass attempts (l33t speak)\n- Audit logging for compliance\n\n## Escalation Thresholds\n\n| Points | Action |\n|--------|--------|\n| 0-2 | No action |\n| 3-5 | Mute |\n| 6-9 | Kick |\n| 10-14 | Temp Ban |\n| 15+ | Permanent Ban |\n\n## Auto-Mod Rules\n\n| Rule | Detection Method |\n|------|-----------------|\n| Spam | Message frequency per sliding window |\n| Caps | Character ratio (&gt;70% uppercase) |\n| Links | URL regex + domain whitelist |\n| Words | Dictionary + Levenshtein (85% threshold) |\n| Mentions | @mention counting with variants |\n| Invites | Discord invite regex + URL expansion |\n\n## When to Use\n\n**Use for:**\n- Discord/Telegram/Slack bot development\n- Moderation and auto-mod systems\n- Multi-turn conversational flows\n- Economy/XP/leveling systems\n- Integration with external APIs\n\n**Do NOT use for:**\n- Web APIs without chat interface (use backend-architect)\n- General automation scripts (use python-pro)\n- Frontend chat widgets (use frontend-developer)\n- AI/ML model integration alone (use ai-engineer)\n\n## Anti-Patterns\n\n### Anti-Pattern: Polling in Production\n**What it looks like**: Using `bot.polling()` or long-polling for Telegram\n**Why wrong**: Wastes resources, slower response, can't scale\n**Instead**: Use webhooks with proper verification\n\n### Anti-Pattern: No Rate Limiting\n**What it looks like**: Sending API requests without throttling\n**Why wrong**: Gets bot banned, triggers 429s, poor UX\n**Instead**: Implement adaptive rate limiter respecting API headers\n\n### Anti-Pattern: In-Memory State Only\n**What it looks like**: Storing conversation state in Python dict\n**Why wrong**: Lost on restart, can't scale to multiple instances\n**Instead**: Redis for state, PostgreSQL for persistence\n\n### Anti-Pattern: Blocking Event Handlers\n**What it looks like**: Long-running operations in `on_message`\n**Why wrong**: Blocks all other events, causes timeouts\n**Instead**: Async tasks, message queue for heavy work\n\n## Security Checklist\n\n```\nTOKEN SECURITY\n├── Never commit tokens to git\n├── Use environment variables or secret manager\n├── Rotate tokens if exposed\n└── Separate tokens for dev/staging/prod\n\nPERMISSION CHECKS\n├── Verify user permissions before action\n├── Use platform's permission system\n├── Check bot's permissions before attempting\n└── Fail safely if permissions missing\n\nINPUT VALIDATION\n├── Sanitize all user input\n├── Validate command arguments\n├── Parameterized queries (no SQL injection)\n└── Rate limit user-triggered actions\n```\n\n## Reference Files\n\n- `references/architecture-patterns.md` - Event-driven architecture, state machines\n- `references/rate-limiting.md` - Distributed and adaptive rate limiting\n- `references/moderation-system.md` - Point-based moderation, auto-mod\n- `references/platform-templates.md` - Discord.py, Telegram webhook templates, security\n\n---\n\n**Core insight**: Production bots fail from rate limiting and state bugs, not from bad command logic. Build infrastructure first.\n\n**Use with**: ai-engineer (LLM integration) | backend-architect (API design) | deployment-engineer (hosting)\n"
    }
  ]
}