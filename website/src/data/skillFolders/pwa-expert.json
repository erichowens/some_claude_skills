{
  "name": "pwa-expert",
  "type": "folder",
  "path": "pwa-expert",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "pwa-expert/references",
      "children": [
        {
          "name": "background-sync.md",
          "type": "file",
          "path": "pwa-expert/references/background-sync.md",
          "size": 2604,
          "content": "# Background Sync\n\nBackground Sync allows queuing actions while offline and executing them when connectivity returns.\n\n## Service Worker Sync Handler\n\n```javascript\n// In service worker\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'sync-checkins') {\n    event.waitUntil(syncCheckins());\n  }\n});\n\nasync function syncCheckins() {\n  const db = await openDB();\n  const pendingCheckins = await db.getAll('pending-checkins');\n\n  for (const checkin of pendingCheckins) {\n    try {\n      await fetch('/api/checkins', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(checkin),\n      });\n      await db.delete('pending-checkins', checkin.id);\n    } catch (error) {\n      // Will retry on next sync\n      console.error('Sync failed:', error);\n    }\n  }\n}\n```\n\n## Register Sync from App\n\n```typescript\n// When saving data offline\nasync function saveCheckin(data: CheckinData) {\n  // Save to IndexedDB first\n  await db.add('pending-checkins', { ...data, id: crypto.randomUUID() });\n\n  // Request background sync\n  if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n    const registration = await navigator.serviceWorker.ready;\n    await registration.sync.register('sync-checkins');\n  }\n}\n```\n\n## IndexedDB Helper\n\n```typescript\n// lib/db.ts\nimport { openDB as idbOpen } from 'idb';\n\nexport async function openDB() {\n  return idbOpen('jb4l-offline', 1, {\n    upgrade(db) {\n      db.createObjectStore('pending-checkins', { keyPath: 'id' });\n      db.createObjectStore('pending-journal', { keyPath: 'id' });\n    },\n  });\n}\n```\n\n## Sync with Retry Logic\n\n```javascript\nasync function syncWithRetry(items, endpoint, storeName, maxRetries = 3) {\n  const db = await openDB();\n\n  for (const item of items) {\n    let attempts = item.attempts || 0;\n\n    try {\n      await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(item.data),\n      });\n\n      // Success - remove from queue\n      await db.delete(storeName, item.id);\n\n    } catch (error) {\n      attempts++;\n\n      if (attempts >= maxRetries) {\n        // Move to failed queue for manual review\n        await db.put('failed-syncs', { ...item, attempts, error: error.message });\n        await db.delete(storeName, item.id);\n      } else {\n        // Update attempt count\n        await db.put(storeName, { ...item, attempts });\n      }\n    }\n  }\n}\n```\n\n## Browser Support\n\n- Chrome 49+\n- Edge 79+\n- Firefox: Behind flag\n- Safari: Not supported (use periodic manual sync)\n"
        },
        {
          "name": "install-prompt.md",
          "type": "file",
          "path": "pwa-expert/references/install-prompt.md",
          "size": 3686,
          "content": "# Install Prompt Implementation\n\n## usePWAInstall Hook\n\n```typescript\n// hooks/usePWAInstall.ts\n'use client';\n\nimport { useState, useEffect } from 'react';\n\ninterface BeforeInstallPromptEvent extends Event {\n  prompt: () => Promise<void>;\n  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;\n}\n\nexport function usePWAInstall() {\n  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);\n  const [isInstallable, setIsInstallable] = useState(false);\n  const [isInstalled, setIsInstalled] = useState(false);\n\n  useEffect(() => {\n    // Check if already installed\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      setIsInstalled(true);\n      return;\n    }\n\n    const handleBeforeInstall = (e: Event) => {\n      e.preventDefault();\n      setDeferredPrompt(e as BeforeInstallPromptEvent);\n      setIsInstallable(true);\n    };\n\n    const handleAppInstalled = () => {\n      setIsInstalled(true);\n      setIsInstallable(false);\n      setDeferredPrompt(null);\n    };\n\n    window.addEventListener('beforeinstallprompt', handleBeforeInstall);\n    window.addEventListener('appinstalled', handleAppInstalled);\n\n    return () => {\n      window.removeEventListener('beforeinstallprompt', handleBeforeInstall);\n      window.removeEventListener('appinstalled', handleAppInstalled);\n    };\n  }, []);\n\n  const install = async () => {\n    if (!deferredPrompt) return false;\n\n    deferredPrompt.prompt();\n    const { outcome } = await deferredPrompt.userChoice;\n\n    setDeferredPrompt(null);\n    setIsInstallable(false);\n\n    return outcome === 'accepted';\n  };\n\n  return { isInstallable, isInstalled, install };\n}\n```\n\n## Install Prompt Component\n\n```tsx\n// components/InstallPrompt.tsx\n'use client';\n\nimport { usePWAInstall } from '@/hooks/usePWAInstall';\nimport { useState } from 'react';\n\nexport function InstallPrompt() {\n  const { isInstallable, install } = usePWAInstall();\n  const [dismissed, setDismissed] = useState(false);\n\n  if (!isInstallable || dismissed) return null;\n\n  return (\n    <div className=\"fixed bottom-20 left-4 right-4 md:left-auto md:right-4 md:w-80\n                    bg-leather-800 border border-leather-600 rounded-lg p-4 shadow-lg\n                    animate-slide-up z-50\">\n      <div className=\"flex items-start gap-3\">\n        <img src=\"/icons/icon-64.png\" alt=\"\" className=\"w-12 h-12 rounded-lg\" />\n        <div className=\"flex-1\">\n          <h3 className=\"font-bitter text-lg text-leather-100\">Install JB4L</h3>\n          <p className=\"text-sm text-leather-400 mt-1\">\n            Get quick access and offline support\n          </p>\n        </div>\n        <button\n          onClick={() => setDismissed(true)}\n          className=\"text-leather-500 hover:text-leather-300\"\n          aria-label=\"Dismiss\"\n        >\n          âœ•\n        </button>\n      </div>\n      <div className=\"flex gap-2 mt-4\">\n        <button\n          onClick={() => setDismissed(true)}\n          className=\"flex-1 px-4 py-2 text-leather-400 hover:text-leather-200\"\n        >\n          Not now\n        </button>\n        <button\n          onClick={install}\n          className=\"flex-1 px-4 py-2 bg-ember-500 hover:bg-ember-600\n                     text-white rounded-lg font-medium\"\n        >\n          Install\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n## Best Practices\n\n1. **Don't show immediately** - Wait for user engagement or after they've used the app a few times\n2. **Respect dismissal** - Store in localStorage if user says \"Not now\"\n3. **Show value first** - Explain benefits: offline access, quick launch, etc.\n4. **iOS handling** - iOS doesn't support `beforeinstallprompt`, show manual instructions instead\n"
        },
        {
          "name": "nextjs-integration.md",
          "type": "file",
          "path": "pwa-expert/references/nextjs-integration.md",
          "size": 2723,
          "content": "# Next.js PWA Integration\n\n## Using next-pwa\n\n```bash\nnpm install next-pwa\n```\n\n### next.config.js Configuration\n\n```javascript\n// next.config.js\nconst withPWA = require('next-pwa')({\n  dest: 'public',\n  register: true,\n  skipWaiting: true,\n  disable: process.env.NODE_ENV === 'development',\n  runtimeCaching: [\n    {\n      urlPattern: /^https:\\/\\/api\\./,\n      handler: 'NetworkFirst',\n      options: {\n        cacheName: 'api-cache',\n        expiration: { maxEntries: 50, maxAgeSeconds: 3600 },\n      },\n    },\n    {\n      urlPattern: /\\.(png|jpg|jpeg|svg|gif|webp)$/,\n      handler: 'CacheFirst',\n      options: {\n        cacheName: 'image-cache',\n        expiration: { maxEntries: 100, maxAgeSeconds: 86400 * 30 },\n      },\n    },\n  ],\n});\n\nmodule.exports = withPWA({\n  // Your Next.js config\n});\n```\n\n## Static Export (Cloudflare Pages)\n\nFor `output: 'export'`, next-pwa can't generate SW at build time. Use manual approach:\n\n### 1. Create Custom Service Worker\n\n```javascript\n// public/sw.js\nconst CACHE_NAME = 'myapp-v1';\n\n// ... (use patterns from service-worker-patterns.md)\n```\n\n### 2. Register Manually\n\n```typescript\n// lib/pwa.ts\nexport async function registerServiceWorker() {\n  if ('serviceWorker' in navigator) {\n    try {\n      await navigator.serviceWorker.register('/sw.js', { scope: '/' });\n    } catch (error) {\n      console.error('SW registration failed:', error);\n    }\n  }\n}\n```\n\n### 3. Call in Layout\n\n```tsx\n// app/layout.tsx\n'use client';\n\nimport { useEffect } from 'react';\nimport { registerServiceWorker } from '@/lib/pwa';\n\nexport default function RootLayout({ children }) {\n  useEffect(() => {\n    registerServiceWorker();\n  }, []);\n\n  return <html>{/* ... */}</html>;\n}\n```\n\n## Workbox CLI Alternative\n\nFor more control with static exports:\n\n```bash\nnpm install workbox-cli --save-dev\n```\n\n```javascript\n// workbox-config.js\nmodule.exports = {\n  globDirectory: 'out/',\n  globPatterns: ['**/*.{html,js,css,png,jpg,svg}'],\n  swDest: 'out/sw.js',\n  runtimeCaching: [\n    {\n      urlPattern: /^https:\\/\\/api\\./,\n      handler: 'NetworkFirst',\n    },\n  ],\n};\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"build\": \"next build && npx workbox generateSW workbox-config.js\"\n  }\n}\n```\n\n## Manifest in Next.js App Router\n\n```tsx\n// app/manifest.ts\nimport type { MetadataRoute } from 'next';\n\nexport default function manifest(): MetadataRoute.Manifest {\n  return {\n    name: 'My App',\n    short_name: 'App',\n    start_url: '/',\n    display: 'standalone',\n    background_color: '#1a1410',\n    theme_color: '#1a1410',\n    icons: [\n      { src: '/icons/icon-192.png', sizes: '192x192', type: 'image/png' },\n      { src: '/icons/icon-512.png', sizes: '512x512', type: 'image/png' },\n    ],\n  };\n}\n```\n"
        },
        {
          "name": "offline-handling.md",
          "type": "file",
          "path": "pwa-expert/references/offline-handling.md",
          "size": 3008,
          "content": "# Offline Handling\n\n## Offline Page\n\n```tsx\n// app/offline/page.tsx\nexport default function OfflinePage() {\n  return (\n    <div className=\"min-h-screen flex items-center justify-center p-4 bg-leather-950\">\n      <div className=\"text-center max-w-md\">\n        <div className=\"text-6xl mb-4\">ğŸ“¡</div>\n        <h1 className=\"font-bitter text-2xl text-leather-100 mb-2\">\n          You're Offline\n        </h1>\n        <p className=\"text-leather-400 mb-6\">\n          Check your connection and try again. Your saved data is still available.\n        </p>\n        <button\n          onClick={() => window.location.reload()}\n          className=\"px-6 py-3 bg-ember-500 hover:bg-ember-600\n                     text-white rounded-lg font-medium\"\n        >\n          Try Again\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n## useOnlineStatus Hook\n\n```typescript\n// hooks/useOnlineStatus.ts\n'use client';\n\nimport { useState, useEffect } from 'react';\n\nexport function useOnlineStatus() {\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n    // Set initial state\n    setIsOnline(navigator.onLine);\n\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  return isOnline;\n}\n```\n\n## Offline Banner Component\n\n```tsx\n// components/OfflineBanner.tsx\n'use client';\n\nimport { useOnlineStatus } from '@/hooks/useOnlineStatus';\n\nexport function OfflineBanner() {\n  const isOnline = useOnlineStatus();\n\n  if (isOnline) return null;\n\n  return (\n    <div className=\"fixed top-0 left-0 right-0 bg-amber-600 text-white\n                    py-2 px-4 text-center text-sm z-50\">\n      You're offline. Some features may be unavailable.\n    </div>\n  );\n}\n```\n\n## Offline-First Data Pattern\n\n```typescript\n// hooks/useOfflineData.ts\nimport { useState, useEffect } from 'react';\nimport { useOnlineStatus } from './useOnlineStatus';\n\nexport function useOfflineData<T>(\n  key: string,\n  fetcher: () => Promise<T>\n) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const isOnline = useOnlineStatus();\n\n  useEffect(() => {\n    async function loadData() {\n      // Try localStorage first\n      const cached = localStorage.getItem(key);\n      if (cached) {\n        setData(JSON.parse(cached));\n        setLoading(false);\n      }\n\n      // Fetch fresh data if online\n      if (isOnline) {\n        try {\n          const fresh = await fetcher();\n          setData(fresh);\n          localStorage.setItem(key, JSON.stringify(fresh));\n        } catch (error) {\n          console.error('Fetch failed:', error);\n        }\n      }\n\n      setLoading(false);\n    }\n\n    loadData();\n  }, [key, isOnline, fetcher]);\n\n  return { data, loading, isOnline };\n}\n```\n"
        },
        {
          "name": "service-worker-patterns.md",
          "type": "file",
          "path": "pwa-expert/references/service-worker-patterns.md",
          "size": 3894,
          "content": "# Service Worker Patterns\n\n## Basic Service Worker Structure\n\n```javascript\n// public/sw.js\nconst CACHE_NAME = 'jb4l-v1';\nconst STATIC_ASSETS = [\n  '/',\n  '/offline',\n  '/manifest.json',\n  '/icons/icon-192.png',\n  '/icons/icon-512.png',\n];\n\n// Install: Cache static assets\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME).then((cache) => {\n      return cache.addAll(STATIC_ASSETS);\n    })\n  );\n  self.skipWaiting(); // Activate immediately\n});\n\n// Activate: Clean old caches\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then((keys) => {\n      return Promise.all(\n        keys\n          .filter((key) => key !== CACHE_NAME)\n          .map((key) => caches.delete(key))\n      );\n    })\n  );\n  self.clients.claim(); // Take control immediately\n});\n\n// Fetch: Handle requests\nself.addEventListener('fetch', (event) => {\n  event.respondWith(handleFetch(event.request));\n});\n\nasync function handleFetch(request) {\n  // Network-first for API requests\n  if (request.url.includes('/api/')) {\n    return networkFirst(request);\n  }\n\n  // Cache-first for static assets\n  return cacheFirst(request);\n}\n```\n\n## Caching Strategy Implementations\n\n### Cache-First\n\nTry cache, fallback to network. Best for static assets.\n\n```javascript\nasync function cacheFirst(request) {\n  const cached = await caches.match(request);\n  if (cached) return cached;\n\n  try {\n    const response = await fetch(request);\n    // Cache successful responses\n    if (response.ok) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, response.clone());\n    }\n    return response;\n  } catch (error) {\n    // Return offline page for navigation\n    if (request.mode === 'navigate') {\n      return caches.match('/offline');\n    }\n    throw error;\n  }\n}\n```\n\n### Network-First\n\nTry network, fallback to cache. Best for API data.\n\n```javascript\nasync function networkFirst(request) {\n  try {\n    const response = await fetch(request);\n    // Cache successful API responses\n    if (response.ok) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, response.clone());\n    }\n    return response;\n  } catch (error) {\n    const cached = await caches.match(request);\n    if (cached) return cached;\n\n    // Return error response for API\n    return new Response(\n      JSON.stringify({ error: 'Offline', cached: false }),\n      { status: 503, headers: { 'Content-Type': 'application/json' } }\n    );\n  }\n}\n```\n\n### Stale-While-Revalidate\n\nReturn cache immediately, update in background. Best balance of speed and freshness.\n\n```javascript\nasync function staleWhileRevalidate(request) {\n  const cache = await caches.open(CACHE_NAME);\n  const cached = await cache.match(request);\n\n  const fetchPromise = fetch(request).then((response) => {\n    if (response.ok) {\n      cache.put(request, response.clone());\n    }\n    return response;\n  });\n\n  return cached || fetchPromise;\n}\n```\n\n## Route-Based Strategy Selection\n\n```javascript\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests\n  if (request.method !== 'GET') return;\n\n  // API routes: Network-first with cache fallback\n  if (url.pathname.startsWith('/api/')) {\n    event.respondWith(networkFirst(request));\n    return;\n  }\n\n  // Static assets: Cache-first\n  if (url.pathname.match(/\\.(js|css|png|jpg|svg|woff2?)$/)) {\n    event.respondWith(cacheFirst(request));\n    return;\n  }\n\n  // HTML pages: Stale-while-revalidate\n  if (request.mode === 'navigate') {\n    event.respondWith(staleWhileRevalidate(request));\n    return;\n  }\n\n  // Default: Network-first\n  event.respondWith(networkFirst(request));\n});\n```\n\n## Handle Skip Waiting Message\n\n```javascript\nself.addEventListener('message', (event) => {\n  if (event.data?.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n```\n"
        },
        {
          "name": "update-flow.md",
          "type": "file",
          "path": "pwa-expert/references/update-flow.md",
          "size": 3220,
          "content": "# PWA Update Flow\n\n## usePWAUpdate Hook\n\n```typescript\n// hooks/usePWAUpdate.ts\n'use client';\n\nimport { useState, useEffect } from 'react';\n\nexport function usePWAUpdate() {\n  const [updateAvailable, setUpdateAvailable] = useState(false);\n  const [registration, setRegistration] = useState<ServiceWorkerRegistration | null>(null);\n\n  useEffect(() => {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.ready.then((reg) => {\n        setRegistration(reg);\n\n        reg.addEventListener('updatefound', () => {\n          const newWorker = reg.installing;\n          newWorker?.addEventListener('statechange', () => {\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n              setUpdateAvailable(true);\n            }\n          });\n        });\n      });\n    }\n  }, []);\n\n  const applyUpdate = () => {\n    if (registration?.waiting) {\n      registration.waiting.postMessage({ type: 'SKIP_WAITING' });\n      window.location.reload();\n    }\n  };\n\n  return { updateAvailable, applyUpdate };\n}\n```\n\n## Update Banner Component\n\n```tsx\n// components/UpdateBanner.tsx\n'use client';\n\nimport { usePWAUpdate } from '@/hooks/usePWAUpdate';\n\nexport function UpdateBanner() {\n  const { updateAvailable, applyUpdate } = usePWAUpdate();\n\n  if (!updateAvailable) return null;\n\n  return (\n    <div className=\"fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-80\n                    bg-ember-600 text-white rounded-lg p-4 shadow-lg z-50\">\n      <p className=\"font-medium mb-2\">Update Available</p>\n      <p className=\"text-sm opacity-90 mb-3\">\n        A new version is ready. Reload to get the latest features.\n      </p>\n      <button\n        onClick={applyUpdate}\n        className=\"w-full py-2 bg-white text-ember-600 rounded font-medium\n                   hover:bg-gray-100 transition-colors\"\n      >\n        Reload Now\n      </button>\n    </div>\n  );\n}\n```\n\n## Service Worker Message Handler\n\n```javascript\n// In sw.js\nself.addEventListener('message', (event) => {\n  if (event.data?.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n```\n\n## Check for Updates Manually\n\n```typescript\n// Force check for updates\nasync function checkForUpdates() {\n  if ('serviceWorker' in navigator) {\n    const registration = await navigator.serviceWorker.ready;\n    await registration.update();\n  }\n}\n\n// Call periodically or on user action\nuseEffect(() => {\n  const interval = setInterval(checkForUpdates, 60 * 60 * 1000); // Every hour\n  return () => clearInterval(interval);\n}, []);\n```\n\n## Update Strategies\n\n### 1. Immediate Update (Aggressive)\n```javascript\n// In sw.js - takes control immediately\nself.addEventListener('install', (event) => {\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', (event) => {\n  self.clients.claim();\n});\n```\n\n### 2. User-Prompted Update (Recommended)\nWait for user to click \"Update\" before reloading. Less disruptive.\n\n### 3. Background Update\nUpdate on next visit. User gets new version automatically.\n\n```javascript\n// Only skipWaiting when no active clients\nself.addEventListener('install', async (event) => {\n  const clients = await self.clients.matchAll();\n  if (clients.length === 0) {\n    self.skipWaiting();\n  }\n});\n```\n"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "pwa-expert/SKILL.md",
      "size": 9696,
      "content": "---\nname: pwa-expert\ndescription: Progressive Web App development with Service Workers, offline support, and app-like behavior. Use for caching strategies, install prompts, push notifications, background sync. Activate on \"PWA\", \"Service Worker\", \"offline\", \"install prompt\", \"beforeinstallprompt\", \"manifest.json\", \"workbox\", \"cache-first\". NOT for native app development (use React Native), general web performance (use performance docs), or server-side rendering.\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Grep\n  - Glob\ncategory: Design & Creative\ntags:\n  - pwa\n  - service-worker\n  - offline\n  - caching\n  - installable\n  - workbox\n  - manifest\n---\n\n# Progressive Web App Expert\n\nBuild installable, offline-capable web apps with Service Workers, smart caching, and native-like experiences.\n\n## When to Use This Skill\n\n- Making a web app installable on mobile/desktop\n- Implementing offline functionality\n- Setting up Service Worker caching strategies\n- Handling install prompts (`beforeinstallprompt`)\n- Background sync for offline-first apps\n- Managing PWA update flows\n- Creating web app manifests\n\n## When NOT to Use This Skill\n\n- **Native app development** â†’ Use React Native, Flutter, or native SDKs\n- **General web performance** â†’ Use Lighthouse/performance auditing tools\n- **Server-side rendering issues** â†’ Use Next.js/framework-specific docs\n- **Push notifications only** â†’ Consider dedicated push notification services\n- **Simple static sites** â†’ PWA overhead may not be worth it\n\n## Core Concepts\n\n### What Makes a PWA Installable\n\n1. **HTTPS** (or localhost for dev)\n2. **Web App Manifest** with required fields\n3. **Service Worker** with fetch handler\n4. **Icons** (192Ã—192 and 512Ã—512 minimum)\n\n### The PWA Stack\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚           Your App (React/Next.js)      â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚         Service Worker (sw.js)          â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚   Cache     â”‚  â”‚  Network Fetch  â”‚   â”‚\nâ”‚  â”‚   Storage   â”‚  â”‚    Handling     â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚          manifest.json                  â”‚\nâ”‚  (App identity, icons, display mode)    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Web App Manifest\n\n### Complete manifest.json\n\n```json\n{\n  \"name\": \"Junkie Buds 4 Life\",\n  \"short_name\": \"JB4L\",\n  \"description\": \"Recovery support app\",\n  \"start_url\": \"/\",\n  \"scope\": \"/\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait-primary\",\n  \"background_color\": \"#1a1410\",\n  \"theme_color\": \"#1a1410\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/icons/icon-maskable-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable\"\n    }\n  ],\n  \"shortcuts\": [\n    {\n      \"name\": \"Find Meetings\",\n      \"short_name\": \"Meetings\",\n      \"url\": \"/meetings?source=shortcut\",\n      \"icons\": [{ \"src\": \"/icons/meetings-96.png\", \"sizes\": \"96x96\" }]\n    }\n  ]\n}\n```\n\n### Display Modes\n\n| Mode | Description |\n|------|-------------|\n| `fullscreen` | No browser UI, full screen |\n| `standalone` | App-like, no URL bar (recommended) |\n| `minimal-ui` | Some browser controls |\n| `browser` | Normal browser tab |\n\n### Link in HTML\n\n```html\n<head>\n  <link rel=\"manifest\" href=\"/manifest.json\" />\n  <meta name=\"theme-color\" content=\"#1a1410\" />\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" />\n  <link rel=\"apple-touch-icon\" href=\"/icons/apple-touch-icon.png\" />\n</head>\n```\n\n## Service Worker Basics\n\n### Registration\n\n```typescript\n// lib/pwa.ts\nexport async function registerServiceWorker() {\n  if ('serviceWorker' in navigator) {\n    try {\n      const registration = await navigator.serviceWorker.register('/sw.js', {\n        scope: '/',\n      });\n      return registration;\n    } catch (error) {\n      console.error('SW registration failed:', error);\n    }\n  }\n}\n\n// Call on app mount\nuseEffect(() => {\n  registerServiceWorker();\n}, []);\n```\n\n### Basic Service Worker Structure\n\n```javascript\n// public/sw.js\nconst CACHE_NAME = 'myapp-v1';\nconst STATIC_ASSETS = ['/', '/offline', '/manifest.json'];\n\n// Install: Cache static assets\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME).then((cache) => cache.addAll(STATIC_ASSETS))\n  );\n  self.skipWaiting();\n});\n\n// Activate: Clean old caches\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then((keys) =>\n      Promise.all(keys.filter((k) => k !== CACHE_NAME).map((k) => caches.delete(k)))\n    )\n  );\n  self.clients.claim();\n});\n\n// Fetch: Handle requests (see references for strategies)\nself.addEventListener('fetch', (event) => {\n  event.respondWith(handleFetch(event.request));\n});\n```\n\n> **See:** `references/service-worker-patterns.md` for caching strategy implementations\n\n## Caching Strategies\n\n| Strategy | Best For | Tradeoff |\n|----------|----------|----------|\n| Cache-First | Static assets, fonts, images | Stale until cache updated |\n| Network-First | API data, user content | Slower, needs connectivity |\n| Stale-While-Revalidate | Balance freshness/speed | Background updates |\n| Network-Only | Auth, real-time data | No offline support |\n| Cache-Only | Versioned assets | Never updates |\n\n> **See:** `references/service-worker-patterns.md` for full implementations\n\n## Install Prompts\n\nHandle the `beforeinstallprompt` event to show a custom install UI:\n\n```typescript\n// Basic pattern\nconst [deferredPrompt, setDeferredPrompt] = useState(null);\n\nuseEffect(() => {\n  window.addEventListener('beforeinstallprompt', (e) => {\n    e.preventDefault();\n    setDeferredPrompt(e);\n  });\n}, []);\n\nconst handleInstall = async () => {\n  if (deferredPrompt) {\n    deferredPrompt.prompt();\n    const { outcome } = await deferredPrompt.userChoice;\n    // outcome: 'accepted' or 'dismissed'\n  }\n};\n```\n\n> **See:** `references/install-prompt.md` for full `usePWAInstall` hook and component\n\n## Offline Experience\n\nKey patterns:\n- Offline page fallback for navigation failures\n- `useOnlineStatus` hook to detect connectivity\n- Offline banner to inform users\n\n> **See:** `references/offline-handling.md` for implementations\n\n## Background Sync\n\nQueue actions while offline, execute when connectivity returns:\n\n```javascript\n// In Service Worker\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'sync-data') {\n    event.waitUntil(syncPendingData());\n  }\n});\n\n// In App - trigger sync\nconst registration = await navigator.serviceWorker.ready;\nawait registration.sync.register('sync-data');\n```\n\n> **See:** `references/background-sync.md` for full IndexedDB integration\n\n## Update Flow\n\nNotify users when a new version is available:\n\n```typescript\n// Basic pattern\nregistration.addEventListener('updatefound', () => {\n  const newWorker = registration.installing;\n  newWorker?.addEventListener('statechange', () => {\n    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n      // New version available - show update prompt\n    }\n  });\n});\n```\n\n> **See:** `references/update-flow.md` for `usePWAUpdate` hook and update strategies\n\n## Next.js Integration\n\nOptions for Next.js PWA:\n\n1. **next-pwa** - Works with standard Next.js server\n2. **Custom SW** - Required for `output: 'export'` (static sites)\n3. **Workbox CLI** - Generate SW after build\n\n> **See:** `references/nextjs-integration.md` for detailed configurations\n\n## Quick Reference\n\n| Task | Solution |\n|------|----------|\n| Check if installed | `window.matchMedia('(display-mode: standalone)').matches` |\n| Force SW update | `registration.update()` |\n| Clear all caches | `caches.keys().then(keys => keys.forEach(k => caches.delete(k)))` |\n| Check online | `navigator.onLine` |\n| Get SW registration | `navigator.serviceWorker.ready` |\n| Skip waiting | `self.skipWaiting()` in SW |\n| Take control | `self.clients.claim()` in SW |\n\n## Testing PWA\n\n### Chrome DevTools\n\n1. **Application tab** â†’ Manifest, Service Workers, Cache Storage\n2. **Lighthouse** â†’ PWA audit\n3. **Network** â†’ Offline checkbox to simulate\n\n### Debug Checklist\n\n- [ ] Manifest loads (Application â†’ Manifest)\n- [ ] SW registered (Application â†’ Service Workers)\n- [ ] Cache populated (Application â†’ Cache Storage)\n- [ ] Install prompt fires (Console for beforeinstallprompt)\n- [ ] Offline page works (Network â†’ Offline)\n- [ ] Update flow works (trigger update, verify prompt)\n\n## References\n\nDetailed implementations in `/references/`:\n\n- `service-worker-patterns.md` - Caching strategy implementations\n- `install-prompt.md` - `usePWAInstall` hook and install component\n- `offline-handling.md` - Offline page, status hooks, banners\n- `background-sync.md` - Background sync with IndexedDB\n- `update-flow.md` - Update detection and user prompts\n- `nextjs-integration.md` - Next.js PWA configuration options\n"
    }
  ]
}